;| Muiltiline comment
Next example file
by Edward Puccini |;

; single line comment

; (mod 10 5)
; (mod 11 (mod 15 9))
; (mod 11 (mod 15 (mod 23 4)))
; (mod (mod 15 (mod 23 4)) 11)

; [1 2 3 4 5 6];

(module layer
    (defn fun1:i32 []
      (prnl "Module function fun1")
      (return 999))
        
    (defn fun2:i32 []
      (prnl "Module function fun2")
      (return 888)))

(compose monolith
        [string:string
         a:i32
         b:f32])

(defn mapit:f32 [op:f32]
  (prn "Map ")
  (prnl (+ op op))
  (return (+ op op)))

(defn reduceit:f32 [op1:f32 op2:f32]
  (prn "Reduce ")
  (prnl (f32 (+ op1 op2)))
  (return (+ op1 op2)))

(defn work:void [f:fun[f32->f32] arg:i32]
  (prnfmt "%f" (f arg)))

(defn arrays-and-lists:i32 [argc:i32]
  (mapit 5.5)
  (prnl "Call module functions ")
  (layer>>fun1)
  (layer>>fun2)
  (let [float1:f32 0.0
        float2:f32 (+ 0.0 0.0)
        array:i32# [1 2 3 4 5 6]
        arrayb:i32# [9 8 7 6 5 4 3 2 1]
        append-array:i32> (append array arrayb)
        rev-array:i32> (rev append-array)
        cdr-array:i32> (cdr array)
        values:f32# [1.0 2.0 3.0 4.0 5.0 6.0]
        my-new-array:f32> (mapn mapit values)
        my-new-floats:f32> (new 10)
        my-new-array2:f32> (append values 1000.0)
        my-new-array3:f32> (append my-new-array2 2000.0)
        my-list:f32' '(1.0 2.0 3.0 4.0 5.0 6.0)
        my-listb:f32' '(7.0 8.0 9.0 10.0 11.0 12.0 13.0 14.0)
        append-my-list:f32' (append my-list my-listb)
        rev-list:f32' (rev append-my-list)
        cdr-my-list:f32' (cdr my-list)
        string:string "abcdefg"
        chars:c8# ['a' 'b' 'c' 'd' 'e' 'f' 'g']
        new-string:c8# "Just a string"
        myfun:fun[f32->f32] mapit]
    (:: (f32> (# my-new-floats 0)) 888.0)
    (prn "my-new-floats set 1. element: ")
    (prnl my-new-floats)
    (prn "array: ")
    (prnl array)
    (prn "cdr-array: ")
    (prnl cdr-array)
    (prn "append-array: ")
    (prnl append-array)
    (prn "rev-array: ")
    (prnl rev-array)
    (prn "my-list: ")
    (prnl my-list)
    (prn "cdr-my-list: ")
    (prnl cdr-my-list)
    (prn "append-my-list: ")
    (prnl append-my-list)
    (prn "rev-list: ")
    (prnl rev-list)
    (prn "My new array1: ")
    (prnl my-new-array)
    (prn "My new array1 length: ")
    (prnl (len my-new-array))
    (prn "My new array2: ")
    (prnl my-new-array2)
    (prn "My new array3: ")
    (prnl my-new-array3)
    (prn "My new array3 gets array values: ")
    (:: my-new-array3 values)
    (prnl my-new-array3)
    (prn "string print to string: ")
    (prnl new-string)
    (prnstr new-string "EDWARD")
    (prnl new-string)
    (prn "My list push ")
    (push my-list 888.0)
    (prnl my-list)
    (prn "My list set/push ")
    (:: my-list (push my-list 777.0))
    (prnl my-list)
    (prn "My list length ")
    (prnl (len my-list))
    (prn "My list length after push ")
    (prnl (len (f32> (push my-list 100.0))))
    (prn "My list car ")
    (prnl (f32 (car my-list)))
    (prn "My list remove 3 ")
    (remove my-list 3)
    (prnl my-list)
    (prn "My list pop ")
    (prnl (f32 (pop my-list)))
    (prn "My list length ")
    (prnl (len my-list))
    (prn "My list append ")
    (append my-list 666.0)
    (prnl my-list)
    (prn "My list element ")
    (prnl (f32 (# my-list 3)))
    (:: (f32> (# my-list 3)) 100.0)
    (prn "My list set ")
    (prnl my-list)
    (prn "My values ")
    (prnl values)
    (myfun 1000.0)
    (work mapit 100)
    (map mapit values)
    (reduce reduceit values)
    (prn "String: ")
    (prnl string)
    (prn "Chars: ")
    (prnl chars)
    (prn "sizeof: ")
    (prnl (@ string)) 
    (:: float1 666.0)
    (:: argc (+ 100 (- 1000 500) 100 (* 1000 500)))
    (prnl argc)
    (:: argc (+ 100 (- 1000 999)))
    (prnl argc)
    ;(del my-new-array)
    ;(del my-new-floats)
    ;(del my-new-array2)
    ;(del my-new-array3)
    (for [cnt:i32 0 < (max (len array) 1)]
      (:: (# array cnt) (* cnt 1000))
      (prnfmt "%d" (^ 2 cnt))
      (prn "ELT: ")
      (prnfmt "%d" (# array cnt))
      (prn "CNT: "))

    (del array)
    (prnl float1)
    (prnl float2)
    (prnl argc)
    (prnl "ENDE"))
  (prnl argc)
  (return 2))


(defn pointers:void []
  (let [value:i32 1000
        value2:i32 2000
        value3:i32 3000
        other:f32 1.0
        other_ptr:f32> (& other)
        value_ptr:i32> value
        value_ptr_ptr:i32>> value_ptr
        new_value_ptr:i32> value2]
    (prn "Value ")
    (prnl value)
    (prn "Pointer print ")
    (prnl value_ptr)
    (prn "deref Pointer ")
    (prnl (i32> (? value_ptr_ptr)))
    (prn "Other value ")
    (prnl other)
    (prn "Pointer deeref ")
    (prnl (f32 (? other_ptr)))
    (prn "Value 2 ")
    (:: value2 4000)
    (prnl new_value_ptr)
    (prn "New Value Pointer: Value 3 ")
    (:: new_value_ptr (& value3))
    (prnl (i32 (? new_value_ptr)))
    (prn "New Value Pointer: Value 3/alt ")
    (prnl new_value_ptr)))

(defn math:void []
  (let [a:f64 10.0
        b:f64 20.0
        c:f64 15.5
        d:f64 (round c)]
    (prn "d = round(c) = ")
    (prnl d)
    (prn "exp(a) = ")
    (prnl (exp a))
    (prn "sin(b) = ")
    (prnl (sin b))))

(defn compositions:void []
  (let [test:monolith {0}]
    (prnl "Test composition")
    (:: (i32> (ref (of test a))) 1000)
    (prn "test.a = ")
    (prnl (i32 (of test a)))))


(defn main:i32 []
  (let [ret:i32 (arrays-and-lists 77)]
    (pointers)
    (math)
    (compositions)
    (return ret)))
