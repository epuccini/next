;;; -----------------------------------------------------
;;; next - parser file
;;; -----------------------------------------------------
;;; File:     src/parser.lisp
;;; Date:     09:29:15 of Wednesday, 8/14/2019 (GMT+1)
;;; Author:   Edward Puccini
;;; -----------------------------------------------------

(in-package :next)

(require 'parse-float)

(defvar *code_list* '(""))
(defvar *definition_list* '(""))
(defvar *implementation_list* '(""))
(defvar *target* 'code)
(defvar *paranteses* 0)
(defvar *variables* nil)
(defvar *functions* nil)
(defvar *compositions* nil)
(defvar *signatures* nil)
(defvar *function-map* nil)
(defvar *current-function* nil)
(defvar *current-composition* nil)
(defvar *current-let-definition* nil)
(defvar *current-module* "")
(defvar *block* 0)
(defvar *error* nil)
(defvar *emitted* nil)
(defvar *generics-template* "")
(defvar *def-template* "")
(defvar *impl-template* "")
(defvar *is-main-defined* nil)
(defvar *infinite-arguments* 10000)

(defun load-templates ()
  (setf *def-template* (load-binary-data "../templates/code.h"))
  (setf *impl-template* (load-binary-data "../templates/code.c"))
  (setf *generics-template* (load-binary-data "../templates/generics.h")))

(defun is-main-defined-p ()
  *is-main-defined*)

(defun filter-expression (expression)
  (let* ((new-expr1 (regex-replace-all "-" expression "_"))
         (new-expr2 (regex-replace-all "\\√" new-expr1 "sqrt"))
         (new-expr3 (regex-replace-all "\\^" new-expr2 "power"))
         (new-expr4 (regex-replace-all "∑" new-expr3 "for"))
         (new-expr5 (regex-replace-all ">>" new-expr4 "__")))
    new-expr5))

(defun print-stack ()
  "Use swank to log a stack-trace."
  (let ((trace ""))
    (let* ((msg-lst (remove-if #'null
                               (swank-backend:call-with-debugging-environment
                                (lambda () (swank:backtrace 0 7)))))
           (stack-msg
            (progn
              (mapcar (lambda (msg)
                        (setf trace (concatenate 'string trace 
                                                   (format nil "~{~A ~}~%" msg))))
                      msg-lst) trace)))
      (print stack-msg))))

(defun final-error-msg (expr-list msg)
  (if (not *emitted*)
      (emit-code-call))
  (format t msg)
  (ignore-errors
   (regex-replace "\n" (format t "~%~{~a ~}~%" (subseq expr-list 0 40)) " "))
  (print-stack)
  (sb-ext:quit))

(defun error-msg (expr-list msg)
  (if (not *emitted*)
      (emit-code-call))
  (setf *error* t)
  (format t msg)
  (ignore-errors
   (regex-replace "\n" (format t "~%~{~a ~}~%" (subseq expr-list 0 40)) " ")))

(defun error-parameter-max (expr-list cnt max)
  (error-msg expr-list (format nil "Error too many parameter to function (~a). Only ~a parameter expected!~%"
             cnt max)))

(defun error-operator-not-defined (expr-list)
  (error-msg expr-list "~%Error no operator defined!~%"))

(defun error-no-type-def (expr-list type)
  (error-msg expr-list (format nil "~%Error no type >~a< defined!~%" type)))

(defun error-function-not-defined (expr-list)
  (error-msg expr-list "~%Error function not defined!~%"))

(defun error-missing-expression (expr-list)
  (error-msg expr-list "~%Error missing expression!~%"))

(defun error-function-type-unkown (expr-list type)
  (error-msg expr-list (format nil "~%Error function type >~a< unkown!~%" type)))

(defun error-syntax-error (expr-list)
  (error-msg expr-list "~%Error syntax error!~%"))

(defun error-missing-open-square-bracket (expr-list)
  (final-error-msg expr-list "~%Error missing square bracket!~%"))

(defun error-missing-open-parens (expr-list)
  (final-error-msg expr-list "~%Error missing open parens!~%"))

(defun error-missing-close-square-bracket (expr-list)
  (final-error-msg expr-list "~%Error missing square bracket!~%"))

(defun error-missing-close-parens (expr-list)
  (final-error-msg expr-list "~%Error missing close parens!~%"))

(defun error-variable-not-defined (expr-list variable)
  (error-msg expr-list
             (format nil "~%Error variable >~a< not defined!~%" variable)))

(defun error-function-vector-malformed (expr-list)
  (error-msg expr-list "~%Error function vector malformed!~%"))

(defun error-composition-vector-malformed (expr-list)
  (error-msg expr-list "~%Error composition vector malformed!~%"))

(defun error-let-vector-malformed (expr-list)
  (error-msg expr-list "~%Error let vector malformed!~%"))

(defun error-cant-infer-type (expr-list)
  (error-msg expr-list "~%Error cant determine type!~%"))

(defun error-only-lists-supported (expr-list)
  (error-msg expr-list "~%Error only lists supported!~%"))

(defun error-type-not-supported (expr-list type)
  (error-msg expr-list (format nil "~%Error type >~a< not supported!~%" type)))

(defun error-too-many-parens (expr-list)
  (error-msg expr-list "~%Error too many paranteses!~%"))

(defun upto-string (expression lower)
  (let ((str ""))
    (loop for x from lower to (1- (length expression)) do
         (if (equal #\" (elt expression x))
             (return-from upto-string str))
         (if (not (equal #\" (elt expression x)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-symbol (expression lower)
  (let ((str "")
        (stack '()))
    (loop for x from lower to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((equal #\" obj)
                  (return-from upto-symbol stack))
                 ((equal #\$ obj)
                  (push "$" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\; obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\( obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\) obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\{ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\} obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\[ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\] obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\% obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\& obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\, obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Newline obj)
                  (push (format nil "~a" #\Newline) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Return obj)
                  (push (format nil "~a" #\Newline) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Linefeed obj)
                  (push (format nil "~a" #\Newline) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Space obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 (t
                  (setf str (format nil "~a~a" str obj))))))
    (push str stack)))

(defun stack-length (stack)
  (let ((l 0))
    (mapcar #'(lambda (x) (setf l (+ l (length x))))
            stack)
    l))

(defun preprocess (expr)
  (let ((stack '())
        (expression (regex-replace-all "->" expr "$")))
    (loop for x from 0 to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((or (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\{ obj)
                      (equal #\} obj)
                      (equal #\% obj)
                      (equal #\& obj)
                      (equal #\, obj)
                      (equal #\; obj)
                      (equal #\< obj)
                      (equal #\> obj)
                      (equal #\# obj))
                  (push (format nil "~a" obj) stack))
                 ((equal #\∑ obj)
                  (push "∑" stack))
                 ((equal #\, obj)
                  (push "," stack))
                 ((equal #\Space obj)
                  (format nil " "))
                 ((equal #\Newline obj)
                  (push (format nil "~a" #\Newline) stack))
                 ((equal #\Return obj)
                  (push (format nil "~a" #\Newline) stack))
                 ((equal #\Linefeed obj)
                  (push (format nil "~a" #\Newline) stack))
                 ((equal #\Tab obj)
                  (format nil " "))
                 ((equal #\" obj)
                  (let ((str (upto-string expression (1+ x))))
                    (setf x (+ x 1 (length str)))
                    (push "\"" stack)
                    (push str stack)
                    (push "\"" stack)))
                 (t
                  (let ((inner-stack (upto-symbol expression x)))
                    (setf stack (append (reverse inner-stack) stack))
                    (setf x (+ x (1- (stack-length inner-stack)))))))))
    (reverse stack)))

(defun emit-code-call ()
  (let ((code "")
        (definition "")
        (implementation ""))
    (if *implementation_list*
        (format t "~%~{~a~}~%" *implementation_list*))
    (if *code_list*
        (format t "~%~{~a~}~%" *code_list*))
    (if *implementation_list*
        (setf implementation
              (format nil "~%~{~a~}~%" *implementation_list*)))
    (if *code_list*
        (progn
          (if (not (is-main-defined-p))
              (setf code (format nil "i32 main () ~%{~%~%~{~a~}~%" *code_list*))
              (setf code (format nil "~%~%~{~a~}~%" *code_list*)))))
    (if (not (is-main-defined-p))
        (setf code (format nil "~a~%destroy_ptr(pointer_list);~%return 0;~%}" code)))
    (setf *emitted* t)
    (values code definition implementation)))

(defun get-current-function ()
  (gethash *paranteses* *current-function*))

(defun get-last-function ()
  (gethash (1- *paranteses*) *current-function*))

(defun store-current-function (fun)
  (setf (gethash *paranteses* *current-function*) fun))

(defun get-composition-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-variable-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-function-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-iter-variable-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *variables*)
              (progn
                (return-from get-iter-variable-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-variable-name-x name cnt)))))))

(defun get-iter-variable-name (name)
  (get-iter-variable-name-x name *block*))

(defun get-iter-function-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *functions*)
              (progn
                (return-from get-iter-function-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-function-name-x name cnt)))))))


(defun get-iter-function-name (name)
  (get-iter-function-name-x name *block*))

(defun get-iter-composition-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *compositions*)
              (progn
                (return-from get-iter-composition-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-composition-name-x name cnt)))))))

(defun get-iter-composition-name (name)
  (get-iter-composition-name-x name *block*))



(defun is-function-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-function-name name)))
                 (hash-table-keys *functions*)))

(defun is-variable-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-variable-name name)))
                 (hash-table-keys *variables*)))

(defun is-iter-function-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-iter-function-name name)))
                 (hash-table-keys *functions*)))

(defun is-iter-variable-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-iter-variable-name name)))
                 (hash-table-keys *variables*)))

(defun is-iter-composition-p (type-name)
  (remove-if-not #'(lambda (x) (equal x (get-iter-composition-name type-name)))
                 (hash-table-keys *compositions*)))

(defun is-iter-composition-type-p (expr-list)
  (let* ((split (split ">>" (car expr-list)))
         (struct-type (gethash (get-iter-variable-name (car split)) *variables*))
         (struct-name (get-iter-composition-name (format nil "~a" struct-type))))
    (gethash (format nil "~a>>~a" struct-name (cadr split)) *variables*)))
  
(defun set-signature (name signature)
  (setf (gethash name *signatures*) signature))

(defun append-signature (name signature)
  (setf (gethash name *signatures*)
        (append (gethash name *signatures*) (list signature))))

(defun inc-parens ()
  (setq *paranteses* (1+ *paranteses*)))

(defun dec-parens ()
  (setq *paranteses* (1- *paranteses*)))

(defun inc-block ()
  (setq *block* (+ 1 *block*)))

(defun dec-block ()
  (zero-hash-variables)
  (zero-hash-functions)
  (zero-hash-compositions)
  (setq *block* (- *block* 1)))

(defun zero-parens ()
  (setq *paranteses* 0))

(defun zero-block ()
  (setq *block* 0))

(defun zero-hash-variables ()
  (dolist (var (hash-table-keys *variables*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-variable-name var) *variables*)))))

(defun zero-hash-functions ()
  (dolist (var (hash-table-keys *functions*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-function-name var) *functions*)))))

(defun zero-hash-compositions ()
  (dolist (var (hash-table-keys *compositions*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-function-name var) *compositions*)))))

(defun add-code (expression)
  ;(setf expression (filter-expression expression))
  (if expression
      (cond ((equal *target* 'code)
             (setf *code_list* (append *code_list* (list expression))))
            ((equal *target* 'implementation)
             (setf *implementation_list* (append *implementation_list*
                                                 (list expression))))
            ((equal *target* 'definition)
             (setf *definition_list* (append *definition_list*
                                             (list expression)))))))

(defun get-last-code ()
  (cond ((equal *target* 'code)
         (car (reverse *code_list*)))
        ((equal *target* 'implementation)
         (car (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (car (reverse *definition_list*)))))

(defun get-previous-code ()
  (cond ((equal *target* 'code)
         (cadr (reverse *code_list*)))
        ((equal *target* 'implementation)
         (cadr (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (cadr (reverse *definition_list*)))))

(defun get-function-value (fn-name)
  (gethash fn-name *function-map*))

(defun set-function-map (fn-name value)
  (setf (gethash fn-name *function-map*) value))

(defun is-function-map-p (fn-name)
  (remove-if-not #'(lambda (fn) (equal fn fn-name))
                 (hash-table-keys *function-map*)))

(defun register-function (name content)
  (set-function-map name content)
  (setf (gethash (get-function-name name) *functions*) 'function)
  (dbg "register-function: Register function >" name
       "< var >" content "<"))

(defun type-of-number-string (numstr)
  (cond ((and
          (typep (parse-integer numstr :junk-allowed t) 'integer)
          (not (find #\. numstr))) 'integer)
        ((search "d0" numstr)
         'double-float)
        ((typep (parse-float numstr
                             :junk-allowed t
                             :type 'single-float) 'single-float)
         'single-float)
        ((typep numstr 'string)
         'string)))

(defun inspect-function-type (expr-list)
  (dbg "inspect-function-type: next function: " (cadr expr-list))
  (if (equal "(" (car expr-list))
      (cond ((remove-if-not
              #'(lambda (x)
                  (equal x (get-iter-function-name (cadr expr-list))))
              (hash-table-keys *functions*))
             (return-from inspect-function-type
               (gethash
                (get-iter-function-name (cadr expr-list))
                *functions*))))
      (return-from inspect-function-type
        (gethash
         (get-iter-function-name (car expr-list))
         *functions*))))

(defun set-function-type (fn-name type)
  (setf (gethash (get-function-name fn-name) *functions*) type))

(defun parse-argument (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-argument: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           (dbg "parse-argument: OPEN ARG")
           (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
                (setf expr-list (cdr expr-list)))
           (if (find #\: (car expr-list))
               (add-code ","))
           (setf expr-list (parse-argument expr-list)))))
  expr-list)

(defun store-composition-variable (var-name type)
  (setf (gethash (format nil "~a>>~a"
                         (get-composition-name *current-composition*)
                         var-name) *variables*) type))

(defun parse-types (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-types: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (car def))
                 (dbg "parse-types: store composition variable "
                      (format nil "~a>>~a"
                              (get-composition-name *current-composition*) (car def))
                      " type " (cadr def))
                 (store-composition-variable (car def) (cadr def))
                 (dbg "parse-types: store composition "
                      (get-composition-name *current-composition*)
                      " " (car def))
                 (setf (gethash (get-composition-name *current-composition*) *compositions*)
                       (car def))))
           (dbg "parse-types: OPEN ARG")
           (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
                (setf expr-list (cdr expr-list)))
           (add-code (format nil ";~%"))
           (setf expr-list (parse-types expr-list)))))
  expr-list)

(defun parse-function-type (expr-list &optional (signature nil))
  (let ((fn-name (car (split ":" (car expr-list))))
        (type (cadr (split ":" (car expr-list)))))
    (cond ((equal "i16" type)
           (add-code "i16")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer)
           (setf expr-list (cdr expr-list)))
          ((equal "i32" type)
           (add-code "i32")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer)
           (setf expr-list (cdr expr-list)))
          ((equal "i64" type)
           (add-code "i64")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint)
           (setf expr-list (cdr expr-list)))
          ((equal "ui16" type)
           (add-code "ui16")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-short-integer)
           (setf expr-list (cdr expr-list)))
          ((equal "ui32" type)
           (add-code "ui32")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-integer)
           (setf expr-list (cdr expr-list)))
          ((equal "ui64" type)
           (add-code "ui64")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-bigint)
           (setf expr-list (cdr expr-list)))
          ((equal "f32" type)
           (add-code "f32")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float)
           (setf expr-list (cdr expr-list)))
          ((equal "f64" type)
           (add-code "f64")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float)
           (setf expr-list (cdr expr-list)))
          ((equal "f80" type)
           (add-code "f80")
           (setf (gethash (get-function-name fn-name) *functions*) 'long-double-float)
           (setf expr-list (cdr expr-list)))
          ((equal "b8" type)
           (add-code "char")
           (setf (gethash (get-function-name fn-name) *functions*) 'char)
           (setf expr-list (cdr expr-list)))
          ((equal "c8" type)
           (add-code "char")
           (setf (gethash (get-function-name fn-name) *functions*) 'char)
           (setf expr-list (cdr expr-list)))
          ((equal "bool" type)
           (add-code "bool")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean)
           (setf expr-list (cdr expr-list)))
          ((equal "file" type)
           (add-code "file")
           (setf (gethash (get-function-name fn-name) *functions*) 'file)
           (setf expr-list (cdr expr-list)))
          ((equal "string" type)
           (add-code "string")
           (setf (gethash (get-function-name fn-name) *functions*) 'string)
           (setf expr-list (cdr expr-list)))
          ((equal "cstring" type)
           (add-code "const string")
           (setf (gethash (get-function-name fn-name) *functions*) 'const-string)
           (setf expr-list (cdr expr-list)))
          
          ((equal "bool#" type)
           (add-code "bool")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-array)
           (setf expr-list (cdr expr-list)))
          ((equal "b8#" type)
           (add-code "b8")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf expr-list (cdr expr-list)))
          ((equal "c8#" type)
           (add-code "c8")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf expr-list (cdr expr-list)))
          ((equal "i16#" type)
           (add-code "i16")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-array)
           (setf expr-list (cdr expr-list)))
          ((equal "i32#" type)
           (add-code "i32")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-array)
           (setf expr-list (cdr expr-list)))
          ((equal "i64#" type)
           (add-code "i64")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-array)
           (setf expr-list (cdr expr-list)))
          ((equal "ui16#" type)
           (add-code "ui16")
           (setf (gethash (get-function-name fn-name) *functions*)
                 'unsigned-short-integer-array)
           (setf expr-list (cdr expr-list)))
          ((equal "ui32#" type)
           (add-code "ui32")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-integer-array)
           (setf expr-list (cdr expr-list)))
          ((equal "ui64#" type)
           (add-code "ui64")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-bigint-array)
           (setf expr-list (cdr expr-list)))
          ((equal "f32#" type)
           (add-code "f32")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-array)
           (setf expr-list (cdr expr-list)))
          ((equal "f64#" type)
           (add-code "f64")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-array)
           (setf expr-list (cdr expr-list)))
          ((equal "f80#" type)
           (add-code "f80")
           (setf (gethash (get-function-name fn-name) *functions*) 'long-double-float-array)
           (setf expr-list (cdr expr-list)))
          
          ((equal "bool>" type)
           (add-code "bool*")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "b8>" type)
           (add-code "b8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "c8>" type)
           (add-code "c8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "i16>" type)
           (add-code "i16*")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "i32>" type)
           (add-code "i32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "i64>" type)
           (add-code "i64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "ui16>" type)
           (add-code "ui16*")
           (setf (gethash (get-function-name fn-name) *functions*)
                 'unsigned-short-integer-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "ui32>" type)
           (add-code "ui32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-integer-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "ui64>" type)
           (add-code "ui64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-bigint-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "f32>" type)
           (add-code "f32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "f64>" type)
           (add-code "f64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "f80>" type)
           (add-code "f80*")
           (setf (gethash (get-function-name fn-name) *functions*) 'long-double-float-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "file>" type)
           (add-code "file*")
           (setf (gethash (get-function-name fn-name) *functions*) 'file-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "string>" type)
           (add-code "char**")
           (setf (gethash (get-function-name fn-name) *functions*) 'string-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "cstring>" type)
           (add-code "const char**")
           (setf (gethash (get-function-name fn-name) *functions*) 'const-string-pointer)
           (setf expr-list (cdr expr-list)))

          ((equal "bool'" type)
           (add-code "node_bool*")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-list)
           (setf expr-list (cdr expr-list)))
          ((equal "b8'" type)
           (add-code "node_b8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-list)
           (setf expr-list (cdr expr-list)))
          ((equal "c8'" type)
           (add-code "node_c8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-list)
           (setf expr-list (cdr expr-list)))
          ((equal "i16'" type)
           (add-code "node_i16*")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-list)
           (setf expr-list (cdr expr-list)))
          ((equal "i32'" type)
           (add-code "node_i32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-list)
           (setf expr-list (cdr expr-list)))
          ((equal "i64'" type)
           (add-code "node_i64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-list)
           (setf expr-list (cdr expr-list)))
          ((equal "ui16'" type)
           (add-code "node_ui16*")
           (setf (gethash (get-function-name fn-name) *functions*)
                 'unsigned-short-integer-list)
           (setf expr-list (cdr expr-list)))
          ((equal "ui32'" type)
           (add-code "node_ui32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-integer-list)
           (setf expr-list (cdr expr-list)))
          ((equal "ui64'" type)
           (add-code "node_ui64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'unsigned-bigint-list)
           (setf expr-list (cdr expr-list)))
          ((equal "f32'" type)
           (add-code "node_f32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-list)
           (setf expr-list (cdr expr-list)))
          ((equal "f64'" type)
           (add-code "node_f64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-list)
           (setf expr-list (cdr expr-list)))
          ((equal "f80'" type)
           (add-code "node_f80*")
           (setf (gethash (get-function-name fn-name) *functions*) 'long-double-float-list)
           (setf expr-list (cdr expr-list)))

          ((equal "void" type)
           (add-code "void")
           (setf (gethash (get-function-name fn-name) *functions*) 'void)
           (setf expr-list (cdr expr-list)))
          ((equal "[" type)
           (add-code "void")
           (setf (gethash (get-function-name fn-name) *functions*) 'void))
          ((is-iter-composition-p type)
           (add-code (get-iter-composition-name "struct "))
           (add-code type)
           (setf (gethash (get-function-name fn-name) *functions*) type))
          ((equal "fun" type)
           (if signature
               (progn
                 (dbg "parse-function-type: signature " signature)
                 (dbg "parse-function-type: signature "
                      (format nil "~a (*~a)(~a)"
                              (car (reverse signature))
                              (get-function-name fn-name)
                              (cdr (reverse signature))))
                 (add-code (format nil "~a (*~a)(~a)"
                                   (car (reverse signature))
                                   (get-function-name fn-name)
                                   (cadr (reverse signature))))
                 (setf (gethash (get-function-name fn-name) *functions*) 'function))
               (progn
                 (add-code "single_fn_f32")
                 (setf (gethash (get-function-name fn-name) *functions*) 'function)))
           (setf expr-list (cdr expr-list)))
          (t
           (dbg "parse-function-type: " (hash-table-keys *compositions*) " type " type)
           (if (not type)
               (error-no-type-def expr-list type)
               (error-function-type-unkown expr-list type)))))
   
  expr-list)

(defun parse-function-name-and-type (expr-list)
  (cond ((stringp (car expr-list))
         (let* ((def (split ":" (car expr-list)))
                (fn-name (car def)))
           (dbg "parse-function-name-and-type: Functionname " fn-name)
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-function-name-and-type: signature "
                      (gethash (car def) *signatures*))
                 (setf expr-list (parse-function-type expr-list
                                      (gethash (car def) *signatures*))))
               (progn
                 (setf expr-list (parse-function-type expr-list))))
           (add-code " ")
           (cond ((equal fn-name "main")
                  (setf *is-main-defined* t)
                  (add-code fn-name))
                 (t
                  (add-code (get-function-name fn-name)))))))
  (dbg "parse-function-name-and-type: EXIT Rest. ")
  expr-list)

(defun parse-variable-type (expr-list var-name type &optional (signature nil))
  (cond ((equal "i16" type)
         (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i32" type)
         (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i64" type)
         (add-code "i64")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint))
        ((equal "ui16" type)
         (add-code "ui16")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-short-integer))
        ((equal "ui32" type)
         (add-code "ui32")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer))
        ((equal "ui64" type)
         (add-code "ui64")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint))
        ((equal "f32" type)
         (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float))
        ((equal "f64" type)
         (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float))
        ((equal "f80" type)
         (add-code "f80")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float))
        ((equal "bool" type)
         (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean))
        ((equal "b8" type)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "c8" type)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "file" type)
         (add-code "file")         
         (setf (gethash (get-variable-name var-name) *variables*) 'file))
        ((equal "string" type)
         (add-code "string")         
         (setf (gethash (get-variable-name var-name) *variables*) 'string))
        ((equal "cstring" type)
         (add-code "const string")         
         (setf (gethash (get-variable-name var-name) *variables*) 'const-string))
        
        ((equal "bool#" type)
         (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-array))
        ((equal "b8#" type)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "c8#" type)
         (add-code "c8")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "i16#" type)
         (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-array))
        ((equal "i32#" type)
         (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-array))
        ((equal "i64#" type)
         (add-code "i64")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-array))
        ((equal "ui16#" type)
         (add-code "ui16")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-array))
        ((equal "ui32#" type)
         (add-code "ui32")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-array))
        ((equal "ui64#" type)
         (add-code "ui64")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-array))
        ((equal "f32#" type)
         (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-array))
        ((equal "f64#" type)
         (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-array))
        ((equal "f80#" type)
         (add-code "f80")
         (setf (gethash (get-variable-name var-name) *variables*) 'longdouble-float-array))
        
        ((equal "bool>>" type)
         (add-code "bool**")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-handle))
        ((equal "b8>>" type)
         (add-code "b8**")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-handle))
        ((equal "c8>>" type)
         (add-code "c8**")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-handle))
        ((equal "i16>>" type)
         (add-code "i16**")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-handle))
        ((equal "i32>>" type)
         (add-code "i32**")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-handle))
        ((equal "i64>>" type)
         (add-code "i64**")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-handle))
        ((equal "ui16>>" type)
         (add-code "ui16**")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-handle))
        ((equal "ui32>>" type)
         (add-code "ui32**")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-handle))
        ((equal "ui64>>" type)
         (add-code "ui64**")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-handle))
        ((equal "f32>>" type)
         (add-code "f32**")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-handle))
        ((equal "f64>>" type)
         (add-code "f64**")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-handle))
        ((equal "f80>>" type)
         (add-code "f80**")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float-handle))
        
        ((equal "bool>" type)
         (add-code "bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-pointer))
        ((equal "b8>" type)
         (add-code "b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "c8>" type)
         (add-code "c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "i16>" type)
         (add-code "i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-pointer))
        ((equal "i32>" type)
         (add-code "i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-pointer))
        ((equal "i64>" type)
         (add-code "i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-pointer))
        ((equal "ui16>" type)
         (add-code "ui16*")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-pointer))
        ((equal "ui32>" type)
         (add-code "ui32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-pointer))
        ((equal "ui64>" type)
         (add-code "ui64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-pointer))
        ((equal "f32>" type)
         (add-code "f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-pointer))
        ((equal "f64>" type)
         (add-code "f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-pointer))
        ((equal "f80>" type)
         (add-code "f80*")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float-pointer))
        ((equal "file>" type)
         (add-code "file*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'file-pointer))
        ((equal "string>" type)
         (add-code "string*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'string-pointer))
        ((equal "cstring>" type)
         (add-code "cstring*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'const-string-pointer))


        
        ((equal "bool'" type)
         (add-code "node_bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-list))
        ((equal "b8'" type)
         (add-code "node_b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "c8'" type)
         (add-code "node_c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "i16'" type)
         (add-code "node_i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-list))
        ((equal "i32'" type)
         (add-code "node_i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-list))
        ((equal "i64'" type)
         (add-code "node_i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-list))
        ((equal "ui16'" type)
         (add-code "node_ui16*")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-list))
        ((equal "ui32'" type)
         (add-code "node_ui32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-list))
        ((equal "ui64'" type)
         (add-code "node_ui64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-list))
        ((equal "f32'" type)
         (add-code "node_f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-list))
        ((equal "f64'" type)
         (add-code "node_f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-list))
        ((equal "f80'" type)
         (add-code "node_f80*")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float-list))
        ((is-iter-composition-p type)
         (add-code "struct ")
         (add-code (get-iter-composition-name type))
         (setf (gethash (get-variable-name var-name) *variables*) type))
        ((equal "fun" type)
         (if signature
             (progn
               (dbg "parse-variable-type: signature " signature)
               (dbg "parse-variable-type: signature "
                    (format nil "~a (*~a)(~a)"
                            (car (reverse signature))
                            (get-variable-name var-name)
                            (cdr (reverse signature))))
               (add-code (format nil "~a (*~a)(~a)"
                                 (car (reverse signature))
                                 (get-variable-name var-name)
                                 (cadr (reverse signature))))
               (setf (gethash (get-variable-name var-name) *variables*) 'function))
             (progn
               (add-code "single_fn_f32")
               (setf (gethash (get-variable-name var-name) *variables*) 'function))))
        (t
         (dbg "parse-variable-type: " (hash-table-keys *compositions*) " type " type)
         (if (not type)
             (error-no-type-def expr-list type)
             (error-type-not-supported expr-list type)))))

(defun parse-signature-vector (var-name expr-list)
  (dbg "parse-signature-vector: ENTRY " (car expr-list))
  (if (equal "$" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (equal "[" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-signature-vector: " (car expr-list))
        (setf (gethash var-name *signatures*) (append
                                               (gethash var-name *signatures*)
                                               (list (car expr-list))))
        (dbg "parse-signature-vector: " (gethash var-name *signatures*))
        (setf expr-list (parse-signature-vector var-name (cdr expr-list)))))
  (if (equal "]" (car expr-list))
      (progn
        (dbg "parse-signature-vector: EXIT " (car expr-list))
        (setf expr-list (cdr expr-list))
        (return-from parse-signature-vector expr-list)))
  expr-list)
  
(defun parse-variable (expr-list)
  (dbg "parse-variable: " (car expr-list))
  (cond ((equal (format nil "~a" #\Newline) (car expr-list))
         (dbg "parse-variable: RET")
         (setf expr-list (parse-variable (cdr expr-list))))
        ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-variable: DEFINE " (car expr-list))
           (if (or (equal (format nil "~a" #\Newline) (cadr expr-list))
                   (equal "]" (cadr expr-list)))
               (error-no-type-def expr-list (cadr def)))
           ;; store current variable
           (setf *current-let-definition* (cadr def))
           ;; parse signature
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list (parse-signature-vector
                                  (car def) (cdr expr-list)))
                 (dbg "parse-argument: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list (car def) (cadr def)
                                      (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))))
           ;; if function then register function
           (if (equal (format nil "~a"
                              (gethash (get-variable-name
                                        (car def)) *variables*))
                      "FUNCTION")
               (register-function (car def) (car expr-list))
               (progn
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           ;; if array emit brackezs
           (if (search "#" (cadr def))
               (add-code "[]"))
           ;; initialisation
           (add-code "=")
           (dbg "parse-variable: OPEN ARG")
           (if (equal (car expr-list) "]")
               (error-missing-expression expr-list))
           ;; parse initialisation
           (dbg "parse-variable: next ")
           (setf expr-list (parse-expression expr-list))
           ;; store poiner
           (dbg "parse-variable: append size ")
           (if (search "#" (cadr def))
               (add-code
                (format nil "append_ptr(~a, sizeof(~a)/sizeof(~a), ARRAY);~%"
                                 (get-variable-name (car def))
                                 (get-variable-name (car def))
                                 (regex-replace "#" (cadr def) ""))))
           (if (search ">" (cadr def))
               (add-code
                (format nil "append_ptr(~a, 1, VARIABLE);~%"
                                 (get-variable-name (car def)))))
           (dbg "parse-variable: rest " (car expr-list))))
        ((not (find #\: (car expr-list)))
         (setf expr-list (cdr expr-list))
         (error-syntax-error expr-list)))
  expr-list)

(defun parse-operator (expr-list)
  (dbg "parse-operator " (car expr-list) " next " (cadr expr-list))
  (cond ((and (equal ">" (car expr-list)) (equal "=" (cadr expr-list)))
         (setf expr-list (cddr expr-list))
         (add-code ">="))
        ((and (equal "<" (car expr-list)) (equal "=" (cadr expr-list)))
         (setf expr-list (cddr expr-list))
         (add-code "<="))
        ((and (equal ">" (car expr-list)) (not (equal "=" (cadr expr-list))))
         (setf expr-list (cdr expr-list))
         (add-code ">"))
        ((and (equal "<" (car expr-list)) (not (equal "=" (cadr expr-list))))
         (setf expr-list (cdr expr-list))
         (add-code "<"))
        ((equal "!=" (car expr-list))
         (setf expr-list (cdr expr-list))
         (add-code "!="))
        ((equal "==" (car expr-list))
         (setf expr-list (cdr expr-list))
         (add-code "=="))
        (t
         (error-operator-not-defined expr-list)))
  expr-list)

(defun parse-condition (expr-list)
  (dbg "parse-condition: " (car expr-list))
  (let ((left nil)
        (right nil))
    (cond ((not (equal (format nil "~a" #\Newline) (car expr-list)))
           (setf left expr-list)
           (dbg "parse-condition: parse left-side " (car left))
           (setf expr-list (parse-expression expr-list t))
           (setf expr-list (parse-operator expr-list))
           (setf right expr-list)
           (dbg "parse-condition: parse right-side " (car right))
           (setf expr-list (parse-expression expr-list t))
           (add-code ")")
           (add-code (format nil "~%"))
           (dbg "parse-condition: rest " (car expr-list))
           (return-from parse-condition expr-list))
          ((equal (format nil "~a" #\Newline) (car expr-list))
           (dbg "parse-condition: RET")
           (setf expr-list (parse-condition expr-list))))
    expr-list))

(defun parse-range (expr-list)
  (dbg "parse-range: " (car expr-list))
  (let ((operator "")
        (from 0)
        (to 0)
        (var-name ""))
    (cond ((equal (format nil "~a" #\Newline) (car expr-list))
           (dbg "parse-range: RET")
           (setf expr-list (parse-range expr-list)))
          ((find #\: (car expr-list))
           (let ((def (split ":" (car expr-list))))
             (dbg "parse-range: DEFINE " (car expr-list))
             (parse-variable-type expr-list (car def) (cadr def))
             (dbg "parse-range: OPEN ARG")
             (if (or (equal (format nil "~a" #\Newline) (cadr expr-list)) (equal "]" (cadr expr-list)))
                 (error-no-type-def expr-list (cadr def)))
             (add-code " ")
             (setf var-name (get-variable-name (car def)))
             (dbg "parse-range: get-variable-name " var-name)
             (add-code var-name)
             (add-code "=")
             (if (equal (cadr expr-list) "]")
                 (error-missing-expression expr-list))
             (dbg "parse-range: parse from ")
             (setf from expr-list)
             (setf expr-list (parse-expression (cdr expr-list) t))
             (add-code (format nil ";~%"))
             (add-code "for")
             (add-code "(")
             (add-code var-name)
             (add-code "=")
             (setf expr-list (parse-expression (cdr from) t))
             (add-code ";")
             (dbg "parse-range: parse operator " (car expr-list))
             (add-code var-name)
             (setf operator (car expr-list))
             (setf expr-list (parse-operator expr-list))
             (dbg "parse-range: parse to " (car expr-list))
             (setf to expr-list)
             (setf expr-list (parse-expression expr-list t))
             (add-code (format nil ";"))
             (add-code var-name)
             (if (or (equal operator "<") (equal operator "<="))
                 (add-code "++"))
             (if (or (equal operator ">") (equal operator ">="))
                 (add-code "--"))
             (if (equal operator "!=")
                 (add-code "++"))
             (add-code ")")
             (add-code (format nil "~%"))
             (dbg "parse-range: rest ")))
          ((not (find #\: (car expr-list)))
           (setf expr-list (cdr expr-list))
           (error-syntax-error expr-list)))
    expr-list))

(defun parse-block (expr-list)
  (dbg "parse-block " (car expr-list) " block " *block*)
  (if (not expr-list)
      (return-from parse-block expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (and (equal ";" (car expr-list)) (equal "|" (cadr expr-list)))
      (progn
        (dbg "parse-expression: parse multiline comment")
        (setf expr-list (parse-multiline-comment (cddr expr-list)))
        (setf expr-list (parse-block expr-list))
        (return-from parse-block expr-list)))
  (if (equal ";" (car expr-list))
      (progn
        (dbg "parse-expression: parse singleline comment")
        (setf expr-list (parse-single-line-comment (cdr expr-list)))
        (setf expr-list (parse-block expr-list))
        (return-from parse-block expr-list)))
  (if (equal "(" (car expr-list))
      (progn
        (dbg "parse-block before expression " (car expr-list))
        (setf expr-list (parse-expression expr-list))
        (sb-ext:gc)))
  (if (equal "\"" (car expr-list))
      (progn
        (dbg "parse-expression: STRING block " *block*)
        (add-code "\"")
        (setf expr-list (parse-cstr (cdr expr-list)))
        (dbg "parse-expression: STRING END ")
        (add-code (format nil ";~%"))
        (return-from parse-block expr-list)))
  (if (equal ")" (car expr-list))
      (return-from parse-block expr-list))
  (if (not (equal ")" (car expr-list)))
      (progn
        (dbg "parse-block " (car expr-list))
        (setf expr-list (parse-block (cdr expr-list))))))

(defun parse-function-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-function-vector: parse variable")  
    (setf expr-list (parse-argument expr-list))
    (if (equal "]" (car expr-list))
        (return-from parse-function-vector expr-list))
    (if (and (not (find #\: (cadr expr-list))) (not (equal "]" (cadr expr-list))))
        (error-function-vector-malformed expr-list))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-function-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-function-vector expr-list))))))

(defun parse-type-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-typevector: parse variable")  
    (setf expr-list (parse-types expr-list))
    (if (equal "]" (car expr-list))
        (return-from parse-type-vector expr-list))
    (if (and (not (find #\: (cadr expr-list))) (not (equal "]" (cadr expr-list))))
        (error-composition-vector-malformed expr-list))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-type-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-type-vector expr-list))))))

(defun parse-if-vector (expr-list)
  (dbg "parse-if-vector: condition range" (car expr-list))  
  (setf expr-list (parse-condition expr-list))
  (dbg "parse-if-vector: after condition " (car expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-if-vector expr-list))
  (dbg "parse-if-vector: after loop " (car expr-list))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-if-vector: next variable" (car expr-list))  
        (setf expr-list (parse-if-vector expr-list))))
  (dbg "parse-if-vector: exit" (car expr-list))
  expr-list)

(defun parse-for-vector (expr-list)
  (dbg "parse-for-vector: parse range")  
  (setf expr-list (parse-range expr-list))
  (if (equal "]" (car expr-list))
      (return-from parse-for-vector expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-for-vector: next variable")  
        (setf expr-list (parse-for-vector expr-list))))
  (dbg "parse-for-vector: exit" (car expr-list))
  expr-list)

(defun parse-let-vector (expr-list)
  (dbg "parse-let-vector: parse variable")  
  (setf expr-list (parse-variable expr-list))
  (if (equal "]" (car expr-list))
      (return-from parse-let-vector expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-let-vector: next variable")  
        (setf expr-list (parse-let-vector expr-list))))
  (dbg "parse-let-vector: exit" (car expr-list))
  expr-list)

(defun parse-open-square-bracket (expr-list)
  (dbg "parse-open-square-bracket")  
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "[" (car expr-list))
      (return-from parse-open-square-bracket (cdr expr-list))
      (error-missing-open-square-bracket expr-list)))

(defun parse-close-square-bracket (expr-list)
  (dbg "parse-close-square-bracket")  
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-close-square-bracket (cdr expr-list))
      (error-missing-close-square-bracket expr-list)))

(defun parse-open-parens (expr-list)
  (dbg "parse-open-parens")  
  (if (equal "(" (car expr-list))
      (return-from parse-open-parens (cdr expr-list))
      (error-missing-open-parens expr-list)))

(defun parse-close-parens (expr-list)
  (dbg "parse-close-parens")  
  (if (equal ")" (car expr-list))
      (return-from parse-close-parens (cdr expr-list))
      (error-missing-close-parens expr-list)))

(defun parse-if (expr-list)
  (inc-block)
  (dbg "parse-if: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-expression expr-list))
  (add-code (format nil "}~%"))
  (if (not (equal ")" (car expr-list)))
      (progn
        (add-code "else")
        (add-code (format nil "~%{~%"))

        (setf expr-list (parse-expression expr-list))
        (add-code (format nil "}~%"))))
  (dec-block)
  (dbg "parse-if BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-while (expr-list)
  (inc-block)
  (dbg "parse-while: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-block expr-list))
  (add-code (format nil "};~%"))
  (dec-block)
  (dbg "parse-while BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-for (expr-list)
  (inc-block)
  (dbg "parse-for: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-for-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-for BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-for ")
  expr-list)

(defun parse-let (expr-list)
  (inc-block)
  (dbg "parse-let: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-let-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-let BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-let ")
  expr-list)

(defun parse-compose (expr-list)
  (let ((composition-name (get-composition-name (car expr-list))))
    (setf *current-composition* (car expr-list))
    (dbg "parse-compose: name " *current-composition*
         " and type block " *block*
         " parens " *paranteses*)
    (dbg "parse-compose: open square")
    (add-code (format nil "struct ~a" composition-name))
    (add-code (format nil "~%{~%"))
    (setf expr-list (cdr expr-list))
    (setf expr-list (parse-open-square-bracket expr-list))
    (setf expr-list (parse-type-vector expr-list))
    (setf expr-list (parse-close-square-bracket expr-list))
    (add-code (format nil "};~%"))
    (add-code (format nil "typedef struct ~a ~a;~%" composition-name composition-name))
    (dbg "parse-compose BLOCK END block " *block* " parens " *paranteses*)
    (dbg "parse-compose " (car expr-list))
    (setf *current-composition* "")
    expr-list))

(defun parse-def-function (expr-list)
  (let ((fn-name (car expr-list)))
  (dbg "parse-def-function: name and type block " *block* " parens " *paranteses*)
  (setf expr-list (parse-function-name-and-type expr-list))
  (inc-block)
  (dbg "parse-def-function: open square")
  (add-code "(")
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-function-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code ")")
  (add-code (format nil "~%{~%"))
  (setf expr-list (parse-block expr-list))
  (if (search "main" fn-name)
      (add-code (format nil "destroy_ptr(pointer_list);~%")))
  (add-code (format nil "}~%"))
  (dec-block)
  (dbg "parse-def-function BLOCK END block " *block* " parens " *paranteses*)
  (dbg "parse-def-function " (car expr-list))
  expr-list))

(defun parse-module (expr-list)
  (setf *current-module* (car expr-list))
  (inc-block)
  (setf expr-list (cdr expr-list))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (setf *current-module* "")
  expr-list)

(defun parse-multiline-comment (expr-list)
  (if (not expr-list) (return-from parse-multiline-comment expr-list))
  (cond ((and (equal "|" (car expr-list)) (equal ";" (cadr expr-list)))
         (dbg "parse-multiline-comment: CLOSE")
         (return-from parse-multiline-comment (cddr expr-list)))
        ((stringp (car expr-list))
         (dbg "parse-multiline-comment: COMMENT >" (car expr-list) "<")
         (setf expr-list (parse-multiline-comment (cdr expr-list))))))

(defun parse-single-line-comment (expr-list)
  (if (not expr-list) (return-from parse-single-line-comment expr-list))
  (cond ((equal (format nil "~a" #\Newline) (car expr-list))
         (if (or (equal (format nil "~a" #\Newline) (cadr expr-list))
                 (equal ";" (cadr expr-list)))
             (setf expr-list (parse-single-line-comment (cdr expr-list)))
             (setf expr-list (cdr expr-list)))
         (return-from parse-single-line-comment expr-list))
        ((not (equal (format nil "~a" #\Newline) (car expr-list)))
         (dbg "parse-singleline-comment: COMMENT " (car expr-list))
         (setf expr-list (parse-single-line-comment (cdr expr-list))))))

(defun parse-null (expr-list)
  (cond ((equal "}" (car expr-list))
         (add-code (car expr-list))
         (return-from parse-null (cdr expr-list)))
        ((not (equal "}" (car expr-list)))
         (dbg "parse-null: " (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-null (cdr expr-list))))))

(defun parse-cstr (expr-list)
  (cond ((equal "\"" (car expr-list))
         (add-code "\"")
         (setf expr-list (cdr expr-list))
         (return-from parse-cstr expr-list))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-cstr (cdr expr-list)))))
  expr-list)

(defun parse-element (expr-list)
  (dbg "parse-element " (car expr-list))
  (cond ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", ")))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", "))))
  (cdr expr-list))
             
(defun parse-vector (expr-list)
  (dbg "parse-vector " (car expr-list))
  (cond ((equal "[" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-vector expr-list))))
        ((equal "]" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-vector expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-vector expr-list)))))
  expr-list)
  
(defun parse-list (expr-list)
  (dbg "parse-list " (car expr-list))
  (cond ((equal "'(" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-list expr-list))))
        ((equal ")" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-list expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-list expr-list)))))
  expr-list)
  
(defun count-elements (expr-list)
  (let ((count 0)
        (parens 0))
    (loop for x from 0 to (1- (length expr-list)) do
         (if (or (equal "(" (elt expr-list x))
                 (equal "[" (elt expr-list x)))
             (progn
               (if (= parens 0)
                   (setf count (1+ count)))
               (setf parens (1+ parens))))
         (if (or (equal ")" (elt expr-list x))
                 (equal "]" (elt expr-list x)))
             (progn
               (setf parens (1- parens))
               (if (< parens 0)
                   (return-from count-elements count))))
         (if (and (not (equal "(" (elt expr-list x)))
                  (not (equal ")" (elt expr-list x))))
             (progn
               (if (= parens 0)
                   (setf count (1+ count))))))
    count))

(defun is-type-cast-p (cast)
  (or (equal "i16" cast)
      (equal "i32" cast)
      (equal "i64" cast)
      (equal "ui16" cast)
      (equal "ui32" cast)
      (equal "ui64" cast)
      (equal "f32" cast)
      (equal "f64" cast)
      (equal "f80" cast)
      (equal "bool" cast)
      (equal "b8" cast)
      (equal "c8" cast)
      (equal "string" cast)
      (equal "i16>" cast)
      (equal "i32>" cast)
      (equal "i64>" cast)
      (equal "ui16>" cast)
      (equal "ui32>" cast)
      (equal "ui64>" cast)
      (equal "f32>" cast)
      (equal "f64>" cast)
      (equal "f80>" cast)
      (equal "bool>" cast)
      (equal "b8>" cast)
      (equal "c8>" cast)
      (equal "string>" cast)
      (equal "i16#" cast)
      (equal "i32#" cast)
      (equal "i64#" cast)
      (equal "ui16#" cast)
      (equal "ui32#" cast)
      (equal "ui64#" cast)
      (equal "f32#" cast)
      (equal "f64#" cast)
      (equal "f80#" cast)
      (equal "bool#" cast)
      (equal "b8#" cast)
      (equal "c8#" cast)
      (equal "string#" cast)
      (equal "i16'" cast)
      (equal "i32'" cast)
      (equal "i64'" cast)
      (equal "ui16'" cast)
      (equal "ui32'" cast)
      (equal "ui64'" cast)
      (equal "f32'" cast)
      (equal "f64'" cast)
      (equal "f80'" cast)
      (equal "bool'" cast)
      (equal "b8'" cast)
      (equal "c8'" cast)
      (equal "string'" cast)
      (equal "i16>>" cast)
      (equal "i32>>" cast)
      (equal "i64>>" cast)
      (equal "ui16>>" cast)
      (equal "ui32>>" cast)
      (equal "ui64>>" cast)
      (equal "f32>>" cast)
      (equal "f64>>" cast)
      (equal "f80>>" cast)
      (equal "bool>>" cast)
      (equal "b8>>" cast)
      (equal "c8>>" cast)
      (equal "string>>" cast)))

(defun get-iter-composition-type (expr-list)
  (let* ((split (split ">>" (car expr-list)))
         (lst (cdr (reverse (cdr (reverse split)))))
         (struct-type (gethash (get-iter-variable-name (car split)) *variables*))
         (struct-name (get-iter-composition-name (format nil "~a" struct-type)))
         (var-name (cadr split))
         (count 2)
         (composition (format nil "~a>>~a" struct-name var-name)))
    (if (= (length split) 2)
        (progn
          (dbg "get-iter-composition-type: composition " composition)
          (return-from get-iter-composition-type (gethash composition *variables*))))
    (loop for sub-name in lst do
         (dbg "get-iter-composition: sub-name " sub-name)
         (dbg "get-iter-composition: composition " composition)
         (setf struct-type
               (gethash composition *variables*))
         (dbg "get-iter-composition-type: struct-type " struct-type)
         (setf struct-name (get-iter-composition-name (format nil "~a" struct-type)))
         (dbg "get-iter-composition-type: struct-name " struct-name)
         (setf var-name (elt split count))
         (dbg "get-iter-composition-type: var-name " var-name)
         (setf count (1+ count))
         (setf composition (format nil "~a>>~a" struct-name var-name))
         (dbg "get-iter-composition-type: composition " composition))
    (gethash composition *variables*)))

(defun build-dotted-type (composition)
  (let* ((split (split ">>" composition))
         (lst (cdr split))
         (var-name (elt split 0))
         (str nil))
    (setf str (concatenate 'string (get-iter-variable-name var-name)))
    (loop for sub-name in lst do
         (setf str (concatenate 'string str "." sub-name)))
    (dbg "build-dotted-type " str)
    str))

(defun get-type (expr-list)
  (let* ((variable-type (gethash (get-iter-variable-name (cadr expr-list)) *variables*))
         (number-type (type-of-number-string (cadr expr-list)))
         (function-type (inspect-function-type (cdr expr-list)))
         (tp nil)
         (tp-str ""))
    (if (is-iter-composition-type-p (cdr expr-list))
        (progn
          (dbg "get-type: composition found! " (get-iter-composition-type (cdr expr-list)))
          (setf variable-type (get-iter-composition-type (cdr expr-list)))
          (dbg "get-type: var-type: " (format nil "~a" variable-type))))
    ;; variable found?
    (cond ((is-iter-variable-p (cadr expr-list))
           (dbg "get-type: variable-type " (format nil "~a" tp))
           (setf tp variable-type))
           ;; struct member found?
          ((is-iter-composition-type-p (cdr expr-list))
           (setf tp-str (format nil "~a" variable-type))
           (return-from get-type tp-str))
          (function-type
           (setf tp function-type))
          (number-type
           (setf tp number-type)))
    (cond ((equal tp 'boolean)
           (setf tp-str "bool"))
          ((equal tp 'b8)
           (setf tp-str "char"))
          ((equal tp 'short-integer)
           (setf tp-str "i16"))
          ((equal tp 'integer)
           (setf tp-str "i32"))
          ((equal tp 'bigint)
           (setf tp-str "i64"))
          ((equal tp 'unsigned-short-integer)
           (setf tp-str "ui16"))
          ((equal tp 'unsigned-integer)
           (setf tp-str "ui32"))
          ((equal tp 'unsigned-bigint)
           (setf tp-str "ui64"))
          ((equal tp 'double-float)
           (setf tp-str "f64"))
          ((equal tp 'single-float)
           (setf tp-str "f32"))
          ((equal tp 'long-double-float)
           (setf tp-str "f80"))
          ((equal tp 'string)
           (setf tp-str "string"))
          ((equal tp 'const-string)
           (setf tp-str "cstring"))
          ((equal tp 'file)
           (setf tp-str "file"))
          
          ((equal tp 'boolean-array)
           (setf tp-str "array_bool"))
          ((equal tp 'char-array)
           (setf tp-str "array_c8"))
          ((equal tp 'char-array)
           (setf tp-str "array_b8"))
          ((equal tp 'short-integer-array)
           (setf tp-str "array_i16"))
          ((equal tp 'integer-array)
           (setf tp-str "array_i32"))
          ((equal tp 'bigint-array)
           (setf tp-str "array_i64"))
          ((equal tp 'unsigned-short-integer-array)
           (setf tp-str "array_ui16"))
          ((equal tp 'unsigned-integer-array)
           (setf tp-str "array_ui32"))
          ((equal tp 'unsigned-bigint-array)
           (setf tp-str "array_ui64"))
          ((equal tp 'double-float-array)
           (setf tp-str "array_f64"))
          ((equal tp 'single-float-array)
           (setf tp-str "array_f32"))
          ((equal tp 'long-double-float-array)
           (setf tp-str "array_f80"))
          
          ((equal tp 'boolean-pointer)
           (setf tp-str "pointer_bool"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_c8"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_b8"))
          ((equal tp 'short-integer-pointer)
           (setf tp-str "pointer_i16"))
          ((equal tp 'integer-pointer)
           (setf tp-str "pointer_i32"))
          ((equal tp 'bigint-pointer)
           (setf tp-str "pointer_i64"))
          ((equal tp 'unsigned-short-integer-pointer)
           (setf tp-str "pointer_ui16"))
          ((equal tp 'unsigned-integer-pointer)
           (setf tp-str "pointer_ui32"))
          ((equal tp 'unsigned-bigint-pointer)
           (setf tp-str "pointer_ui64"))
          ((equal tp 'double-float-pointer)
           (setf tp-str "pointer_f64"))
          ((equal tp 'single-float-pointer)
           (setf tp-str "pointer_f32"))
          ((equal tp 'long-double-float-pointer)
           (setf tp-str "pointer_f80"))
          ((equal tp 'string-pointer)
           (setf tp-str "pointer_string"))
          ((equal tp 'const-string-pointer)
           (setf tp-str "pointer_cstring"))
          ((equal tp 'file-pointer)
           (setf tp-str "pointer_file"))

          ((equal tp 'boolean-handle)
           (setf tp-str "handle_bool"))
          ((equal tp 'char-handle)
           (setf tp-str "handle_c8"))
          ((equal tp 'char-handle)
           (setf tp-str "handle_b8"))
          ((equal tp 'short-integer-handle)
           (setf tp-str "handle_i16"))
          ((equal tp 'integer-handle)
           (setf tp-str "handle_i32"))
          ((equal tp 'bigint-handle)
           (setf tp-str "handle_i64"))
          ((equal tp 'unsigned-short-integer-handle)
           (setf tp-str "handle_ui16"))
          ((equal tp 'unsigned-integer-handle)
           (setf tp-str "handle_ui32"))
          ((equal tp 'unsigned-bigint-handle)
           (setf tp-str "handle_ui64"))
          ((equal tp 'double-float-handle)
           (setf tp-str "handle_f64"))
          ((equal tp 'single-float-handle)
           (setf tp-str "handle_f32"))
          ((equal tp 'long-double-float-handle)
           (setf tp-str "handle_f80"))

          ((equal tp 'boolean-list)
           (setf tp-str "list_bool"))
          ((equal tp 'char-list)
           (setf tp-str "list_c8"))
          ((equal tp 'char-list)
           (setf tp-str "list_b8"))
          ((equal tp 'short-interger-list)
           (setf tp-str "list_i16"))
          ((equal tp 'integer-list)
           (setf tp-str "list_i32"))
          ((equal tp 'bigint-list)
           (setf tp-str "list_i64"))
          ((equal tp 'unsigned-short-interger-list)
           (setf tp-str "list_ui16"))
          ((equal tp 'unsigned-integer-list)
           (setf tp-str "list_ui32"))
          ((equal tp 'unsigned-bigint-list)
           (setf tp-str "list_ui64"))
          ((equal tp 'double-float-list)
           (setf tp-str "list_f64"))
          ((equal tp 'single-float-list)
           (setf tp-str "list_f32"))
          ((equal tp 'long-double-float-list)
           (setf tp-str "list_f80"))
          (t
           (setf tp-str "T")
           (error-cant-infer-type expr-list)))
    tp-str))


(defun get-math-type (expr-list)
  (let ((variable-type (gethash (get-iter-variable-name (cadr expr-list)) *variables*))
        (number-type (type-of-number-string (cadr expr-list)))
        (function-type (inspect-function-type (cdr expr-list)))
        (tp nil)
        (tp-str ""))
    (if (is-iter-composition-type-p (cdr expr-list))
        (progn
          (dbg "get-math-type: composition found! "
               (get-iter-composition-type (cdr expr-list)))
          (setf variable-type (get-iter-composition-type (cdr expr-list)))
          (dbg "get-math-type: var-type: " (format nil "~a" variable-type))))
    ;; variable found?
    (cond ((remove-if-not #'(lambda (x)
                              (equal x (get-iter-variable-name (cadr expr-list))))
                          (hash-table-keys *variables*))
           (setf tp variable-type))
          ((is-iter-composition-type-p (cdr expr-list))
           (setf tp-str (format nil "~a" variable-type))
           (return-from get-math-type tp-str))
          (function-type
           (setf tp function-type))
          (number-type
           (setf tp number-type)))
    (cond ((equal tp 'short-integer)
           (setf tp-str "i16"))
          ((equal tp 'integer)
           (setf tp-str "i32"))
          ((equal tp 'bigint)
           (setf tp-str "i64"))
          ((equal tp 'unsigned-short-integer)
           (setf tp-str "ui16"))
          ((equal tp 'unsigned-integer)
           (setf tp-str "ui32"))
          ((equal tp 'unsigned-bigint)
           (setf tp-str "ui64"))
          ((equal tp 'double-float)
           (setf tp-str "f64"))
          ((equal tp 'single-float)
           (setf tp-str "f32"))
          ((equal tp 'long-double-float)
           (setf tp-str "f80"))
          
          ((equal tp 'boolean-pointer)
           (setf tp-str "pointer_bool"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_c8"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_b8"))
          ((equal tp 'short-integer-pointer)
           (setf tp-str "pointer_i16"))
          ((equal tp 'integer-pointer)
           (setf tp-str "pointer_i32"))
          ((equal tp 'bigint-pointer)
           (setf tp-str "pointer_i64"))
          ((equal tp 'unsigned-short-integer-pointer)
           (setf tp-str "pointer_ui16"))
          ((equal tp 'unsigned-integer-pointer)
           (setf tp-str "pointer_ui32"))
          ((equal tp 'unsigned-bigint-pointer)
           (setf tp-str "pointer_ui64"))
          ((equal tp 'double-float-pointer)
           (setf tp-str "pointer_f64"))
          ((equal tp 'single-float-pointer)
           (setf tp-str "pointer_f32"))
          ((equal tp 'long-double-float-pointer)
           (setf tp-str "pointer_f80"))

          ((equal tp 'boolean-handle)
           (setf tp-str "handle_bool"))
          ((equal tp 'char-handle)
           (setf tp-str "handle_c8"))
          ((equal tp 'char-handle)
           (setf tp-str "handle_b8"))
          ((equal tp 'short-integer-handle)
           (setf tp-str "handle_i16"))
          ((equal tp 'integer-handle)
           (setf tp-str "handle_i32"))
          ((equal tp 'bigint-handle)
           (setf tp-str "handle_i64"))
          ((equal tp 'unsigned-short-integer-handle)
           (setf tp-str "handle_ui16"))
          ((equal tp 'unsigned-integer-handle)
           (setf tp-str "handle_ui32"))
          ((equal tp 'unsigned-bigint-handle)
           (setf tp-str "handle_ui64"))
          ((equal tp 'double-float-handle)
           (setf tp-str "handle_f64"))
          ((equal tp 'single-float-handle)
           (setf tp-str "handle_f32"))
          ((equal tp 'long-double-float-handle)
           (setf tp-str "handle_f80"))
          (t
           (setf tp-str "T")
           (error-cant-infer-type expr-list)))
    tp-str))

(defun if-cast-p ()
  (or (and (equal ")" (get-last-code))
           (equal "i16" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i32" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i64" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui16" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui32" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui64" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f32" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f64" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f80" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "bool" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "c8" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "b8" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i16*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i32*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i64*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui16*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui32*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui64*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f32*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f64*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f80*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "bool*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "c8*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "b8*" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i16**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i32**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "i64**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui16**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui32**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "ui64**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f32**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f64**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "f80**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "bool**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "c8**" (get-previous-code)))
      (and (equal ")" (get-last-code))
           (equal "b8**" (get-previous-code)))))

                    
(defun parse-arguments (expr-list max)
  (dbg "parse-arguments: >" (car expr-list) "<")
  (cond ((equal "\"" (car expr-list))
         (if (and *paranteses*
                  (not (equal "(" (get-last-code)))
                  (not (equal "&" (get-last-code)))
                  (not (equal "*" (get-last-code)))
                  (not (if-cast-p)))
             (add-code ","))
         (add-code "\"")
         (dbg "parse-arguments: parse-cstr >" (car expr-list) "<")
         (setf expr-list (parse-cstr (cdr expr-list)))
         (setf expr-list (parse-arguments expr-list max)))
        ((equal ")" (car expr-list))
         (let ((fn (get-current-function)))
           (dbg "parse-arguments: " (car expr-list) " function " fn)
           (dbg "parse-arguments: block " *block* " Parens " *paranteses*)
           (return-from parse-arguments expr-list)))
        ((equal "," (car expr-list))
         (error-syntax-error expr-list))
        ((equal (format nil "~a" #\Newline) (car expr-list))
         (setf expr-list (parse-arguments (cdr expr-list) max)))
        ((equal "'" (car expr-list))
            (let ((type (get-type (cddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-arguments: parse list literal ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (return-from parse-arguments expr-list)))
        ((equal "[" (car expr-list))
            (let ((type (get-type (cdr expr-list)))
                  (start (cdr expr-list)))
              (add-code (format nil "create_array_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-arguments: parse array literal ")
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (return-from parse-arguments expr-list)))
        ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (progn
           (dbg "parse-arguments: NUMBERP ")
           (if (and (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (equal "*" (get-last-code)))
                    (not (if-cast-p)))
               (add-code ","))
           (progn
             ; convert lisp double-float to c double
             (setf (car expr-list) (regex-replace-all "d0" (car expr-list) "f"))
             (add-code (car expr-list))
             (setf expr-list (parse-arguments (cdr expr-list) max)))))
        ((or (is-variable-split-name-p (car expr-list))
             (is-iter-variable-p (car expr-list)))
         (let ((comp-name (build-dotted-type (car expr-list)))
               (var-name (regex-replace ">>.*" (car expr-list) "")))
           (if (and (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (equal "*" (get-last-code)))
                    (not (if-cast-p)))
               (add-code ","))
           (dbg "parse-arguments: VARIABLE " (get-iter-variable-name var-name))
           (if (search ">>" (car expr-list))
               (add-code comp-name)
               (add-code (get-iter-variable-name var-name)))
           (setf expr-list (parse-arguments (cdr expr-list) max))
           (return-from parse-arguments expr-list)))
        ((is-iter-function-p (car expr-list))
         (progn
           (dbg "parse-arguments: last code " (get-previous-code))
           (add-code (get-iter-function-name (car expr-list)))
           (setf expr-list (parse-arguments (cdr expr-list) max))))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-arguments: VARIABLE not defined: "
              (get-iter-variable-name  (car expr-list))" block " *block*
              " hash " (hash-table-keys *variables*))
         (error-variable-not-defined expr-list (car expr-list)))
        ((equal "(" (car expr-list))
         (progn
           (if (and *paranteses*
                    (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (if-cast-p)))
               (add-code ","))
           (dbg "parse-arguments: parse-expression ( block "
                *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t))
           (setf expr-list (parse-arguments expr-list
                                            (1- (count-elements expr-list)))))))
  expr-list)

(defun parse-infix (expr-list function)
  (if (equal ")" (car expr-list))
      (progn
        (dbg "parse-infix: parens ) parens " *paranteses* " block " *block*)
        (dbg "parse-infix: EXIT ")
        (return-from parse-infix expr-list)))
  (dbg "parse-infix: operand " (car expr-list))
  (setf expr-list (parse-expression expr-list t))
  (if (and (not (equal ")" (car expr-list)))
           (not (equal (format nil "~a" #\Newline) (car expr-list))))
      (progn
        (add-code function)
        (setf expr-list (parse-infix expr-list function))))
  expr-list)

(defmacro parse-map (expr-list form &optional (max 1))
  `(progn
    (store-current-function ,form)
     (add-code ,form)
     (add-code "(")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defmacro parse-math (expr-list form &optional (max 1))
  `(let ((type (get-type ,expr-list)))
    (store-current-function ,form)
     (add-code (format nil "~a_~a" ,form type))
     (add-code "(")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defmacro parse-type-cast (expr-list current form &optional (max 1))
  `(progn
     (store-current-function ,current)
     (add-code "(")
     (add-code ,form)
     (add-code ")")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defun parse-call (expr-list)
  (cond ((equal ")" (car expr-list))
         (return-from parse-call (cdr expr-list)))
        ((equal "," (car expr-list))
         (error-syntax-error expr-list))
        ((equal (format nil "~a" #\Newline) (car expr-list))
         (dbg "parse-call: RET")
         (setf expr-list (parse-call (cdr expr-list))))
        ((or (equal "set" (car expr-list)) (equal "::" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "set")
           (if (or (is-iter-variable-p (cadr expr-list))
                   (is-iter-composition-type-p (cdr expr-list)))
               (progn
                 (add-code (format nil "set_pointer_~a" type))
                 (add-code "(")
                 (add-code "&"))
               (progn
                 (if (or (search "elt" (caddr expr-list)) (search "#" (caddr expr-list)))
                     (progn
                       (add-code (format nil "set_pointer_~a" type))
                       (add-code "("))
                     (progn
                       (add-code (format nil "set_~a" type))
                       (add-code "(")))))
           (dbg "parse-call: set Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((or (equal "elt" (car expr-list)) (equal "#" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "elt")
           (if (equal (cadr (gethash (get-last-function) *signatures*)) "value")
               (add-code "*"))
           (add-code (format nil "elt_~a" (regex-replace "pointer" type "array")))
           (add-code "(")
           (dbg "parse-call: elt Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list)
                                            (1- (count-elements expr-list))))))
         ((equal "prnfmt" (car expr-list))
          (store-current-function "prnfmt")
          (add-code "print_format")
          (add-code "(")
          (dbg "parse-call: prnfmt Next arg " (cadr expr-list))
          (setf expr-list (parse-arguments (cdr expr-list) *infinite-arguments*)))
        ((equal "prnl" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "prnl")
           (if (search "array" type)
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list)))))
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prnl Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prn" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "prn")
           (if (search "array" type)
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list)))))
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prn Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prnstr" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "prnstr")
           (add-code (format nil "print_str_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "of" (car expr-list))
         (add-code "(")
         (if (equal "set" (get-current-function))
             (add-code "&"))
         (store-current-function "of")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-expression expr-list t))
         (add-code ".")
         (add-code (car expr-list))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "let" (car expr-list))
         (store-current-function "let")
         (inf "Compile let in block " *block*)
         (dbg "parse-call: LET INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-let (cdr expr-list))))
        ((or (equal "for" (car expr-list)) (equal "∑" (car expr-list)))
         (store-current-function "for")
         (inf "Compile for in block " *block*)          
         (dbg "parse-call: FOR INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-for (cdr expr-list))))
        ((equal "defn" (car expr-list))
         (store-current-function "defn")
         (setf *target* 'implementation)
         (dbg "parse-call: DEFN INC BLOCK " (car expr-list))
         (inf "Compile function '" (cadr expr-list) "'")
         (setf expr-list (parse-def-function (cdr expr-list)))
         (setf *target* 'code))
        ((equal "compose" (car expr-list))
         (setf *target* 'implementation)
         (store-current-function "compose")
         (dbg "parse-call: COMPOSE INC BLOCK " (car expr-list))
         (setf expr-list (parse-compose (cdr expr-list)))
         (setf *target* 'code))
        ((equal "return" (car expr-list))
         (store-current-function "return")
         (add-code "return")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "while" (car expr-list))
         (store-current-function "while")
         (add-code "while")
         (add-code "(")
         (dbg "parse-call: WHILE INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-while (cdr expr-list))))
        ((equal "if" (car expr-list))
         (store-current-function "if")
         (add-code "if")
         (add-code "(")
         (dbg "parse-call: IF INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-if (cdr expr-list))))
        ((or (equal "mod" (car expr-list))
             (equal "%" (car expr-list)))
         (store-current-function "mod")
         (add-code "mod")
         (add-code "(")
         (dbg "parse-call: MOD block " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-arguments (cdr expr-list) 2)))
        ((equal "<" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "lt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "<=" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "leqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal ">" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "gt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal ">=" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "geqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "!=" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "neq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "==" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "eq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "add" (car expr-list)) (equal "+" (car expr-list)))
         (store-current-function "add")
         (dbg "parse-call: operator + ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "+")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "sub" (car expr-list)) (equal "-" (car expr-list)))
         (store-current-function "sub")
         (dbg "parse-call: operator - ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "-")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "mul" (car expr-list)) (equal "*" (car expr-list)))
         (store-current-function "mul")
         (dbg "parse-call: operator * ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "*")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "div" (car expr-list)) (equal "/" (car expr-list)))
         (store-current-function "div")
         (dbg "parse-call: operator / ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "/")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "sqrt" (car expr-list)) (equal "√" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "sqrt")
           (add-code (format nil "sqrt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "fabs" (car expr-list))
           (store-current-function "fabs")
           (add-code (format nil "fabs_f64"))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list))
        ((equal "atan" (car expr-list))
         (parse-math expr-list "atan"))
        ((equal "atan2" (car expr-list))
         (parse-math expr-list "atan2" 2))
        ((equal "acos" (car expr-list))
         (parse-math expr-list "acos"))
        ((equal "asin" (car expr-list))
         (parse-math expr-list "asin"))
        ((equal "asin2" (car expr-list))
         (parse-math expr-list "atan2"))
        ((equal "cos" (car expr-list))
         (parse-math expr-list "cos"))
        ((equal "cosh" (car expr-list))
         (parse-math expr-list "cosh"))
        ((equal "sin" (car expr-list))
         (parse-math expr-list "sin"))
        ((equal "sinh" (car expr-list))
         (parse-math expr-list "sinh"))
        ((equal "tanh" (car expr-list))
         (parse-math expr-list "tanh"))
        ((equal "exp" (car expr-list))
         (parse-math expr-list "exp"))
        ((equal "log" (car expr-list))
         (parse-math expr-list "log"))
        ((equal "log10" (car expr-list))
         (parse-math expr-list "log10"))
        ((equal "floor" (car expr-list))
         (parse-math expr-list "floor"))
        ((equal "ceil" (car expr-list))
         (parse-math expr-list "ceil"))
        ((equal "round" (car expr-list))
         (parse-math expr-list "round"))
        ((equal "fmod" (car expr-list))
         (parse-math expr-list "fmod" 2))
        ((equal "open" (car expr-list))
         (parse-map expr-list "open" 2))
        ((equal "read-line" (car expr-list))
         (parse-map expr-list "read_line" 1))
        ((equal "write-line" (car expr-list))
         (parse-map expr-list "write_line" 2))
        ((equal "read-binary" (car expr-list))
         (parse-map expr-list "read_binary" 4))
        ((equal "write-binary" (car expr-list))
         (parse-map expr-list "write_binary" 4))
        ((equal "close" (car expr-list))
         (parse-map expr-list "close" 1))
        ((equal "string-to-i32" (car expr-list))
         (parse-map expr-list "atoi" 1))
        ((equal "string-to-f32" (car expr-list))
         (parse-map expr-list "atof" 1))
        ((equal "trunc" (car expr-list))
         (parse-map expr-list "trunc" 1))
        ((or (equal "power" (car expr-list)) (equal "^" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "power")
           (add-code (format nil "power_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "max" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "max")
           (add-code (format nil "max_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "min" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "min")
           (add-code (format nil "min_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "module" (car expr-list))
         (store-current-function "module")
         (setf expr-list (parse-module (cdr expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "len" (car expr-list)) (equal "@" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "size")
           (if (or (search "array" type)
                   (search "list" type)
                   (search "pointer" type))
               (add-code (format nil "length_~a" type))
               (if (search "string" type)
                   (add-code "sizeof")
                   (error-type-not-supported expr-list type)))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "map" (car expr-list))
         (let ((type (get-type (cdr expr-list))))
           (store-current-function "map")
           (add-code (format nil "map_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "mapn" (car expr-list))
         (let ((type (get-type (cdr expr-list))))
           (store-current-function "mapn")
           (add-code (format nil "mapn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "reduce" (car expr-list))
         (let ((type (get-type (cdr expr-list))))
           (store-current-function "reduce")
           (add-code (format nil "reduce_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "push" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "push")
           (add-code (format nil "push_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "car" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "car")
           (add-code (format nil "car_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdr" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (store-current-function "cdr")
           (add-code (format nil "cdr_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdrn" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (store-current-function "cdrn")
           (add-code (format nil "cdrn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "rev" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (store-current-function "rev")
           (add-code (format nil "reverse_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "append" (car expr-list))
         (store-current-function "append")
         (let ((typea (get-type expr-list))
               (typeb (get-type (cdr expr-list))))
           (if (and (not (search "list" typea))
                    (not (search "array" typea))
                    (not (search "pointer" typea)))
               (error-type-not-supported expr-list typea))
           (if (search "array" typeb)
               (add-code (format nil "append_array_~a" typeb)))
           (if (search "list" typeb)
               (add-code (format nil "append_list_~a" typeb)))
           (if (search "pointer" typeb)
               (add-code (format nil "append_pointer_~a" typeb)))
           (if (and (not (search "list" typeb))
                    (not (search "array" typeb))
                    (not (search "pointer" typeb)))
               (add-code (format nil "append_~a" typea)))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "size" (car expr-list))
         (store-current-function "size")
         (add-code "sizeof")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "remove" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "remove")
           (add-code (format nil "remove_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "pop" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "pop")
           (add-code (format nil "pop_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "break" (car expr-list))
         (add-code "break")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "continue" (car expr-list))
         (add-code "continue")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (add-code "destroy_ptr")
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "bool" (car expr-list))
         (parse-type-cast expr-list "bool" "bool"))
        ((equal "b8" (car expr-list))
         (parse-type-cast expr-list "b8" "b8"))
        ((equal "c8" (car expr-list))
         (parse-type-cast expr-list "c8" "c8"))
        ((equal "i16" (car expr-list))
         (parse-type-cast expr-list "i16" "i16"))
        ((equal "i32" (car expr-list))
         (parse-type-cast expr-list "i32" "i32"))
        ((equal "i64" (car expr-list))
         (parse-type-cast expr-list "i64" "i64"))
        ((equal "ui16" (car expr-list))
         (parse-type-cast expr-list "ui16" "ui16"))
        ((equal "ui32" (car expr-list))
         (parse-type-cast expr-list "ui32" "ui32"))
        ((equal "ui64" (car expr-list))
         (parse-type-cast expr-list "ui64" "ui64"))
        ((equal "f32" (car expr-list))
         (parse-type-cast expr-list "f32" "f32"))
        ((equal "f64" (car expr-list))
         (parse-type-cast expr-list "f64" "f64"))
        ((equal "f80" (car expr-list))
         (parse-type-cast expr-list "f80" "f80"))
        ((equal "string" (car expr-list))
         (parse-type-cast expr-list "string" "string"))
        ((equal "cstring" (car expr-list))
         (parse-type-cast expr-list "cstring" "cstring"))
        ((equal "file" (car expr-list))
         (parse-type-cast expr-list "file" "file"))
        ((equal "bool>" (car expr-list))
         (parse-type-cast expr-list "bool>" "bool*"))
        ((equal "b8>" (car expr-list))
         (parse-type-cast expr-list "b8>" "b8*"))
        ((equal "c8>" (car expr-list))
         (parse-type-cast expr-list "c8>" "c8*"))
        ((equal "i16>" (car expr-list))
         (parse-type-cast expr-list "i16>" "i16*"))
        ((equal "i32>" (car expr-list))
         (parse-type-cast expr-list "i32>" "i32*"))
        ((equal "i64>" (car expr-list))
         (parse-type-cast expr-list "i64>" "i64*"))
        ((equal "ui16>" (car expr-list))
         (parse-type-cast expr-list "ui16>" "ui16*"))
        ((equal "ui32>" (car expr-list))
         (parse-type-cast expr-list "ui32>" "ui32*"))
        ((equal "ui64>" (car expr-list))
         (parse-type-cast expr-list "ui64>" "ui64*"))
        ((equal "f32>" (car expr-list))
         (parse-type-cast expr-list "f32>" "f32*"))
        ((equal "f64>" (car expr-list))
         (parse-type-cast expr-list "f64>" "f64*"))
        ((equal "f80>" (car expr-list))
         (parse-type-cast expr-list "f80>" "f80*"))
        ((equal "string>" (car expr-list))
         (parse-type-cast expr-list "string>" "string*"))
        ((equal "cstring>" (car expr-list))
         (parse-type-cast expr-list "cstring>" "cstring*"))
        ((equal "file>" (car expr-list))
         (parse-type-cast expr-list "file>" "file*"))
        ((equal "bool>>" (car expr-list))
         (parse-type-cast expr-list "bool>>" "bool**"))
        ((equal "b8>>" (car expr-list))
         (parse-type-cast expr-list "b8>>" "b8**"))
        ((equal "c8>>" (car expr-list))
         (parse-type-cast expr-list "c8>>" "c8**"))
        ((equal "i16>>" (car expr-list))
         (parse-type-cast expr-list "i16>>" "i16**"))
        ((equal "i32>>" (car expr-list))
         (parse-type-cast expr-list "i32>>" "i32**"))
        ((equal "i64>>" (car expr-list))
         (parse-type-cast expr-list "i64>>" "i64**"))
        ((equal "ui16>>" (car expr-list))
         (parse-type-cast expr-list "ui16>>" "ui16**"))
        ((equal "ui32>>" (car expr-list))
         (parse-type-cast expr-list "ui32>>" "ui32**"))
        ((equal "ui64>>" (car expr-list))
         (parse-type-cast expr-list "ui64>>" "ui64**"))
        ((equal "f32>>" (car expr-list))
         (parse-type-cast expr-list "f32>>" "f32**"))
        ((equal "f64>>" (car expr-list))
         (parse-type-cast expr-list "f64>>" "f64**"))
        ((equal "f80>>" (car expr-list))
         (parse-type-cast expr-list "f80>>" "f80**"))
        ((equal "string>>" (car expr-list))
         (parse-type-cast expr-list "string>>" "string**"))
        ((equal "cstring>>" (car expr-list))
         (parse-type-cast expr-list "cstring>>" "cstring**"))
        ((equal "file>>" (car expr-list))
         (parse-type-cast expr-list "file>>" "file**"))
        ((or (equal "?" (car expr-list)) (equal "deref" (car expr-list)))
         (store-current-function "deref")
         (add-code (format nil "("))
         (add-code (format nil "*"))
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((or (equal "&" (car expr-list)) (equal "ref" (car expr-list)))
         (store-current-function "ref")
         (add-code (format nil "("))
         (add-code (format nil "&"))
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "del" (car expr-list))
         (store-current-function "del")
         (add-code (format nil "delete_ptr"))
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (store-current-function "destroy")
         (add-code (format nil "destroy_ptr"))
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (parse-arguments (cdr expr-list) 0))
           (return-from parse-call expr-list))
        ((equal "new" (car expr-list))
         (if (not (search ">" *current-let-definition*))
             (error-type-not-supported expr-list *current-let-definition*))
         (let ((type (regex-replace ">" *current-let-definition* "")))
           (store-current-function "new")
           (add-code (format nil "new_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "new_bool" (car expr-list))
         (store-current-function "new_bool")
         (add-code "new_bool")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_c8" (car expr-list))
         (store-current-function "new_c8")
         (add-code "new_c8")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_b8" (car expr-list))
         (store-current-function "new_b8")
         (add-code "new_b8")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_i16" (car expr-list))
         (store-current-function "new_16")
         (add-code "new_i16")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_i32" (car expr-list))
         (store-current-function "new_i32")
         (add-code "new_i32")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_i64" (car expr-list))
         (store-current-function "new_i64")
         (add-code "new_i64")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_f32" (car expr-list))
         (store-current-function "new_f32")
         (add-code "new_f32")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_f64" (car expr-list))
         (store-current-function "new_f64")
         (add-code "new_f64")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_f80" (car expr-list))
         (store-current-function "new_f80")
         (add-code "new_f80")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "defp" (car expr-list))
         (setf *target* 'implementation)
         (store-current-function "defp")
         (add-code "static")
         (add-code " ")
         (setf expr-list (parse-variable (cdr expr-list)))
         (setf *target* 'code)
         (return-from parse-call expr-list))
        ((is-iter-function-p (car expr-list))
         (progn
           (dbg "parse-call: FN: " (get-iter-function-name (car expr-list)))
           (if (is-function-map-p (car expr-list))
               (add-code (get-iter-function-name (get-function-value (car expr-list))))
               (add-code (get-iter-function-name (car expr-list))))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) *infinite-arguments*))))
        ((get-iter-variable-name (car expr-list))
         (dbg "parse-call: FN emit: " (get-function-name (car expr-list)))
         (add-code "(")
         (add-code "*")
         (add-code (get-function-name (car expr-list)))
         (add-code ")")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list)
                                          *infinite-arguments*)))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-call: FN not defined: " (get-function-name (car expr-list)))
         (error-function-not-defined expr-list))
        ((equal "(" (car expr-list))
         (progn
           (dbg "parse-call: CALL OPEN ( block " *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t))))
        )
   expr-list)

(defun is-variable-split-name-p (expression)
  (let ((split (split ">>" expression)))
    (remove-if-not
     #'(lambda (x)
         (equal x (get-iter-variable-name (car split))))
     (hash-table-keys *variables*))))

(defun parse-expression (expr-list &optional (omit nil))
  (if expr-list
      (progn
        (dbg "parse-expression: enter " (car expr-list))
        (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
             (setf expr-list (cdr expr-list)))
        (if (not expr-list)
            (return-from parse-expression expr-list))
        (if (equal "," (car expr-list))
            (error-syntax-error expr-list))        
        (if (equal "EOF" (car expr-list))
            (add-code "EOF"))
        (if (equal ")" (car expr-list))
            (error-too-many-parens expr-list))
        (if (equal "\"" (car expr-list))
            (progn
              (dbg "parse-expression: STRING block " *block*)
              (add-code "\"")
              (setf expr-list (parse-cstr (cdr expr-list)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: STRING END ")
              (return-from parse-expression expr-list)))
        (if (and (equal ";" (car expr-list)) (equal "|" (cadr expr-list)))
            (progn
              (dbg "parse-expression: parse multiline comment")
              (setf expr-list (parse-multiline-comment (cddr expr-list)))
              (return-from parse-expression expr-list)))
        (if (equal ";" (car expr-list))
            (progn
              (dbg "parse-expression: parse singleiline comment")
              (setf expr-list (parse-single-line-comment expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "{" (car expr-list))
            (progn
              (dbg "parse-expression: parse null")
              (setf expr-list (parse-null expr-list))
                (if (not omit)
                  (add-code (format nil ";~%")))
            (return-from parse-expression expr-list)))
        (if (equal "[" (car expr-list))
            (progn
              (dbg "parse-expression: parse vector " (car expr-list))
              (add-code "{")
              (dbg "parse-expression: parse vector literal ")
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (equal "'" (car expr-list))
            (let ((type (get-type (cddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-expression: parse list literal ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (numberp (parse-integer (car expr-list) :junk-allowed t))
            (progn
              (dbg "parse-expression: NUM block " *block*
                   " number " (car expr-list))
              (add-code (car expr-list))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression (cdr expr-list))))
        (if (remove-if-not
             #'(lambda (x)
                 (equal x (get-iter-function-name (car expr-list))))
             (hash-table-keys *functions*))
            (progn
              (add-code (get-iter-function-name (car expr-list)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: parse function symbol "
                   (car expr-list))))
        (if (or (is-variable-split-name-p (car expr-list))
                (is-iter-variable-p (car expr-list)))
            (let ((comp-name (build-dotted-type (car expr-list)))
                  (var-name (regex-replace ">>.*" (car expr-list) "")))
              (dbg "parse-expression: VARIABLE "
                   (get-iter-variable-name var-name))
              (if (search ">" *current-let-definition*)
                  (add-code "&"))
              (if (search ">>" (car expr-list))
                  (add-code comp-name)
                  (add-code (get-iter-variable-name var-name)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: VAR END " var-name)
              (return-from parse-expression (cdr expr-list))))
        (if (not (or (equal "," (car expr-list))
                     (equal (format nil "~a" #\Newline) (car expr-list))
                     (equal "(" (car expr-list))
                     (equal ")" (car expr-list))
                     (equal "[" (car expr-list))
                     (equal "]" (car expr-list))
                     (equal "\"" (car expr-list))
                     (equal ";|" (car expr-list))
                     (equal "|;" (car expr-list))
                     (equal ";" (car expr-list))
                     (numberp (parse-integer (car expr-list) :junk-allowed t))))
            (progn
              (dbg "parse-expression: SYMBOL " (car expr-list))
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "(" (car expr-list))
            (let ((space nil)
                  (no-parens nil))
              ;; parse-open-parens
              (setf expr-list (parse-open-parens expr-list))
              (inc-parens)
              (dbg "parse-expression: OPEN parens "
                   *paranteses* " block " *block*)
              ;; omit semicolon for blocks
              (if (or (equal "for" (car expr-list))
                      (equal "if" (car expr-list))
                      (equal "while" (car expr-list))
                      (equal "defn" (car expr-list))
                      (equal "defp" (car expr-list))
                      (equal "let" (car expr-list))
                      (equal "compose" (car expr-list))
                      (equal "module" (car expr-list))
                      (equal "break" (car expr-list))
                      (equal "continue" (car expr-list))
                      (equal "i16" (car expr-list)))
                  (setf space t))
              (if (is-type-cast-p (car expr-list))
                  (setf no-parens t))
              ;; parse-call
              (setf expr-list (parse-call expr-list))
              (dbg "parse-expression: CALL END rest " (car expr-list)
                   " parens " *paranteses* " block " *block*)
              (dbg "parse-expression: CLOSE parens " *paranteses* " block " *block*
                   " omit " omit)
              (if (car expr-list)
                  (setf expr-list (parse-close-parens expr-list)))
              (let ((fn (get-last-function)))
                (dbg "parse-expression: function " fn " omit " omit)
                (if (and (not space) (not no-parens))
                    (add-code ")")))
              (dec-parens)
              (if (and (not space) (not omit))
                  (add-code (format nil ";~%")))
              ;; exit
              (return-from parse-expression expr-list)))
        (if (equal (format nil "~a" #\Newline) (car expr-list))
            (progn
              (setf expr-list (cdr expr-list))
              (dbg "parse-expression: caught \n")
              (return-from parse-expression expr-list))))))
  
(defun parse (expression)
  "Parse expression."
  (dbg "parse: preprocess")
  (let ((expr-list (preprocess expression)))
    (dbg "parse: setup hashtables")
    (setf *code_list* '(""))
    (setf *implementation_list* '(""))
    (setf *definition_list* '(""))
    (setf *paranteses* 0)
    (setf  *block* 0)
    (setf *variables* (make-hash-table :test 'equal))
    (setf *compositions* (make-hash-table :test 'equal))
    (setf *functions* (make-hash-table :test 'equal))
    (setf *function-map* (make-hash-table :test 'equal))
    (setf *signatures* (make-hash-table :test 'equal))
    (setf *current-function* (make-hash-table :test 'equal))
    (dbg "parse: setup-signatures")
    (setup-signatures)
    (dbg "parse: parse-expressions")
    (loop while (> (length expr-list) 0) do
         (setf expr-list (parse-expression expr-list))))
  (emit-code-call))
