;;; -----------------------------------------------------
;;; next - parser file
;;; -----------------------------------------------------
;;; File:     src/parser.lisp
;;; Date:     09:29:15 of Wednesday, 8/14/2019 (GMT+1)
;;; Author:   Edward Puccini
;;; -----------------------------------------------------

(in-package :next)

(require 'parse-float)

;; target lists to store c-code

(defvar *code_list* '(""))
(defvar *definition_list* '(""))
(defvar *implementation_list* '(""))
(defvar *main_buffer* nil)
(defvar *definition_buffer* nil)
(defvar *target* 'code)
(defvar *tmp-var* nil)

;; counters and flags

(defvar *block* 0)
(defvar *error* nil)
(defvar *emitted* nil)
(defvar *paranteses* 0)
(defvar *line-start-code* 0)
(defvar *line-start-implementation* 0)
(defvar *main-start-implementation* 0)

;; function and var storage

(defvar *variable-type* nil)
(defvar *function-type* nil)
(defvar *function-args* nil)
(defvar *compositions* nil)
(defvar *signatures* nil)
(defvar *function-map* nil)

;; states

(defvar *current-function* nil)
(defvar *current-composition* nil)
(defvar *current-type-variable* nil)
(defvar *current-type-definition* nil)
(defvar *current-module* "")
(defvar *start-operation* -1)

;; templates

(defvar *generics-template* "")
(defvar *def-template* "")
(defvar *impl-template* "")
(defvar *is-main-defined* nil)

;; constants

(defvar *infinite-arguments* 10000)

;; Builtin next-types

(defvar *types*
  '("i16" "i32" "i64" "ui16" "ui32" "ui64" "f32" "f64" "f80"
    "bool" "b8" "c8" "string" "file" "fun" "void" "ixx" "ixx_cast"

    "i16>" "i32>" "i64>" "ui16>" "ui32>" "ui64>" "f32>" "f64>" "f80>"
    "bool>" "b8>" "c8>" "string>" "file>" "fun>" "void>" "ixx>"

    "i16#" "i32#" "i64#" "ui16#" "ui32#" "ui64#" "f32#" "f64#" "f80#"
    "bool#" "b8#" "c8#" "string#" "file#" "fun#" 

    "i16'" "i32'" "i64'" "ui16'" "ui32'" "ui64'" "f32'" "f64'" "f80'"
    "bool'" "b8'" "c8'" "string'" "file'" "fun'" 

    "i16>>" "i32>>" "i64>>" "ui16>>" "ui32>>" "ui64>>" "f32>>" "f64>>" "f80>>"
    "bool>>" "b8>>" "c8>>" "string>>" "file>>" "fun>>" "void>>"  "ixx>>"))

(defvar *math-operators* '("+" "-" "*" "/" "√"
                           "add" "badd" "sub" "bsub" "mul" "bmul" "div" "bdiv"
                           "sqrt" "power" "bsqrt" "bpower"
                           "mod" "eq" "neq" "lt" "gt" "leqt" "geqt"))

(defvar *non-infix-operators* '("^" "power" "√" "sqrt"))

(defun is-non-infix-operator-p (operator)
  (dolist (op *non-infix-operators*)
    (if (equal op operator)
        (return-from is-non-infix-operator-p t)))
  (return-from is-non-infix-operator-p nil))

(defun is-fixed-math-type-p (type)
  (or (equal "f32" type) (equal "f64" type) (equal "f80" type)
      (equal "i16" type) (equal "i32" type) (equal "i64" type)
      (equal "ui16" type) (equal "ui32" type) (equal "ui64" type)))

(defun set-target (target)
  (setf *target* target))

(defun load-templates ()
  (setf *def-template* (load-binary-data "../templates/code.h"))
  (setf *impl-template* (load-binary-data "../templates/code.c"))
  (setf *generics-template* (load-binary-data "../templates/generics.h")))

(defun is-main-defined-p ()
  *is-main-defined*)

(defun filter-expression (expression)
  (let* ((new-expr1 (regex-replace-all "-" expression "_"))
         (new-expr2 (regex-replace-all "\\√" new-expr1 "sqrt"))
         (new-expr3 (regex-replace-all "\\^" new-expr2 "power"))
         (new-expr4 (regex-replace-all "∑" new-expr3 "for"))
         (new-expr5 (regex-replace-all ">>" new-expr4 "__")))
    new-expr5))

;; Error handling

(defun print-stack ()
  "Use swank to log a stack-trace."
  (let ((trace ""))
    (let* ((msg-lst (remove-if #'null
                               (swank-backend:call-with-debugging-environment
                                (lambda () (swank:backtrace 0 7)))))
           (stack-msg
            (progn
              (mapcar (lambda (msg)
                        (setf trace (concatenate 'string trace 
                                                   (format nil "~{~A ~}~%" msg))))
                      msg-lst) trace)))
      (print stack-msg))))

(defun final-error-msg (expr-list msg)
  (if (not *emitted*)
      (emit-code-call))
  (format t msg)
  (ignore-errors
   (regex-replace "\n" (format t "~%~{~a ~}~%" (subseq expr-list 0 40)) " "))
  (print-stack)
  (sb-ext:quit))

(defun error-msg (expr-list msg)
  (if (not *emitted*)
      (emit-code-call))
  (format t msg)
  (setf *error* t)
  (sb-ext:quit)
  (ignore-errors
   (regex-replace "\n" (format t "~%~{~a ~}~%" (subseq expr-list 0 40)) " ")))

(defun error-parameter-max (expr-list cnt max)
  (error-msg expr-list (format nil "Error too many parameter to function (~a). Only ~a parameter expected!~%"
             cnt max)))

(defun error-operator-not-defined (expr-list)
  (final-error-msg expr-list "~%Error no operator defined!~%"))

(defun error-no-type-def (expr-list)
  (error-msg expr-list "~%Error no type defined!~%"))

(defun error-function-not-defined (expr-list)
  (error-msg expr-list "~%Error function not defined!~%"))

(defun error-missing-expression (expr-list)
  (error-msg expr-list "~%Error missing expression!~%"))

(defun error-function-type-unkown (expr-list type)
  (error-msg expr-list (format nil "~%Error function type >~a< unkown!~%" type)))

(defun error-syntax-error (expr-list)
  (final-error-msg expr-list "~%Error syntax error!~%"))

(defun error-missing-open-square-bracket (expr-list)
  (final-error-msg expr-list "~%Error missing square bracket!~%"))

(defun error-missing-open-parens (expr-list)
  (final-error-msg expr-list "~%Error missing open parens!~%"))

(defun error-missing-close-square-bracket (expr-list)
  (final-error-msg expr-list "~%Error missing square bracket!~%"))

(defun error-missing-close-parens (expr-list)
  (final-error-msg expr-list "~%Error missing close parens!~%"))

(defun error-variable-not-defined (expr-list variable)
  (error-msg expr-list
             (format nil "~%Error variable >~a< not defined!~%" variable)))

(defun error-function-vector-malformed (expr-list)
  (error-msg expr-list "~%Error function vector malformed!~%"))

(defun error-composition-vector-malformed (expr-list)
  (error-msg expr-list "~%Error composition vector malformed!~%"))

(defun error-let-vector-malformed (expr-list)
  (error-msg expr-list "~%Error let vector malformed!~%"))

(defun error-cant-infer-type (expr-list)
  (error-msg expr-list "~%Error cant determine type!~%"))

(defun error-only-lists-supported (expr-list)
  (error-msg expr-list "~%Error only lists supported!~%"))

(defun error-type-not-supported (expr-list type)
  (error-msg expr-list (format nil "~%Error type >~a< not supported!~%" type)))

(defun error-too-many-parens (expr-list)
  (error-msg expr-list "~%Error too many paranteses!~%"))

(defun error-not-outside-function (expr-list)
  (error-msg expr-list "~%Error this declaration requires to be inside a function!~%"))

(defun upto-line-end (expression lower)
  (let ((str "")
        (obj nil))
    (loop for x from lower to (- (length expression) 1) do
         (setf obj (elt expression x))
         (if (or (equal #\Newline obj)
                 (equal #\Return obj)
                 (equal #\Linefeed obj))
             (return-from upto-line-end str))
         (if (not (or (equal #\Newline obj)
                      (equal #\Return obj)
                      (equal #\Linefeed obj)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-comment-end (expression lower)
  (let ((str ""))
    (loop for x from lower to (- (length expression) 2) do
         (if (and (equal #\| (elt expression x)) (equal #\; (elt expression (1+ x))))
             (return-from upto-comment-end str))
         (if (not (equal #\| (elt expression x)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-string (expression lower)
  (let ((str ""))
    (loop for x from lower to (1- (length expression)) do
         (if (equal #\" (elt expression x))
             (return-from upto-string str))
         (if (not (equal #\" (elt expression x)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-symbol (expression lower)
  (let ((str "")
        (stack '()))
    (loop for x from lower to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((equal #\" obj)
                  (return-from upto-symbol stack))
                 ((equal #\$ obj)
                  (push "$" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\√ obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\; obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\( obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\) obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\{ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\} obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\[ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\] obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\% obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\& obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\, obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Newline obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Return obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Linefeed obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Space obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 (t
                  (setf str (format nil "~a~a" str obj))))))
    (push str stack)))

(defun stack-length (stack)
  (let ((l 0))
    (mapcar #'(lambda (x) (setf l (+ l (length x))))
            stack)
    l))

(defun preprocess (expr)
  (let ((stack '())
        (expression (regex-replace-all "->" expr "$")))
    (setf expression (concatenate'string expression " "))
    (loop for x from 0 to (- (length expression) 2) do
         (let ((obj (elt expression x))
               (next (elt expression (1+ x))))
           (cond ((or (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\{ obj)
                      (equal #\} obj)
                      (equal #\% obj)
                      (equal #\& obj)
                      (equal #\# obj)
                      (equal #\√ obj))
                  (push (format nil "~a" obj) stack))
                 ((and (equal #\< obj) (equal #\< next))
                  (push "<<" stack)
                  (setf x (1+ x)))
                 ((and (equal #\> obj) (equal #\> next))
                  (push ">>" stack)
                  (setf x (1+ x)))
                 ((and (equal #\< obj) (equal #\= next))
                  (push "<=" stack)
                  (setf x (1+ x)))
                 ((and (equal #\< obj) (not (equal #\= next)) (not (equal #\< next)))
                  (push "<" stack))
                 ((and (equal #\> obj) (equal #\= next))
                  (push ">=" stack)
                  (setf x (1+ x)))
                 ((and (equal #\> obj) (not (equal #\= next)) (not (equal #\> next)))
                  (push ">" stack))
                 ((and (equal #\= obj) (equal #\= next))
                  (push "==" stack)
                  (setf x (1+ x)))
                 ((and (equal #\= obj) (not (equal #\= next)))
                  (push "=" stack))
                 ((and (equal #\! obj) (equal #\= next))
                  (push "!=" stack)
                  (setf x (1+ x)))
                 ((and (equal #\! obj) (not (equal #\= next)))
                  (push "!" stack))
                 ((equal #\∑ obj)
                  (push "∑" stack))
                 ((equal #\, obj)
                  (push "," stack))
                 ((equal #\Space obj)
                  (format nil " "))
                 ((or (equal #\Newline obj)
                      (equal #\Return obj)
                      (equal #\Linefeed obj))
                  (format nil " "))
                 ((and (equal #\; obj) (not (equal #\| next)))
                  (let ((str (upto-line-end expression (+ 2 x))))
                    (setf x (+ x 2 (length str)))))
                 ((and (equal #\; obj) (equal #\| next))
                  (let ((str (upto-comment-end expression (+ 2 x))))
                    (setf x (+ x 2 (length str)))))
                 ((equal #\Tab obj)
                  (format nil " "))
                 ((equal #\" obj)
                  (let ((str (upto-string expression (1+ x))))
                    (setf x (+ x 1 (length str)))
                    (push "\"" stack)
                    (push str stack)
                    (push "\"" stack)))
                 (t
                  (let ((inner-stack (upto-symbol expression x)))
                    (setf stack (append (reverse inner-stack) stack))
                    (setf x (+ x (1- (stack-length inner-stack)))))))))
    (reverse stack)))

(defun emit-code-call ()
  (let ((code "")
        (definition "")
        (implementation ""))
    (if *implementation_list*
        (format t "~%~{~a~}~%" *implementation_list*))
    (if *code_list*
        (format t "~%~{~a~}~%" *code_list*))
    (if *implementation_list*
        (setf implementation
              (format nil "~%~{~a~}~%" *implementation_list*)))
    (if *code_list*
        (progn
          (if (not (is-main-defined-p))
              (setf code (format nil "i32 main () ~%{~%~%~{~a~}~%" *code_list*))
              (setf code (format nil "~%~%~{~a~}~%" *code_list*)))))
    (if (not (is-main-defined-p))
        (setf code (format nil "~a~%destroy_ptr(pointer_list);~%return 0;~%}" code)))
    (setf *emitted* t)
    (values code definition implementation)))

(defun get-composition-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-variable-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-function-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-iter-variable-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *variable-type*)
              (progn
                (return-from get-iter-variable-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-variable-name-x name cnt)))))))
(defun get-iter-variable-name (name)
  (get-iter-variable-name-x name *block*))

(defun get-iter-function-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *function-type*)
              (progn
                (return-from get-iter-function-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-function-name-x name cnt)))))))


(defun get-iter-function-name (name)
  (get-iter-function-name-x name *block*))

(defun get-iter-composition-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *compositions*)
              (progn
                (return-from get-iter-composition-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-composition-name-x name cnt)))))))

(defun get-iter-composition-name (name)
  (get-iter-composition-name-x name *block*))

(defun is-function-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-function-name name)))
                 (hash-table-keys *function-type*)))

(defun is-variable-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-variable-name name)))
                 (hash-table-keys *variable-type*)))

(defun get-iter-function-type (fn-name)
  (gethash (get-iter-function-name fn-name) *function-type*))

(defun is-iter-function-p (name)
  (get-iter-function-type name))

(defun get-iter-variable-type (fn-name)
  (gethash (get-iter-variable-name fn-name) *variable-type*))

(defun is-iter-variable-p (name)
  (get-iter-variable-type name))

(defun get-iter-composition-type (type-name)
  (remove-if-not #'(lambda (x) (equal x (get-iter-composition-name type-name)))
                 (hash-table-keys *compositions*)))

(defun is-iter-composition-p (type-name)
  (get-iter-composition-type type-name))

(defun is-iter-composition-type-p (expr-list)
  (let* ((split (split ">>" (car expr-list)))
         (struct-type (gethash (get-iter-variable-name (car split)) *variable-type*))
         (struct-name (get-iter-composition-name (format nil "~a" struct-type))))
    (gethash (format nil "~a>>~a" struct-name (cadr split)) *variable-type*)))
  
(defun set-signature (name signature)
  (setf (gethash name *signatures*) signature))

(defun append-signature (name signature)
  (setf (gethash name *signatures*)
        (append (gethash name *signatures*) (list signature))))

(defun inc-parens ()
  (setq *paranteses* (1+ *paranteses*)))

(defun dec-parens ()
  (setq *paranteses* (1- *paranteses*)))

(defun inc-block ()
  (setq *block* (+ 1 *block*)))

(defun dec-block ()
  (zero-hash-variables)
  (setq *block* (- *block* 1)))

(defun zero-parens ()
  (setq *paranteses* 0))

(defun zero-block ()
  (setq *block* 0))

(defun zero-hash-variables ()
  (dolist (var (hash-table-keys *variable-type*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-variable-name var) *variable-type*)))))

(defun zero-hash-functions ()
  (dolist (var (hash-table-keys *function-type*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-function-name var) *function-type*)))))

(defun zero-hash-compositions ()
  (dolist (var (hash-table-keys *compositions*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-function-name var) *compositions*)))))

(defun add-code (expression)
  ;(setf expression (filter-expression expression))
  (if expression
      (cond ((equal *target* 'code)
             (setf *code_list* (append *code_list* (list expression))))
            ((equal *target* 'implementation)
             (setf *implementation_list* (append *implementation_list*
                                                 (list expression))))
            ((equal *target* 'definition)
             (setf *definition_list* (append *definition_list*
                                             (list expression))))
            ((equal *target* 'definition-buffer)
             (setf (gethash *paranteses* *definition_buffer*)
                   (append (gethash *paranteses* *definition_buffer*)
                                               (list expression))))
            ((equal *target* 'main-buffer)
             (setf (gethash *paranteses* *main_buffer*)
                   (append (gethash *paranteses* *main_buffer*)
                                               (list expression)))))))

(defun get-last-code ()
  (cond ((equal *target* 'code)
         (car (reverse *code_list*)))
        ((equal *target* 'implementation)
         (car (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (car (reverse *definition_list*)))))

(defun get-previous-code ()
  (cond ((equal *target* 'code)
         (cadr (reverse *code_list*)))
        ((equal *target* 'implementation)
         (cadr (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (cadr (reverse *definition_list*)))))

(defun set-insert-points ()
  (setf *line-start-code* (length *code_list*))
  (setf *line-start-implementation* (length *implementation_list*)))

(defun set-insert-main-points ()
  (setf *main-start-implementation* (length *implementation_list*)))

(defun get-function-value (fn-name)
  (gethash fn-name *function-map*))

(defun set-function-map (fn-name value)
  (setf (gethash fn-name *function-map*) value))

(defun is-function-map-p (fn-name)
  (remove-if-not #'(lambda (fn) (equal fn fn-name))
                 (hash-table-keys *function-map*)))

(defun set-function-type (fn-name type)
  (setf (gethash (get-function-name fn-name) *function-type*) type))

(defun register-function (name content)
  (set-function-map name content)
  (set-function-type name "fun")
  (dbg "register-function: Register function >" name
       "< var >" content "<"))

(defun type-of-number-string (numstr)
  (cond ((and
          (typep (parse-integer numstr :junk-allowed t) 'integer)
          (not (find #\. numstr))
          (not (is-bigint-p numstr))
          (return-from type-of-number-string "i32")))
        ((search "d0" numstr)
         (return-from type-of-number-string "f64"))
        ((typep (parse-float numstr
                             :junk-allowed t
                             :type 'single-float) 'single-float)
         (return-from type-of-number-string "f32"))
        ((is-bigint-p numstr)
         (return-from type-of-number-string "ixx"))
        (t
         (return-from type-of-number-string nil))))

(defun inspect-function-type (expr-list)
  (dbg "inspect-function-type: " (cadr expr-list))
  (dbg "inspect-function-type: " (gethash
               (get-iter-function-name (car expr-list))
               *function-type*))
  (if (equal "(" (car expr-list))
      (cond ((is-iter-function-p (cadr expr-list))
             (return-from inspect-function-type
               (gethash
                (get-iter-function-name (cadr expr-list))
                *function-type*)))
            (t
             (return-from inspect-function-type
               (get-iter-function-name
                (get-function-value (cadr expr-list))))))
      (if (is-iter-function-p (car expr-list))
          (progn
            (return-from inspect-function-type
              (gethash
               (get-iter-function-name (car expr-list))
               *function-type*)))
          (progn
            (return-from inspect-function-type
              (get-iter-function-name
               (get-function-value (car expr-list))))))))

(defun parse-argument (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-argument: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           (dbg "parse-argument: OPEN ARG")
           (if (find #\: (car expr-list))
               (add-code ","))
           (setf expr-list (parse-argument expr-list)))))
  expr-list)

(defun store-composition-variable (var-name type)
  (setf (gethash (format nil "~a>>~a"
                         (get-composition-name *current-composition*)
                         var-name) *variable-type*) type))

(defun parse-types (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-types: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (car def))
                 (dbg "parse-types: store composition variable "
                      (format nil "~a>>~a"
                              (get-composition-name *current-composition*) (car def))
                      " type " (cadr def))
                 (store-composition-variable (car def) (cadr def))
                 (dbg "parse-types: store composition "
                      (get-composition-name *current-composition*)
                      " " (car def))
                 (setf (gethash (get-composition-name *current-composition*) *compositions*)
                       (car def))))
           (dbg "parse-types: OPEN ARG")
           (add-code (format nil ";~%"))
           (setf expr-list (parse-types expr-list)))))
  expr-list)

(defun parse-function-type (expr-list &optional (signature nil))
  (let ((fn-name (car (split ":" (car expr-list))))
        (type (cadr (split ":" (car expr-list))))
        (code-type ""))
    ;; base type ?
    (if (is-type-p type)
        (progn
          (if (search "ixx" type)
              (setf type (regex-replace "ixx" type "ixx_cast")))
          (cond ((search "'" type)
                 (setf code-type (format nil "node_~a*"
                                         (regex-replace "'" type ""))))
                ((search "#" type)
                 (setf code-type (regex-replace "#" type "")))
                ((search ">>" type)
                 (setf code-type (regex-replace ">>" type "**")))
                ((search ">" type)
                 (setf code-type (regex-replace ">" type "*")))
                (t
                 (setf code-type type)))))
    (if (and (not (equal "fun" type))
             (not (is-iter-composition-p type)))
        (add-code code-type))
    ;; composition ?
    (if (is-iter-composition-p type)
        (progn
          (add-code "struct ")
          (add-code (get-iter-composition-name type))))
    ;; function ?
    (if (equal "fun" type)
           (if signature
               (progn
                 (dbg "parse-function-type: signature " signature)
                 (dbg "parse-function-type: signature "
                      (format nil "~a (*~a)(~a)"
                              (car (reverse signature))
                              (get-function-name fn-name)
                              (cdr (reverse signature))))
                 (add-code (format nil "~a (*~a_~a)(~a)"
                                   (car (reverse signature))
                                   (get-function-name fn-name)
                                   (get-iter-function-type (get-function-name fn-name))
                                   (cadr (reverse signature)))))
               (progn
                 (add-code "single_fn_f32")))
           (setf expr-list (cdr expr-list)))
    ;; errors ?
    (if (and (not type) (not (is-iter-composition-p type)))
        (error-no-type-def expr-list))
    (if (and type
             (not (is-type-p type))
             (not (is-iter-composition-p type)))
        (error-function-type-unkown expr-list type))
    (setf (gethash (get-function-name fn-name) *function-type*) type)
  expr-list))

(defun set-function-arg (name type)
  (setf (gethash (get-function-name name) *function-args*) type))
  
(defun get-iter-function-args (name)
  (gethash (get-iter-function-name name) *function-args*))

(defun parse-function-name-and-type (expr-list)
  (let* ((def (split ":" (car expr-list)))
         (fn-name (car def))
         (first-arg (split ":" (caddr expr-list)))
         (fn-type ""))
    (if (>= (length first-arg) 2)
        (setf fn-type (cadr first-arg))
        (setf fn-type "void"))
    (set-function-arg (car def) fn-type)
    (cond ((stringp (car expr-list))
           (dbg "parse-function-name-and-type: Functionname " fn-name)
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-function-name-and-type: signature "
                      (gethash (car def) *signatures*))
                 (setf expr-list
                       (parse-function-type expr-list
                                            (gethash (car def) *signatures*))))
               (progn
                 (setf expr-list (parse-function-type expr-list))))
           (add-code " ")))
    (cond ((equal fn-name "main")
           (setf *is-main-defined* t)
           (add-code fn-name))
          (t
           (add-code (format nil "~a_~a"
                             (get-function-name fn-name)
                             fn-type))))
    (dbg "parse-function-name-and-type: EXIT Rest. ")
    expr-list))
  
(defun parse-variable-type (expr-list var-name type &optional (signature nil))
  (let ((code-type ""))
    (if (is-type-p type)
        (progn
          (cond ((search "'" type)
                 (setf code-type (format nil "node_~a*"
                                         (regex-replace "'" type ""))))
                ((search "#" type)
                 (setf code-type (regex-replace "#" type "")))
                ((search ">>" type)
                 (setf code-type (regex-replace ">>" type "**")))
                ((search ">" type)
                 (setf code-type (regex-replace ">" type "*")))
                (t
                 (setf code-type type)))))
    (if (and (not (equal "fun" type))
             (not (is-iter-composition-p type)))
        (add-code code-type))
    (if (is-iter-composition-p type)
        (progn
          (add-code "struct ")
          (add-code (get-iter-composition-name type))))
    (setf (gethash (get-variable-name var-name) *variable-type*) type)
    (setf (gethash (get-variable-name var-name) *variable-type*) type)
    (if (equal "fun" type)
        (if signature
            (progn
              (dbg "parse-variable-type: signature " signature)
              (dbg "parse-variable-type: signature "
                   (format nil "~a (*~a)(~a)"
                           (car (reverse signature))
                           (get-variable-name var-name)
                           (cdr (reverse signature))))
              (add-code (format nil "~a (*~a)(~a)"
                                (car (reverse signature))
                                (get-variable-name var-name)
                                (cadr (reverse signature))))
              (setf (gethash (get-variable-name var-name) *variable-type*) "fun"))
            (progn
              (add-code "single_fn_f32")
              (setf (gethash (get-variable-name var-name) *variable-type*) "fun"))))
    ;; errors ?
    (if (and (not type) (not (is-iter-composition-p type)))
        (error-no-type-def expr-list))
    (if (and type
             (not (is-type-p type))
             (not (is-iter-composition-p type)))
        (error-function-type-unkown expr-list type))
  expr-list))

(defun parse-signature-vector (var-name expr-list)
  (dbg "parse-signature-vector: ENTRY " (car expr-list))
  (if (equal "$" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (equal "[" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-signature-vector: " (car expr-list))
        (setf (gethash var-name *signatures*) (append
                                               (gethash var-name *signatures*)
                                               (list (car expr-list))))
        (dbg "parse-signature-vector: " (gethash var-name *signatures*))
        (setf expr-list (parse-signature-vector var-name (cdr expr-list)))))
  (if (equal "]" (car expr-list))
      (progn
        (dbg "parse-signature-vector: EXIT " (car expr-list))
        (setf expr-list (cdr expr-list))
        (return-from parse-signature-vector expr-list)))
  expr-list)
  
(defun parse-variable (expr-list)
  (dbg "parse-variable: >" (car expr-list) "<")
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-variable: DEFINE " (car expr-list))
           (if (equal "]" (cadr expr-list))
               (error-no-type-def expr-list))
           ;; store current variable
           (setf *current-type-variable* (car def))
           (setf *current-type-definition* (cadr def))
           ;; parse signature
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list (parse-signature-vector
                                  (car def) (cdr expr-list)))
                 (dbg "parse-argument: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list (car def) (cadr def)
                                      (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))))
           ;; if function then register function
           (if (equal (format nil "~a"
                              (gethash (get-variable-name
                                        (car def)) *variable-type*))
                      "fun")
               (register-function (car def) (car expr-list))
               (progn
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           ;; if array emit brackezs
           (if (search "#" (cadr def))
               (add-code "[]"))
           ;; ixx ?
           (if (equal "ixx" (cadr def))
               (progn
                 (add-code (format nil ";~%"))
                 (add-code "mpz_init")
                 (add-code "(")
                 (add-code (get-iter-variable-name (car def)))
                 (add-code ")")
                 (add-code (format nil ";~%"))
                 (add-code "mpz_set")
                 (add-code "(")
                 (add-code (get-iter-variable-name (car def)))
                 (add-code ","))
               ;; initialisation
               (add-code "="))
           ;; if pointer auto ref variables
           (if (search ">" (cadr def))
               (if (or (is-variable-split-name-p (car expr-list))
                       (is-iter-variable-p (car expr-list)))
                   (add-code "&")))
           ;; error ?
           (dbg "parse-variable: OPEN ARG")
           (if (equal (car expr-list) "]")
               (error-missing-expression expr-list))
           ;; parse initialisation
           (dbg "parse-variable: next ")
           (setf expr-list (parse-expression expr-list t))
           ;; ixx ?
           (if (equal "ixx" (cadr def))
               (progn
                 (add-code ")")))
           (add-code (format nil ";~%"))
           ;; store poiner
           (dbg "parse-variable: append size ")
           (if (or (search "#" (cadr def)))
               (progn
                 (let ((type "ARRAY"))
                   (add-code
                    (format nil "append_ptr(~a, sizeof(~a)/sizeof(~a), ~a);~%"
                            (get-variable-name (car def))
                            (get-variable-name (car def))
                            (regex-replace "#" (cadr def) "")
                            type)))))
           (if (search ">" (cadr def))
               (add-code
                (format nil "append_ptr(~a, 1, VARIABLE);~%"
                        (get-variable-name (car def)))))
           (setf *current-type-variable* nil)
           (setf *current-type-definition* nil)
           (dbg "parse-variable: rest " (car expr-list))))
        ((not (find #\: (car expr-list)))
         (dbg "parse-variable: seperator missing! " (car expr-list))
         (setf expr-list (cdr expr-list))
         (error-syntax-error expr-list)))
  expr-list)

(defvar *operators* '(("<" "lt") ("<=" "leqt")
                      (">" "gt") (">=" "geqt")
                      ("==" "eq") ("!=" "neq")))

(defun get-operator-name (operator)
  (dolist (comp *operators*)
    (if (equal (car comp) operator)
        (return-from get-operator-name (cadr comp))))
  (return-from get-operator-name nil))

(defun skip-expression (expr-list parens)
  (if (equal "(" (car expr-list))
      (setf parens (1+ parens)))
  (if (equal ")" (car expr-list))
      (setf parens (1- parens)))
  (if (< parens 0)
      (return-from skip-expression expr-list))
  (skip-expression expr-list parens))
      
(defun parse-condition (expr-list)
  (dbg "parse-condition: " (car expr-list))
  (let ((operator nil))
    (cond ((not expr-list)
           (return-from parse-condition (cdr expr-list)))
          (t
           (setf operator (car expr-list))
           (if (not (get-operator-name operator))
               (progn 
                 (if (and (not (equal "]" (car expr-list)))
                          (equal "(" (car expr-list)))
                     (progn
                       (setf expr-list (parse-expression expr-list t))
                       (add-code ")")
                       (add-code (format nil "~%")))
                     (error-operator-not-defined expr-list))
                 (return-from parse-condition expr-list)))
           (setf expr-list (cdr expr-list))
           (let ((type (get-next-token-type-string expr-list)))
             (setf *current-type-definition* type)
             (add-code (format nil "~a_~a" (get-operator-name operator) type))
             (add-code "(")
             (dbg "parse-condition: parse left-side " (car expr-list))
             (setf expr-list (parse-expression expr-list t))
             (add-code ",")
             (dbg "parse-condition: parse right-side " (cadr expr-list))
             (setf expr-list (parse-expression expr-list t))
             (add-code ")")
             (add-code ")")
             (add-code (format nil "~%"))
             (setf *current-type-definition* nil)
             (dbg "parse-condition: rest " (car expr-list))
             (return-from parse-condition expr-list))))))
    
(defun parse-range (expr-list)
  (dbg "parse-range: " (car expr-list))
  (let ((operator "")
        (from 0)
        (to 0)
        (var-name ""))
    (cond ((equal "]" (car expr-list))
           (add-code "for")
           (add-code "(")
           (add-code ";;")
           (add-code (format nil ")~%"))
          (return-from parse-range expr-list))
          ((find #\: (car expr-list))
           (let ((def (split ":" (car expr-list))))
             (dbg "parse-range: DEFINE " (car expr-list))
             (parse-variable-type expr-list (car def) (cadr def))
             (dbg "parse-range: OPEN ARG")
             (if (equal "]" (cadr expr-list))
                 (error-no-type-def expr-list))
             (add-code " ")
             (setf var-name (get-variable-name (car def)))
             (dbg "parse-range: get-variable-name " var-name)
             (add-code var-name)
             (add-code "=")
             (if (equal (cadr expr-list) "]")
                 (error-missing-expression expr-list))
             (dbg "parse-range: parse from ")
             (setf from expr-list)
             (setf expr-list (parse-expression (cdr expr-list) t))
             (add-code (format nil ";~%"))
             (add-code "for")
             (add-code "(")
             (add-code var-name)
             (add-code "=")
             (setf expr-list (parse-expression (cdr from) t))
             (add-code ";")
             (dbg "parse-range: parse operator " (car expr-list))
             (add-code var-name)
             (setf operator (car expr-list))
             (setf expr-list (cdr expr-list))
             (add-code operator)
             (dbg "parse-range: parse to " (car expr-list))
             (setf to expr-list)
             (setf expr-list (parse-expression expr-list t))
             (add-code (format nil ";"))
             (add-code var-name)
             (if (or (equal operator "<") (equal operator "<="))
                 (add-code "++"))
             (if (or (equal operator ">") (equal operator ">="))
                 (add-code "--"))
             (if (equal operator "==")
                 (add-code "++"))
             (if (equal operator "!=")
                 (add-code "++"))
             (if (equal operator "=")
                 (add-code "++"))
             (add-code ")")
             (add-code (format nil "~%"))
             (dbg "parse-range: rest ")))
          ((not (find #\: (car expr-list)))
           (setf expr-list (cdr expr-list))
           (error-no-type-def expr-list)))
    expr-list))

(defun parse-block (expr-list)
  (dbg "parse-block " (car expr-list) " block " *block*)
  (if (not expr-list)
      (progn
       (dbg "parse-block: NULL " (car expr-list))
       (return-from parse-block expr-list)))
  (if (equal "(" (car expr-list))
      (progn
        (dbg "parse-block before expression " (car expr-list))
        (setf expr-list (parse-expression expr-list))
        (dbg "parse-block: after expression " (car expr-list))
        (sb-ext:gc)
        (setf expr-list (parse-block expr-list))))
  (if (equal "\"" (car expr-list))
      (progn
        (dbg "parse-expression: STRING block " *block*)
        (add-code "\"")
        (setf expr-list (parse-cstr (cdr expr-list)))
        (dbg "parse-expression: STRING END ")
        (add-code (format nil ";~%"))
        (dbg "parse-block: return" (car expr-list))
        (return-from parse-block expr-list)))
  (if (equal ")" (car expr-list))
      (progn
        (dbg "parse-block: ) " (car expr-list))
        (return-from parse-block expr-list)))
  (if (and (not (equal ")" (car expr-list)))
           (not (equal "(" (car expr-list))))
      (progn
        (dbg "parse-block " (car expr-list))
        (setf expr-list (cdr expr-list))
        (setf expr-list (parse-block expr-list)))))

(defun parse-function-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-function-vector: parse variable")  
    (setf expr-list (parse-argument expr-list))
    (if (equal "]" (car expr-list))
        (return-from parse-function-vector expr-list))
    (if (and (not (find #\: (cadr expr-list))) (not (equal "]" (cadr expr-list))))
        (error-function-vector-malformed expr-list))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-function-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-function-vector expr-list))))))

(defun parse-type-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-typevector: parse variable")  
    (setf expr-list (parse-types expr-list))
  (if (not expr-list)
      (return-from parse-type-vector (cdr expr-list)))
    (if (equal "]" (car expr-list))
        (return-from parse-type-vector expr-list))
    (if (and (not (find #\: (cadr expr-list)))
             (not (equal "]" (cadr expr-list))))
        (error-composition-vector-malformed expr-list))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-type-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-type-vector expr-list))))))

(defun parse-if-vector (expr-list)
  (dbg "parse-if-vector: condition range" (car expr-list))  
  (setf expr-list (parse-condition expr-list))
  (dbg "parse-if-vector: after condition " (car expr-list))
  (if (not expr-list)
      (return-from parse-if-vector (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-if-vector expr-list))
  (dbg "parse-if-vector: after loop " (car expr-list))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-if-vector: next variable" (car expr-list))  
        (setf expr-list (parse-if-vector expr-list))))
  (dbg "parse-if-vector: exit" (car expr-list))
  expr-list)

(defun parse-for-vector (expr-list)
  (dbg "parse-for-vector: parse range")  
  (setf expr-list (parse-range expr-list))
  (if (not expr-list)
      (return-from parse-for-vector (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-for-vector expr-list))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-for-vector: next variable")  
        (setf expr-list (parse-for-vector expr-list))))
  (dbg "parse-for-vector: exit" (car expr-list))
  expr-list)

(defun parse-let-vector (expr-list)
  (dbg "parse-let-vector: parse variable")  
  (setf expr-list (parse-variable expr-list))
  (if (equal "]" (car expr-list))
      (return-from parse-let-vector expr-list))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-let-vector: next variable")  
        (setf expr-list (parse-let-vector expr-list))))
  (dbg "parse-let-vector: exit" (car expr-list))
  expr-list)

(defun parse-open-square-bracket (expr-list)
  (dbg "parse-open-square-bracket")  
  (if (equal "[" (car expr-list))
      (return-from parse-open-square-bracket (cdr expr-list))
      (error-missing-open-square-bracket expr-list)))

(defun parse-close-square-bracket (expr-list)
  (dbg "parse-close-square-bracket")  
  (if (equal "]" (car expr-list))
      (return-from parse-close-square-bracket (cdr expr-list))
      (error-missing-close-square-bracket expr-list)))

(defun parse-open-parens (expr-list)
  (dbg "parse-open-parens")  
  (if (equal "(" (car expr-list))
      (return-from parse-open-parens (cdr expr-list))
      (error-missing-open-parens expr-list)))

(defun parse-close-parens (expr-list)
  (dbg "parse-close-parens")  
  (if (equal ")" (car expr-list))
      (return-from parse-close-parens (cdr expr-list))
      (error-missing-close-parens expr-list)))

(defun parse-if (expr-list)
  (inc-block)
  (dbg "parse-if: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (set-insert-points)
  (setf expr-list (parse-expression expr-list))
  (add-code (format nil "}~%"))
  (if (not (equal ")" (car expr-list)))
      (progn
        (add-code "else")
        (add-code (format nil "~%{~%"))
        (set-insert-points)
        (setf expr-list (parse-expression expr-list))
        (add-code (format nil "}~%"))))
  (set-insert-points)
  (dec-block)
  (dbg "parse-if BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-while (expr-list)
  (inc-block)
  (dbg "parse-while: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (set-insert-points)
  (setf expr-list (parse-block expr-list))
  (add-code (format nil "};~%"))
  (set-insert-points)
  (dec-block)
  (dbg "parse-while BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-for (expr-list)
  (inc-block)
  (dbg "parse-for: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-for-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (set-insert-points)
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (set-insert-points)
  (dbg "parse-for BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-for ")
  expr-list)

(defun parse-let (expr-list)
  (inc-block)
  (dbg "parse-let: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (set-insert-points)
  (setf expr-list (parse-let-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-let BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-let ")
  expr-list)

(defun parse-compose (expr-list)
  (let ((composition-name (get-composition-name (car expr-list))))
    (setf *current-composition* (car expr-list))
    (dbg "parse-compose: name " *current-composition*
         " and type block " *block*
         " parens " *paranteses*)
    (dbg "parse-compose: open square")
    (add-code (format nil "struct ~a" composition-name))
    (add-code (format nil "~%{~%"))
    (setf expr-list (cdr expr-list))
    (setf expr-list (parse-open-square-bracket expr-list))
    (setf expr-list (parse-type-vector expr-list))
    (setf expr-list (parse-close-square-bracket expr-list))
    (add-code (format nil "};~%"))
    (add-code (format nil "typedef struct ~a ~a;~%" composition-name composition-name))
    (dbg "parse-compose BLOCK END block " *block* " parens " *paranteses*)
    (dbg "parse-compose " (car expr-list))
    (setf *current-composition* "")
    expr-list))

(defun parse-def-function (expr-list)
  (let ((fn-name (car expr-list)))
  (dbg "parse-def-function: name and type block " *block* " parens " *paranteses*)
  (setf expr-list (parse-function-name-and-type expr-list))
  (inc-block)
  (dbg "parse-def-function: open square")
  (add-code "(")
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-function-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code ")")
  (add-code (format nil "~%{~%"))
  (setf *current-function* fn-name)
  (if (equal "main" fn-name)
      (progn
        (set-insert-main-points)
        (insert-main-buffer)))
  (set-insert-points)
  (setf expr-list (parse-block expr-list))
  (if (search "main" fn-name)
      (add-code (format nil "destroy_ptr(pointer_list);~%")))
  (setf *current-function* nil)
  (add-code (format nil "}~%"))
  (dec-block)
  (dbg "parse-def-function BLOCK END block " *block* " parens " *paranteses*)
  expr-list))

(defun parse-module (expr-list)
  (setf *current-module* (car expr-list))
  (inc-block)
  (setf expr-list (cdr expr-list))
  (set-insert-points)
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (setf *current-module* "")
  expr-list)

(defun parse-multiline-comment (expr-list)
  (if (not expr-list) (return-from parse-multiline-comment expr-list))
  (cond ((and (equal "|" (car expr-list)) (equal ";" (cadr expr-list)))
         (dbg "parse-multiline-comment: CLOSE")
         (return-from parse-multiline-comment (cddr expr-list)))
        ((stringp (car expr-list))
         (dbg "parse-multiline-comment: COMMENT >" (car expr-list) "<")
         (setf expr-list (parse-multiline-comment (cdr expr-list))))))

(defun parse-single-line-comment (expr-list)
  (if (not expr-list) (return-from parse-single-line-comment expr-list))
  (cond ((equal (format nil "~a" #\Newline) (car expr-list))
         (if (or (equal (format nil "~a" #\Newline) (cadr expr-list))
                 (equal ";" (cadr expr-list)))
             (setf expr-list (parse-single-line-comment (cdr expr-list)))
             (setf expr-list (cdr expr-list)))
         (return-from parse-single-line-comment expr-list))
        ((not (equal (format nil "~a" #\Newline) (car expr-list)))
         (dbg "parse-singleline-comment: COMMENT " (car expr-list))
         (setf expr-list (parse-single-line-comment (cdr expr-list))))))

(defun parse-null (expr-list)
  (cond ((equal "}" (car expr-list))
         (add-code (car expr-list))
         (return-from parse-null (cdr expr-list)))
        ((not (equal "}" (car expr-list)))
         (dbg "parse-null: " (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-null (cdr expr-list))))))

(defun parse-cstr (expr-list)
  (cond ((equal "\"" (car expr-list))
         (add-code "\"")
         (setf expr-list (cdr expr-list))
         (return-from parse-cstr expr-list))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-cstr (cdr expr-list)))))
  expr-list)

(defun parse-element (expr-list)
  (dbg "parse-element " (car expr-list))
  (cond ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", ")))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", "))))
  (cdr expr-list))
             
(defun parse-vector (expr-list)
  (dbg "parse-vector " (car expr-list))
  (cond ((equal "[" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-vector expr-list))))
        ((equal "]" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-vector expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-vector expr-list)))))
  expr-list)
  
(defun parse-list (expr-list)
  (dbg "parse-list " (car expr-list))
  (cond ((equal "'(" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-list expr-list))))
        ((equal ")" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-list expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-list expr-list)))))
  expr-list)

(defun is-math-operator-p (obj)
  (dolist (operator *math-operators*)
    (if (equal obj operator)
        (return-from is-math-operator-p t)))
  (return-from is-math-operator-p nil))

(defun infer-parens (expr-list x)
  (let ((type "")
        (len (length expr-list)))
    (if (or (= x (- len 2))
            (equal ")" (car expr-list))
            (equal "]" (car expr-list)))
        (progn
          (setf x (1+ x))
          (return-from infer-parens x))
        (progn
          (setf type (determine-type-of-symbol (subseq expr-list x (- len 1))))
          (if (equal type "ixx")
              (return-from infer-parens x))
          (setf x (1+ x))
          (infer-parens expr-list x)))))

(defun skip-parens (expr-list x)
  (let ((len (length expr-list)))
    (if (or (= x (- len 2))
            (equal ")" (car expr-list))
            (equal "]" (car expr-list)))
        (progn
          (setf x (1+ x))
          (return-from skip-parens x))
        (progn
          (setf x (1+ x))
          (skip-parens expr-list x)))))
  
(defun infer-math-type (expr-list)
  (let ((parens 0)
        (default-type "f64")
        (type "")
        (len (length expr-list)))
    (loop for x from 0 to (- len 2) do
         (let ((obj (elt expr-list x))
               (next (elt expr-list (1+ x))))
           (if (or (not expr-list) (not obj))
               (return-from infer-math-type type))
           (if (or (equal "(" obj)
                   (equal "[" obj))
               (progn
                 (setf parens (1+ parens))
                 (if (= parens 0)
                     (progn
                       (if (is-math-operator-p next)
                           (progn
                             (setf x (1- (infer-parens expr-list x))))
                           (progn
                             (setf x (1- (skip-parens expr-list x)))))))))
           (if (or (equal ")" obj)
                   (equal "]" obj))
               (progn
                 (setf parens (1- parens))
                 (if (< parens 0)
                     (progn
                       (return-from infer-math-type default-type)))))
           (if (and (not (equal "(" obj))
                    (not (equal "[" obj))
                    (not (equal ")" obj))
                    (not (equal "]" obj))
                    (not (is-math-operator-p obj)))
               (progn
                 (setf type (determine-type-of-symbol
                             (subseq expr-list x len)))
                 (dbg "infer-math-type: >" type "<" (subseq expr-list x len))
                 (if (equal type "ixx")
                     (return-from infer-math-type type))
                 (if (and type (not (equal type "ixx")))
                     (setf default-type type))
                 (if (not type)
                     (return-from infer-math-type default-type))))))
    (dbg "infer-math-type: loop end " type)
    default-type))
  
(defun count-elements (expr-list)
  (let ((count 0)
        (parens 0))
    (loop for x from 0 to (1- (length expr-list)) do
         (if (or (equal "(" (elt expr-list x))
                 (equal "[" (elt expr-list x)))
             (progn
               (if (= parens 0)
                   (setf count (1+ count)))
               (setf parens (1+ parens))))
         (if (or (equal ")" (elt expr-list x))
                 (equal "]" (elt expr-list x)))
             (progn
               (setf parens (1- parens))
               (if (< parens 0)
                   (return-from count-elements count))))
         (if (and (not (equal "(" (elt expr-list x)))
                  (not (equal ")" (elt expr-list x))))
             (progn
               (if (= parens 0)
                   (setf count (1+ count))))))
    count))

(defun compose-iter-composition-type (expr-list)
  (let* ((split (split ">>" (car expr-list)))
         (lst (cdr (reverse (cdr (reverse split)))))
         (struct-type (gethash (get-iter-variable-name (car split)) *variable-type*))
         (struct-name (get-iter-composition-name (format nil "~a" struct-type)))
         (var-name (cadr split))
         (count 2)
         (composition (format nil "~a>>~a" struct-name var-name)))
    (if (= (length split) 2)
        (progn
          (dbg "compose-iter-composition-type: composition " composition)
          (return-from compose-iter-composition-type (gethash composition *variable-type*))))
    (loop for sub-name in lst do
         (dbg "get-iter-composition: sub-name " sub-name)
         (dbg "get-iter-composition: composition " composition)
         (setf struct-type
               (gethash composition *variable-type*))
         (dbg "compose-iter-composition-type: struct-type " struct-type)
         (setf struct-name (get-iter-composition-name (format nil "~a" struct-type)))
         (dbg "compose-iter-composition-type: struct-name " struct-name)
         (setf var-name (elt split count))
         (dbg "compose-iter-composition-type: var-name " var-name)
         (setf count (1+ count))
         (setf composition (format nil "~a>>~a" struct-name var-name))
         (dbg "compose-iter-composition-type: composition " composition))
    (gethash composition *variable-type*)))

(defun build-dotted-type (composition)
  (let* ((split (split ">>" composition))
         (lst (cdr split))
         (var-name (elt split 0))
         (str nil))
    (if (is-iter-variable-p var-name)
        (progn
          (setf str (concatenate 'string (get-iter-variable-name var-name)))
          (loop for sub-name in lst do
               (setf str (concatenate 'string str "." sub-name))))
        (progn
          (setf str (get-iter-variable-name (regex-replace ">>" composition "__")))))
    (dbg "build-dotted-type " str)
    str))

(defun lisp-to-next-type (token)
  (let ((type (string-downcase (format nil "~a" token)))
        (type-str))
    (if token
        (progn
          (cond ((equal type "boolean")
                 (setq type-str "bool"))
                ((equal type "char")
                 (setq type-str "c8"))
                ((equal type "integer")
                 (setq type-str "i32"))
                ((equal type "fixnum")
                 (setq type-str "i64"))
                ((equal type "big-integer")
                 (setq type-str "ixx"))
                ((equal type "double-float")
                 (setq type-str "f64"))
                ((equal type "single-float")
                 (setq type-str "f32"))
                ((equal type "char-array")
                 (setq type-str "c8#"))
                ((equal type "string")
                 (setq type-str "string"))
                ((equal type "file")
                 (setq type-str "file"))
                ((equal type "boolean-array")
                 (setq type-str "bool#"))
                ((equal type "char-array")
                 (setq type-str "string"))
                ((equal type "integer-array")
                 (setq type-str "i32#"))
                ((equal type "fixnum-array")
                 (setq type-str "i64#"))
                ((equal type "double-float-array")
                 (setq type-str "f64#"))
                ((equal type "single-float-array")
                 (setq type-str "f32#"))
                ((equal type "boolean-pointer")
                 (setq type-str "bool>"))
                ((equal type "char-pointer")
                 (setq type-str "c8>"))
                ((equal type "integer-pointer")
                 (setq type-str "i32>"))
                ((equal type "big-integer-pointer")
                 (setq type-str "ixx>"))
                ((equal type "double-float-pointer")
                 (setq type-str "f64>"))
                ((equal type "single-float-pointer")
                 (setq type-str "f32>"))))
        (setq type-str type))
    (dbg (format nil "lisp-to-next-type ~a" type))
    (dbg "lisp-to-next-type " type-str)
    type-str))

(defun get-literal-type (symbol-value)
  (progn
    (if (equal "\"" symbol-value)
        "string")))

(defun determine-type-of-symbol (expr-list &optional (skip-infer nil))
  (let* ((symbol-value (car expr-list))
         (literal-type (get-literal-type symbol-value))
         (variable-type (get-iter-variable-type symbol-value))
         (number-type (type-of-number-string symbol-value))
         (inspect-type (inspect-function-type expr-list))
         (function-type (get-iter-function-type symbol-value))
         (type-str ""))
    ;; infer type when math operation
    (if (and (not skip-infer)
             (equal "(" (car expr-list))
             (is-math-operator-p (cadr expr-list)))
        (progn
          (setf inspect-type (infer-math-type expr-list))
          (setf *current-type-definition* inspect-type)))
    (if inspect-type
        (dbg "inspect-type " inspect-type))
    (if literal-type
        (dbg "literal-type " literal-type))
    (if variable-type
        (dbg "variable-type " variable-type))
    (if number-type
        (dbg "number-type " (format nil "~a" number-type)))
    (if function-type
        (dbg "function-type " (format nil "~a" function-type)))
    (cond ((is-iter-composition-type-p expr-list)
           (setf type-str (compose-iter-composition-type expr-list)))
          ((is-type-p variable-type)
           (setf type-str variable-type))
          ((is-type-p inspect-type)
           (setf type-str inspect-type))
          ((is-type-p function-type)
           (setf type-str function-type))
          ((is-type-p number-type)
           (setf type-str number-type))
          ((is-type-p literal-type)
           (setf type-str literal-type))
          (t
           (setf type-str "void")))
    ;           (error-cant-infer-type symbol-value)))
    (dbg "determine-type-of-symbol: type-str " type-str)
    type-str))

(defun get-next-token-type-string (expr-list &optional (skip-infer nil))
  (let ((type-str (determine-type-of-symbol expr-list skip-infer)))
    ;; turn next-type into c-type-string
    (if (is-type-p type-str)
        (progn
          (cond ((search "cstring" type-str)
                 (setf type-str "cstring"))
                ((search "'" type-str)
                 (setf type-str (format nil "list_~a"
                                        (regex-replace "'" type-str ""))))
                ((search "#" type-str)
                 (setf type-str (format nil "array_~a"
                                        (regex-replace "#" type-str ""))))
                ((search ">>" type-str)
                 (setf type-str (format nil "handle_~a"
                                        (regex-replace ">>" type-str ""))))
                ((search ">" type-str)
                 (setf type-str (format nil "pointer_~a"
                                        (regex-replace ">" type-str "")))))))
    (dbg "get-next-token-type-string: type-str " type-str)
    type-str))

(defun is-type-p (cast)
  (dolist (type *types*)
    (if (equal type cast)
        (return-from is-type-p t))))

(defun parse-bigint-number (expr-list number)
  (let ((tmp-var (fgensym))
        (tmp-target *target*))
    (setf (gethash *paranteses* *definition_buffer*) '(""))
    (setf *target* 'definition-buffer)
    (add-bigint-declaration tmp-var number)
    ;; last real target
    (set-target tmp-target)
    (insert-definition-buffer)
    (setf (gethash *paranteses* *definition_buffer*) '(""))
    (if (or (not *current-type-definition*)
            (equal "ixx" *current-type-definition*))
        (add-code tmp-var))
    (if (is-fixed-math-type-p *current-type-definition*)
        (progn
          (add-code "mpz_get_si")
          (add-code "(")
          (add-code tmp-var)
          (add-code ")")))
    (setf *tmp-var* tmp-var)
    (return-from parse-bigint-number expr-list)))

(defun parse-infix (expr-list function)
  (if (equal ")" (car expr-list))
      (progn
        (dbg "parse-infix: EXIT ")
        (return-from parse-infix expr-list)))
  (dbg "parse-infix: operand " (car expr-list))
  (setf expr-list (parse-expression expr-list t))
  (if (not (equal ")" (car expr-list)))
      (progn
        (add-code function)
        (setf expr-list (parse-infix expr-list function))))
  expr-list)

(defmacro parse-map (expr-list form &optional (max 1))
  `(progn
     (add-code ,form)
     (add-code "(")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defmacro parse-math (expr-list form &optional (max 1))
  `(let ((type (get-next-token-type-string (cdr ,expr-list) t)))
     (add-code (format nil "~a_~a" ,form type))
     (add-code "(")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defmacro parse-type-cast (expr-list current form &optional (max 1))
  `(progn
     (setf *current-type-definition* ,current)
     (add-code "(")
     (add-code ,form)
     (add-code ")")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max t))
     (setf *current-type-definition* nil)
     (return-from parse-call ,expr-list)))

(defmacro parse-calculation (expr-list word operator)
  `(let ((type (get-next-token-type-string (cdr ,expr-list) t)))
     (dbg "parse-calculation " (car ,expr-list) " next "
          (cadr ,expr-list))
     (setf expr-list (cdr ,expr-list))
     ;; handling ixx types
     (if (or (equal *current-type-definition* "ixx")
             (equal "ixx" type))
         (progn
           (setf expr-list (parse-bigint-operation ,expr-list ,word))
           (return-from parse-call ,expr-list)))
     ;; handling non-infix operators
     (if (is-non-infix-operator-p ,word)
         (progn
           (add-code ,operator)
           (add-code "(")
           (setf expr-list (parse-arguments ,expr-list (count-elements ,expr-list)))
           (return-from parse-call ,expr-list)))
     ;; handling infix operations
     (add-code "(")
     (if (not (equal ")" (car ,expr-list)))
         (progn
           (dbg "parse-call: parse-infix "
                (get-iter-variable-name (car ,expr-list)))
           (setf expr-list (parse-infix ,expr-list ,operator)))
         (error-operator-not-defined ,expr-list))
     (setf expr-list (parse-arguments ,expr-list (count-elements ,expr-list)))
     ,expr-list))

(defun list-into-list (lista listb index)
  (let ((new-list '())
        (lena (length lista))
        (lenb (length listb)))
    (loop for x from 0 to (1- (length lista)) do
         (push (elt lista (- lena x 1)) new-list)
         (if (equal x (- lena index 1))
             (progn
               (loop for y from 0 to (1- (length listb)) do
                    (push (elt listb (- lenb y 1)) new-list)))))
    new-list))

(defun get-bigint-operator (operator)
  (if (or (equal "add" operator) (equal "badd" operator) (equal "+" operator))
      (return-from get-bigint-operator "mpz_add"))
  (if (or (equal "sub" operator) (equal "bsub" operator) (equal "-" operator))
      (return-from get-bigint-operator "mpz_sub"))
  (if (or (equal "div" operator) (equal "bdiv" operator) (equal "/" operator))
      (return-from get-bigint-operator "mpz_div"))
  (if (or (equal "mul" operator) (equal "bmul" operator) (equal "*" operator))
      (return-from get-bigint-operator "mpz_mul"))
  (if (or (equal "sqrt" operator) (equal "bsqrt" operator) (equal "√" operator))
      (return-from get-bigint-operator "mpz_sqrt"))
  (if (or (equal "power" operator) (equal "bpower" operator) (equal "^" operator))
      (return-from get-bigint-operator "mpz_powm")))

(defun insert-main-buffer ()
  (if (equal *target* 'main-buffer)
      (progn
        (setf (gethash (1- *paranteses*) *main_buffer*)
              (list-into-list
                           (gethash (1- *paranteses*) *main_buffer*)
                           (gethash *paranteses* *main_buffer*)
                           *line-start-code*))
        (setf *line-start-implementation*
              (+ *line-start-implementation*
                 (length (gethash *paranteses* *main_buffer*))))))
  (if (equal *target* 'implementation)
      (progn
        (setf *implementation_list* (list-into-list
                                     *implementation_list*
                                     (gethash *paranteses* *main_buffer*)
                                     *main-start-implementation*))
        (setf *main-start-implementation*
              (+ *main-start-implementation*
                 (length (gethash *paranteses* *main_buffer*)))))))

(defun insert-definition-buffer ()
  (if (equal *target* 'definition-buffer)
      (progn
        (setf (gethash (1- *paranteses*) *definition_buffer*)
              (list-into-list
                           (gethash (1- *paranteses*) *definition_buffer*)
                           (gethash *paranteses* *definition_buffer*)
                           *line-start-code*))
        (setf *line-start-code*
              (+ *line-start-code*
                 (length (gethash *paranteses* *definition_buffer*))))))
  (if (equal *target* 'code)
      (progn
        (setf *code_list* (list-into-list
                           *code_list*
                           (gethash *paranteses* *definition_buffer*)
                           *line-start-code*))
        (setf *line-start-code*
              (+ *line-start-code*
                 (length (gethash *paranteses* *definition_buffer*))))))
  (if (equal *target* 'implementation)
      (progn
        (setf *implementation_list* (list-into-list
                                     *implementation_list*
                                     (gethash *paranteses* *definition_buffer*)
                                     *line-start-implementation*))
        (setf *line-start-implementation*
              (+ *line-start-implementation*
                 (length (gethash *paranteses* *definition_buffer*)))))))

(defun fgensym ()
  (let* ((sym1 (gensym))
         (sym (format nil "~a" sym1)))
    sym))

(defun add-bigint-init (name value)
  (add-code "mpz_init_set_si")
  (add-code "(")
  (add-code (get-variable-name name))
  (add-code ",")
  (add-code value)
  (add-code ")")
  (add-code (format nil ";~%")))

(defun add-bigint-declaration (tmp-var &optional (value "0"))
  (setf (gethash (get-variable-name tmp-var) *variable-type*) "ixx")
  (add-code "mpz_t")
  (add-code " ")
  (add-code tmp-var)
  (add-code (format nil ";~%"))
  (add-code "mpz_init_set_str")
  (add-code "(")
  (add-code tmp-var)
  (add-code ",")
  (add-code (format nil "\"~a\"" value))
  (add-code ",")
  (add-code "10")
  (add-code ")")
  (add-code (format nil ";~%")))

(defun add-bigint-declaration-with-ixx-var (tmp-var var-name)
  (setf (gethash (get-variable-name tmp-var) *variable-type*) "ixx")
  (add-code "mpz_t")
  (add-code " ")
  (add-code tmp-var)
  (add-code (format nil ";~%"))
  (add-code "mpz_init_set")
  (add-code "(")
  (add-code tmp-var)
  (add-code ",")
  (add-code (get-iter-variable-name var-name))
  (add-code ")")
  (add-code (format nil ";~%")))

(defun add-bigint-declaration-with-var (tmp-var var-name)
  (add-code "mpz_t")
  (add-code " ")
  (add-code tmp-var)
  (add-code (format nil ";~%"))
  (add-code "mpz_set_si")
  (add-code "(")
  (add-code tmp-var)
  (add-code ",")
  (add-code (get-iter-variable-name var-name))
  (add-code ")")
  (add-code (format nil ";~%")))

(defun add-bigint-term (expr-list tmp-var operator)
  (let ((tmp-target *target*)
        (op1 tmp-var)
        (op2)
        (skip-progress nil)
        (skip-value-declaration nil)
        (skip-var-declaration nil)
        (tmp-var2 (fgensym))
        (op3 (fgensym))
        (type (determine-type-of-symbol expr-list))
        (intz 0))

    (dbg "add-bigint-term: " (car expr-list))
    ;; declare var for values
    (if (equal "(" (car expr-list))
        (progn
          (dbg "add-bigint-term: 1 " (car expr-list))
          (setf expr-list (parse-expression expr-list t))
          (dbg "add-bigint-term: 2 " (car expr-list))
          (setf op2 *tmp-var*)
          (setf skip-progress t)
          (setf skip-var-declaration t)
          (setf skip-value-declaration t))
        (if (not (is-iter-variable-p (car expr-list)))
            (if (is-bigint-p (car expr-list))
                (progn
                  (setf skip-var-declaration t)
                  (setf intz (get-bigint (car expr-list)))
                  (setf op2 tmp-var2)) ;; mpz_t
                (progn
                  (setf skip-var-declaration t)
                  (setf intz (car expr-list))
                  (setf op2 tmp-var2))) ;; integer
            (progn
              (if (equal type "ixx")
                  (progn
                    (setf skip-var-declaration t)
                    (setf op2 (get-iter-variable-name (car expr-list))))
                  (progn
                    (setf intz (car expr-list))
                    (setf op2 tmp-var2)
                    (setf skip-value-declaration t))))))
    
    ;; switch target - clear buffer
    (set-target 'definition-buffer)
    (setf (gethash *paranteses* *definition_buffer*) '(""))

    ;; add declaration with string value
    (if (not skip-value-declaration)
        (add-bigint-declaration tmp-var2 intz))

    ;; add declaration with non-ixx-var
    (if (not skip-var-declaration)
        (add-bigint-declaration-with-var tmp-var2 intz))
    
    ;; add modulator var
    (if (equal "mpz_powm" operator)
        (progn
          (add-bigint-declaration op3 (format nil "~a" (expt 2 128)))))
    
    ;; add mpz_call
    (add-code operator)
    (add-code "(")
    ;; add op1
    (add-code tmp-var)
    (add-code ",")
    ;; add op2
    (add-code op1)
    (add-code ",")
    (add-code op2)
    
    ;; modulator
    (if (equal "mpz_powm" operator)
        (progn
          (add-code ",")
          (add-code op3)))
    
    ;; end of operation
    (add-code ")")
    (add-code (format nil ";~%"))

    ;; swith target and insert buffer
    (set-target tmp-target)
    (insert-definition-buffer)

    (if (not skip-progress)
        (setf expr-list (cdr expr-list)))
    expr-list))
  
(defun parse-bigint-operation-next (expr-list tmp-var operator)
  (if (not (equal ")" (car expr-list)))
      (progn
        (setf expr-list (add-bigint-term expr-list tmp-var operator))
        (setf expr-list (parse-bigint-operation-next
                         expr-list tmp-var operator)))
      (return-from parse-bigint-operation-next expr-list)))

(defun parse-bigint-operation (expr-list operator)
  (let ((tmp-target *target*)
        (tmp-var (fgensym))
        (bigint-operator (get-bigint-operator operator))
        (op1)
        (type (determine-type-of-symbol expr-list))
        (skip-value-declaration nil)
        (init-with-var nil)
        (init-with-ixx-var nil))
    
    (dbg "parse-bigint-operation: " bigint-operator " next " (car expr-list))
    ;; set start marker
    (if (= *start-operation* -1)
        (setf *start-operation* *paranteses*))

    ;; add mpz_t and init with 0 +/- or 1 */ 
    (if (equal "(" (car expr-list))
        (progn
          (dbg "add-bigint-operands: 1 " (car expr-list))
          (setf expr-list (parse-expression expr-list t))
          (dbg "add-bigint-operands: 2 " (car expr-list))
          (setf tmp-var *tmp-var*)
          (setf skip-value-declaration t))
        (if (not (is-iter-variable-p (car expr-list)))
            (if (is-bigint-p (car expr-list))
                (progn
                  (setf op1 (get-bigint (car expr-list)))) ; mpz_t
                (progn
                  (setf op1 (car expr-list))))
            (progn
              (if (equal "ixx" type)
                  (progn
                    (setf op1 (car expr-list))
                    (setf init-with-ixx-var t))
                  (progn
                    (setf op1 (car expr-list))
                    (setf init-with-var t)))
              (setf skip-value-declaration t)))) ;; integer

    ;; switch target - clear buffer
    (set-target 'definition-buffer)
    (setf (gethash *paranteses* *definition_buffer*) '(""))        

    ;; add declaration
    (if (not skip-value-declaration)
        (progn
          (add-bigint-declaration tmp-var op1)
          (setf expr-list (cdr expr-list))))
    (if init-with-ixx-var
        (progn
          (add-bigint-declaration-with-ixx-var tmp-var op1)
          (setf expr-list (cdr expr-list))))
    
    (if init-with-var
        (progn
          (add-bigint-declaration-with-var tmp-var op1)
          (setf expr-list (cdr expr-list))))
    
    (if (equal "sqrt" operator)
        (progn
          (add-code bigint-operator)
          (add-code "(")
          (add-code tmp-var)
          (add-code ",")
          (add-code tmp-var)
          (add-code ")")
          (add-code (format nil ";~%"))))
          
    ;; swith target and insert buffer
    (set-target tmp-target)
    (insert-definition-buffer)
          
    ;; next var
    (setf expr-list
          (parse-bigint-operation-next expr-list tmp-var bigint-operator))

    ;; end add var
    (if (= (- *paranteses* *start-operation*) 0)
        (progn
          (add-code "(")
          (add-code tmp-var)
          (setf *start-operation* -1)))
    (setf *tmp-var* tmp-var)
    (return-from parse-bigint-operation expr-list)))

(defvar *stop* nil)

(defun parse-arguments (expr-list max &optional (omit-comma nil))
  (dbg "parse-arguments: >" (car expr-list) "<")
  (cond ((equal "\"" (car expr-list))
         (if (and *paranteses*
                  (not (equal "(" (get-last-code)))
                  (not omit-comma))
             (add-code ","))
         (add-code "\"")
         (dbg "parse-arguments: parse-cstr >" (car expr-list) "<")
         (setf expr-list (parse-cstr (cdr expr-list)))
         (setf expr-list (parse-arguments expr-list max)))
        ((equal ")" (car expr-list))
         (dbg "parse-arguments: " (car expr-list))
         (return-from parse-arguments expr-list))
        ((equal "]" (car expr-list))
         (dbg "parse-arguments: " (car expr-list))
         (return-from parse-arguments expr-list))
        ((equal "," (car expr-list))
         (error-syntax-error expr-list))
        ((equal "'" (car expr-list))
            (let ((type (get-next-token-type-string (cdddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-arguments: parse list literal ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (return-from parse-arguments expr-list)))
        ((equal "[" (car expr-list))
            (let ((type (get-next-token-type-string (cddr expr-list)))
                  (start (cdr expr-list)))
              (add-code (format nil "create_array_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-arguments: parse array literal ")
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (return-from parse-arguments expr-list)))
        ((equal "(" (car expr-list))
         (progn
           (if (and *paranteses*
                    (not (equal "(" (get-last-code)))
                    (not omit-comma))
               (add-code ","))
           (setf expr-list (parse-expression expr-list t))
           (setf expr-list (parse-arguments expr-list
                                            (1- (count-elements expr-list))))))
        ((is-bigint-p (car expr-list))
         (progn
           (if (and (not (equal "(" (get-last-code)))
                    (not omit-comma))
               (add-code ","))
           (setf expr-list (parse-bigint-number expr-list (get-bigint (car expr-list))))
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list max))))
        ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (progn
           (if (and (not (equal "(" (get-last-code)))
                    (not omit-comma))
               (add-code ","))
           (progn
             ; convert lisp double-float to c double
             (setf (car expr-list) (regex-replace-all "d0" (car expr-list) "f"))
             (add-code (car expr-list))
             (setf expr-list (parse-arguments (cdr expr-list) max)))))
        ((or (is-variable-split-name-p (car expr-list))
             (is-iter-variable-p (car expr-list)))
         (let ((comp-name (build-dotted-type (car expr-list)))
               (var-name (regex-replace ">>.*" (car expr-list) ""))
               (tmp-target *target*)
               (type (determine-type-of-symbol expr-list)))
           (if (and (not (equal "(" (get-last-code)))
                    (not omit-comma))
               (add-code ","))
           (dbg "parse-arguments: VARIABLE " (get-iter-variable-name var-name))
           (if (search ">>" (car expr-list))
               (add-code comp-name)
               (progn
                 (if (equal "ixx" type)
                     (progn
                       (if (equal type *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (not *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (is-fixed-math-type-p *current-type-definition*)
                           (progn
                             (add-code "mpz_get_si")
                             (add-code "(")
                             (add-code (get-iter-variable-name var-name))
                             (add-code ")")))))
                 (if (is-fixed-math-type-p type)
                     (progn
                       (if (is-fixed-math-type-p *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (not *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (equal "ixx" *current-type-definition*)
                           (progn
                             (set-target 'definition-buffer)
                             (setf (gethash *paranteses* *definition_buffer*) '(""))
                             (add-bigint-declaration-with-var (fgensym) var-name)
                             (set-target tmp-target)
                             (insert-definition-buffer)))))))
           (setf expr-list (parse-arguments (cdr expr-list) max))
           (return-from parse-arguments expr-list)))
        ((is-iter-function-p (car expr-list))
         (let* ((fn-name (car expr-list))
                (fn-type (get-iter-function-args fn-name)))
           (dbg "parse-arguments: FN: " (get-iter-function-name fn-name))
           (if (and (not (equal "(" (get-last-code)))
                    (not omit-comma))
               (add-code ","))
           (if (is-function-map-p fn-name)
               (progn
                 (setf fn-name (get-iter-function-type
                                 (get-function-value fn-name)))
                 (add-code (format nil "~a_~a"
                                   (get-iter-function-name
                                    (get-function-value fn-name))
                                   fn-type))))
           (if (is-iter-function-p fn-name)
               (add-code (format nil "~a_~a"
                                 (get-iter-function-name
                                  (car expr-list))
                                 fn-type))
               (add-code (get-iter-function-name (car expr-list))))
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list max))
           (return-from parse-arguments expr-list)))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-arguments: VARIABLE not defined: "
              (get-iter-variable-name  (car expr-list))" block " *block*
              " hash " (hash-table-keys *variable-type*))
         (error-variable-not-defined expr-list (car expr-list))))
  expr-list)

(defun parse-call (expr-list)
  (dbg "parse-call >" (car expr-list) "<")
  (cond ((equal ")" (car expr-list))
         (return-from parse-call (cdr expr-list)))
        ((equal "," (car expr-list))
         (error-syntax-error expr-list))
        ((or (equal "set" (car expr-list)) (equal "::" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list)))
               (omit-comma nil))
           ;; set following arguments-type this type
           (setf *current-type-definition* type)
           ;; replace elt if exist
           (if (or (equal (elt expr-list 4) "elt")
                   (equal (elt expr-list 4) "#"))
               (setf (elt expr-list 4) "pelt"))
           (if (or (equal (caddr expr-list) "elt")
                   (equal (caddr expr-list) "#"))
               (setf (caddr expr-list) "pelt"))
           ;; disptach
           (if (or (is-iter-variable-p (cadr expr-list))
                   (is-iter-composition-type-p (cdr expr-list)))
               (progn
                 (add-code (format nil "set_pointer_~a" type))
                 (add-code "(")
                 (if (not (equal "ixx" type))
                     (add-code "&"))
                 (setf omit-comma t))
               (progn

                 (if (or (search "elt" (caddr expr-list))
                         (search "#" (caddr expr-list)))
                     (progn
                       (add-code (format nil "set_pointer_~a" type))
                       (add-code "("))
                     (progn
                       (add-code (format nil "set_~a" type))
                       (add-code "(")))))
           (dbg "parse-call: set Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2 omit-comma))))
        ((or (equal "elt" (car expr-list)) (equal "#" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list)))
               (omit-comma nil))
           (add-code (format nil "elt_~a"
                             (regex-replace "pointer" type "array")))
           (add-code "(")
           (dbg "parse-call: elt Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list)
                                            (1- (count-elements expr-list))
                                            omit-comma))))
        ((equal "pelt" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list)))
               (omit-comma nil))
           (add-code (format nil "pelt_~a"
                             (regex-replace "pointer" type "array")))
           (add-code "(")
           (dbg "parse-call: pelt Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list)
                                            (1- (count-elements expr-list))
                                            omit-comma))))
         ((equal "prnfmt" (car expr-list))
          (add-code "printf")
          (add-code "(")
          (dbg "parse-call: prnfmt Next arg " (cadr expr-list))
          (setf expr-list (cdr expr-list))
          (setf expr-list (parse-arguments expr-list *infinite-arguments*)))
        ((equal "prnl" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (dbg "parse-call: prnl next " (caddr expr-list))
           (if (search "ixx" type)
               (progn
                 (add-code "prnl_ixx")
                 (add-code "(")))
           (if (and (search "array" type) (not (search "ixx" type)))
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list))))))
           (if (and (not (search "array" type)) (not (search "ixx" type)))
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prnl Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prn" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (dbg "parse-call: prn next " (caddr expr-list))
           (if (search "ixx" type)
               (progn
                 (add-code "prn_ixx")
                 (add-code "(")))
           (if (and (search "array" type) (not (search "ixx" type)))
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list))))))
           (if (and (not (search "array" type)) (not (search "ixx" type)))
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prn Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prnstr" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "print_str_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "of" (car expr-list))
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-expression expr-list t))
         (add-code ".")
         (add-code (car expr-list))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "let" (car expr-list))
         (inf "Compile let in block " *block*)
         (dbg "parse-call: LET INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-let (cdr expr-list))))
        ((or (equal "for" (car expr-list)) (equal "∑" (car expr-list)))
         (inf "Compile for in block " *block*)          
         (dbg "parse-call: FOR INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-for (cdr expr-list))))
        ((equal "defn" (car expr-list))
         (setf *target* 'implementation)
         (dbg "parse-call: DEFN INC BLOCK " (car expr-list))
         (inf "Compile function '" (cadr expr-list) "'")
         (setf expr-list (parse-def-function (cdr expr-list)))
         (setf *target* 'code))
        ((equal "compose" (car expr-list))
         (setf *target* 'implementation)
         (dbg "parse-call: COMPOSE INC BLOCK " (car expr-list))
         (setf expr-list (parse-compose (cdr expr-list)))
         (setf *target* 'code))
        ((equal "return" (car expr-list))
         (add-code "return")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "while" (car expr-list))
         (add-code "while")
         (add-code "(")
         (dbg "parse-call: WHILE INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-while (cdr expr-list))))
        ((equal "if" (car expr-list))
         (add-code "if")
         (add-code "(")
         (dbg "parse-call: IF INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-if (cdr expr-list))))
        ((or (equal "mod" (car expr-list))
             (equal "%" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "mod_~a" type))
           (add-code "(")
           (dbg "parse-call: MOD block " *block* " PARENS " *paranteses*)
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "<" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not *current-type-definition*)
               (setf *current-type-definition* type))
           (add-code (format nil "lt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "<=" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not *current-type-definition*)
               (setf *current-type-definition* type))
           (add-code (format nil "leqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cddr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal ">" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not *current-type-definition*)
               (setf *current-type-definition* type))
           (add-code (format nil "gt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal ">=" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not *current-type-definition*)
               (setf *current-type-definition* type))
           (add-code (format nil "geqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "!=" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not *current-type-definition*)
               (setf *current-type-definition* type))
           (add-code (format nil "neq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "==" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not *current-type-definition*)
               (setf *current-type-definition* type))
           (add-code (format nil "eq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "badd" (car expr-list))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-bigint-operation expr-list "badd"))
         (return-from parse-call expr-list))
        ((equal "bsub" (car expr-list))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-bigint-operation expr-list "bsub"))
         (return-from parse-call expr-list))
        ((equal "bmul" (car expr-list))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-bigint-operation expr-list "bmul"))
         (return-from parse-call expr-list))
        ((equal "bdiv" (car expr-list))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-bigint-operation expr-list "bdiv"))
         (return-from parse-call expr-list))
        ((equal "bsqrt" (car expr-list))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-bigint-operation expr-list "bsqrt"))
         (return-from parse-call expr-list))
        ((equal "bpower" (car expr-list))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-bigint-operation expr-list "bpower"))
         (return-from parse-call expr-list))
        ((or (equal "add" (car expr-list)) (equal "+" (car expr-list)))
         (setf expr-list (parse-calculation expr-list "add" "+"))
         (return-from parse-call expr-list))
        ((or (equal "sub" (car expr-list)) (equal "-" (car expr-list)))
         (setf expr-list (parse-calculation expr-list "sub" "-"))
         (return-from parse-call expr-list))
        ((or (equal "mul" (car expr-list)) (equal "*" (car expr-list)))
          (setf expr-list (parse-calculation expr-list "mul" "*"))
          (return-from parse-call expr-list))
        ((or (equal "div" (car expr-list)) (equal "/" (car expr-list)))
         (setf expr-list (parse-calculation expr-list "div" "/"))
         (return-from parse-call expr-list))
        ((or (equal "sqrt" (car expr-list)) (equal "√" (car expr-list)))
         (setf expr-list (parse-calculation expr-list "sqrt" "sqrt"))
         (return-from parse-call expr-list))
        ((or (equal "power" (car expr-list)) (equal "^" (car expr-list)))
         (setf expr-list (parse-calculation expr-list "power" "pow"))
         (return-from parse-call expr-list))
        ((equal "fpower" (car expr-list))
           (add-code (format nil "pow"))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list))
        ((equal "fabs" (car expr-list))
           (add-code (format nil "fabs_f64"))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list))
        ((or (equal "or" (car expr-list)) (equal "||" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "or_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "and" (car expr-list)) (equal "&&" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "and_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "not" (car expr-list)) (equal "!" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (equal "ixx" type)
               (add-code "not_ixx")
               (add-code (format nil "not_~a" type)))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "atan" (car expr-list))
         (parse-math expr-list "atan"))
        ((equal "atan2" (car expr-list))
         (parse-math expr-list "atan2" 2))
        ((equal "acos" (car expr-list))
         (parse-math expr-list "acos"))
        ((equal "asin" (car expr-list))
         (parse-math expr-list "asin"))
        ((equal "asin2" (car expr-list))
         (parse-math expr-list "atan2"))
        ((equal "cos" (car expr-list))
         (parse-math expr-list "cos"))
        ((equal "cosh" (car expr-list))
         (parse-math expr-list "cosh"))
        ((equal "sin" (car expr-list))
         (parse-math expr-list "sin"))
        ((equal "sinh" (car expr-list))
         (parse-math expr-list "sinh"))
        ((equal "tanh" (car expr-list))
         (parse-math expr-list "tanh"))
        ((equal "exp" (car expr-list))
         (parse-math expr-list "exp"))
        ((equal "log" (car expr-list))
         (parse-math expr-list "log"))
        ((equal "log10" (car expr-list))
         (parse-math expr-list "log10"))
        ((equal "floor" (car expr-list))
         (parse-math expr-list "floor"))
        ((equal "ceil" (car expr-list))
         (parse-math expr-list "ceil"))
        ((equal "round" (car expr-list))
         (parse-math expr-list "round"))
        ((equal "fmod" (car expr-list))
         (parse-math expr-list "fmod" 2))
        ((equal "open" (car expr-list))
         (parse-map expr-list "open" 2))
        ((equal "read-line" (car expr-list))
         (parse-map expr-list "read_line" 1))
        ((equal "write-line" (car expr-list))
         (parse-map expr-list "write_line" 2))
        ((equal "read-binary" (car expr-list))
         (parse-map expr-list "read_binary" 4))
        ((equal "write-binary" (car expr-list))
         (parse-map expr-list "write_binary" 4))
        ((equal "close" (car expr-list))
         (parse-map expr-list "close" 1))
        ((equal "string-to-i32" (car expr-list))
         (parse-map expr-list "atoi" 1))
        ((equal "string-to-f32" (car expr-list))
         (parse-map expr-list "atof" 1))
        ((equal "trunc" (car expr-list))
         (parse-map expr-list "trunc" 1))
        ((equal "max" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "max_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "min" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "min_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "module" (car expr-list))
         (setf expr-list (parse-module (cdr expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "len" (car expr-list)) (equal "@" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (or (search "array" type)
                   (search "list" type)
                   (search "pointer" type))
               (add-code (format nil "length_~a" type))
               (if (search "string" type)
                   (add-code "sizeof")
                   (error-type-not-supported expr-list type)))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "equal" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (add-code (format nil "eq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "map" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (add-code (format nil "map_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "mapn" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (add-code (format nil "mapn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "reduce" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (add-code (format nil "reduce_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "push" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (add-code (format nil "push_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 2 t))
           (return-from parse-call expr-list)))
        ((equal "car" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (add-code (format nil "car_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdr" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (add-code (format nil "cdr_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdrn" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (add-code (format nil "cdrn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "rev" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (add-code (format nil "reverse_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "append" (car expr-list))
         (let ((typea (get-next-token-type-string (cdr expr-list)))
               (typeb (get-next-token-type-string (cddr expr-list))))
           (if (and (not (search "list" typea))
                    (not (search "array" typea))
                    (not (search "pointer" typea)))
               (error-type-not-supported expr-list typea))
           (if (search "array" typeb)
               (add-code (format nil "append_array_~a" typeb)))
           (if (search "list" typeb)
               (add-code (format nil "append_list_~a" typeb)))
           (if (search "pointer" typeb)
               (add-code (format nil "append_pointer_~a" typeb)))
           (if (and (not (search "list" typeb))
                    (not (search "array" typeb))
                    (not (search "pointer" typeb)))
               (add-code (format nil "append_~a" typea)))
           (add-code "(")
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list 2))
           (return-from parse-call expr-list)))
        ((equal "size" (car expr-list))
         (add-code "sizeof")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "remove" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (add-code (format nil "remove_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "pop" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (add-code (format nil "pop_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 1 t))
           (return-from parse-call expr-list)))
        ((equal "break" (car expr-list))
         (add-code "break")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "continue" (car expr-list))
         (add-code "continue")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (add-code "destroy_ptr")
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "bool" (car expr-list))
         (parse-type-cast expr-list "bool" "bool"))
        ((equal "b8" (car expr-list))
         (parse-type-cast expr-list "b8" "b8"))
        ((equal "c8" (car expr-list))
         (parse-type-cast expr-list "c8" "c8"))
        ((equal "i16" (car expr-list))
         (parse-type-cast expr-list "i16" "i16"))
        ((equal "i32" (car expr-list))
         (parse-type-cast expr-list "i32" "i32"))
        ((equal "i64" (car expr-list))
         (parse-type-cast expr-list "i64" "i64"))
        ((equal "ui16" (car expr-list))
         (parse-type-cast expr-list "ui16" "ui16"))
        ((equal "ui32" (car expr-list))
         (parse-type-cast expr-list "ui32" "ui32"))
        ((equal "ui64" (car expr-list))
         (parse-type-cast expr-list "ui64" "ui64"))
        ((equal "f32" (car expr-list))
         (parse-type-cast expr-list "f32" "f32"))
        ((equal "f64" (car expr-list))
         (parse-type-cast expr-list "f64" "f64"))
        ((equal "f80" (car expr-list))
         (parse-type-cast expr-list "f80" "f80"))
        ((equal "ixx" (car expr-list))
         (parse-type-cast expr-list "ixx" "ixx_cast"))
        ((equal "string" (car expr-list))
         (parse-type-cast expr-list "string" "string"))
        ((equal "cstring" (car expr-list))
         (parse-type-cast expr-list "cstring" "cstring"))
        ((equal "file" (car expr-list))
         (parse-type-cast expr-list "file" "file"))
        ((equal "bool>" (car expr-list))
         (parse-type-cast expr-list "bool>" "bool*"))
        ((equal "b8>" (car expr-list))
         (parse-type-cast expr-list "b8>" "b8*"))
        ((equal "c8>" (car expr-list))
         (parse-type-cast expr-list "c8>" "c8*"))
        ((equal "i16>" (car expr-list))
         (parse-type-cast expr-list "i16>" "i16*"))
        ((equal "i32>" (car expr-list))
         (parse-type-cast expr-list "i32>" "i32*"))
        ((equal "i64>" (car expr-list))
         (parse-type-cast expr-list "i64>" "i64*"))
        ((equal "ui16>" (car expr-list))
         (parse-type-cast expr-list "ui16>" "ui16*"))
        ((equal "ui32>" (car expr-list))
         (parse-type-cast expr-list "ui32>" "ui32*"))
        ((equal "ui64>" (car expr-list))
         (parse-type-cast expr-list "ui64>" "ui64*"))
        ((equal "f32>" (car expr-list))
         (parse-type-cast expr-list "f32>" "f32*"))
        ((equal "f64>" (car expr-list))
         (parse-type-cast expr-list "f64>" "f64*"))
        ((equal "f80>" (car expr-list))
         (parse-type-cast expr-list "f80>" "f80*"))
        ((equal "ixx>>" (car expr-list))
         (parse-type-cast expr-list "ixx>" "ixx*"))
        ((equal "string>" (car expr-list))
         (parse-type-cast expr-list "string>" "string*"))
        ((equal "cstring>" (car expr-list))
         (parse-type-cast expr-list "cstring>" "cstring*"))
        ((equal "file>" (car expr-list))
         (parse-type-cast expr-list "file>" "file*"))
        ((equal "bool>>" (car expr-list))
         (parse-type-cast expr-list "bool>>" "bool**"))
        ((equal "b8>>" (car expr-list))
         (parse-type-cast expr-list "b8>>" "b8**"))
        ((equal "c8>>" (car expr-list))
         (parse-type-cast expr-list "c8>>" "c8**"))
        ((equal "i16>>" (car expr-list))
         (parse-type-cast expr-list "i16>>" "i16**"))
        ((equal "i32>>" (car expr-list))
         (parse-type-cast expr-list "i32>>" "i32**"))
        ((equal "i64>>" (car expr-list))
         (parse-type-cast expr-list "i64>>" "i64**"))
        ((equal "ui16>>" (car expr-list))
         (parse-type-cast expr-list "ui16>>" "ui16**"))
        ((equal "ui32>>" (car expr-list))
         (parse-type-cast expr-list "ui32>>" "ui32**"))
        ((equal "ui64>>" (car expr-list))
         (parse-type-cast expr-list "ui64>>" "ui64**"))
        ((equal "f32>>" (car expr-list))
         (parse-type-cast expr-list "f32>>" "f32**"))
        ((equal "f64>>" (car expr-list))
         (parse-type-cast expr-list "f64>>" "f64**"))
        ((equal "f80>>" (car expr-list))
         (parse-type-cast expr-list "f80>>" "f80**"))
        ((equal "ixx>>" (car expr-list))
         (parse-type-cast expr-list "ixx>>" "ixx**"))
        ((equal "string>>" (car expr-list))
         (parse-type-cast expr-list "string>>" "string**"))
        ((equal "cstring>>" (car expr-list))
         (parse-type-cast expr-list "cstring>>" "cstring**"))
        ((equal "file>>" (car expr-list))
         (parse-type-cast expr-list "file>>" "file**"))
        ((or (equal "?" (car expr-list)) (equal "deref" (car expr-list)))
         (add-code (format nil "("))
         (add-code (format nil "*"))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1 t))
         (return-from parse-call expr-list))
        ((or (equal "&" (car expr-list)) (equal "ref" (car expr-list)))
         (add-code (format nil "("))
         (add-code (format nil "&"))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1 t))
         (return-from parse-call expr-list))
        ((equal "del" (car expr-list))
         (add-code (format nil "delete_ptr"))
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (add-code (format nil "destroy_ptr"))
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 0))
         (return-from parse-call expr-list))
        ((equal "new" (car expr-list))
         (if (not (search ">" *current-type-definition*))
             (error-type-not-supported expr-list *current-type-definition*))
         (let ((type (regex-replace ">" *current-type-definition* "")))
           (add-code (format nil "new_~a" type))
           (add-code "(")
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list 1))
           (return-from parse-call expr-list)))
        ((equal "new_bool" (car expr-list))
         (add-code "new_bool")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_c8" (car expr-list))
         (add-code "new_c8")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_b8" (car expr-list))
         (add-code "new_b8")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_i16" (car expr-list))
         (add-code "new_i16")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_i32" (car expr-list))
         (add-code "new_i32")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_i64" (car expr-list))
         (add-code "new_i64")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_ui16" (car expr-list))
         (add-code "new_ui16")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_ui32" (car expr-list))
         (add-code "new_ui32")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_ui64" (car expr-list))
         (add-code "new_ui64")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_f32" (car expr-list))
         (add-code "new_f32")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_f64" (car expr-list))
         (add-code "new_f64")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_f80" (car expr-list))
         (add-code "new_f80")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "defp" (car expr-list))
         (let ((tmp-target *target*)
               (def (split ":" (cadr expr-list))))
           (if (and (not *current-function*)
                    (equal (cadr def) "ixx"))
               (progn
                 (set-target 'implementation)
                 (add-code "static")
                 (add-code " ")
                 (add-code "ixx")
                 (add-code " ")
                 (add-code (get-variable-name (car def)))
                 (add-code (format nil ";~%"))
                 (set-target 'code)
                 ;; move to variable/type pair
                 (setf expr-list (cdr expr-list))
                 ;; switch target - clear buffer
                 (set-target 'main-buffer)
                 ;; move to value)
                 (setf expr-list (cdr expr-list))
                 ;; add initialisation
                 (add-bigint-init (car def) (car expr-list))
                 (set-target tmp-target)
                 ;; move to end
                 (setf expr-list (cdr expr-list))
                 (setf (gethash (get-variable-name (car def)) *variable-type*) "ixx")
                 (return-from parse-call expr-list))
               (progn
                 (set-target 'implementation)
                 (add-code "static")
                 (add-code " ")
                 (setf expr-list (cdr expr-list))
                 (setf expr-list (parse-variable expr-list))
                 (set-target 'code)
                 (return-from parse-call expr-list)))))
        ((equal "defv" (car expr-list))
         (setf *target* 'implementation)
         (add-code "volatile")
         (add-code " ")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-variable expr-list))
         (setf *target* 'code)
         (return-from parse-call expr-list))
        ((equal "defr" (car expr-list))
         (if (not *current-function*)
             (error-not-outside-function expr-list))
         (add-code "register")
         (add-code " ")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-variable expr-list))
         (return-from parse-call expr-list))
        ((or (equal "shitfl" (car expr-list))
             (equal "<<" (car expr-list)))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-expression expr-list t))
         (add-code "<<")
         (setf expr-list (parse-expression expr-list t))
         (return-from parse-call expr-list))
        ((or (equal "shitfr" (car expr-list))
          (equal ">>" (car expr-list)))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-expression expr-list t))
         (add-code ">>")
         (setf expr-list (parse-expression expr-list t))
         (return-from parse-call expr-list))
        ((is-iter-function-p (car expr-list))
         (let* ((fn-name (car expr-list))
                (fn-type (get-next-token-type-string (cdr expr-list))))
           (if (is-iter-function-p (cadr expr-list))
               (setf fn-type "fun"))
           (dbg "parse-call: FN: " (get-iter-function-name fn-name))
           (if (is-function-map-p fn-name)
               (add-code (get-iter-function-name fn-name))
               (add-code (format nil "~a_~a"
                                 (get-iter-function-name fn-name) fn-type)))
           (add-code "(")
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list *infinite-arguments*))))
        ((is-iter-variable-p (car expr-list))
         (dbg "parse-call: FN emit: " (get-function-name (car expr-list)))
         (add-code "(")
         (add-code "*")
         (add-code (get-function-name (car expr-list)))
         (add-code ")")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list)
                                          *infinite-arguments*
                                          t)))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-call: FN not defined: " (get-iter-function-name (car expr-list)))
         (error-function-not-defined expr-list))
        ((equal "(" (car expr-list))
         (progn
           (dbg "parse-call: CALL OPEN ( block " *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t)))))
   expr-list)

(defun is-variable-split-name-p (expression)
  (let ((split (split ">>" expression)))
    (remove-if-not
     #'(lambda (x)
         (equal x (get-iter-variable-name (car split))))
     (hash-table-keys *variable-type*))))

(defun get-bigint (expr)
  (if expr
      (if (> (length expr) 1)
          (let ((number (parse-integer
                         (subseq expr 1 (length expr)) :junk-allowed t)))
            (if (and (numberp number) (equal "B" (subseq expr 0 1)))
                (return-from get-bigint number)))
        nil)))

(defun is-bigint-p (expr)
  (get-bigint expr))

(defun parse-expression (expr-list &optional (omit-semicolon nil))
  (if expr-list
      (progn
        (dbg "parse-expression: >" (car expr-list) "<")
        (if (not expr-list)
            (return-from parse-expression expr-list))
        (if (equal "," (car expr-list))
            (error-syntax-error expr-list))        
        (if (equal "EOF" (car expr-list))
            (add-code "EOF"))
        (if (equal "\"" (car expr-list))
            (progn
              (dbg "parse-expression: STRING block " *block*)
              (add-code "\"")
              (setf expr-list (parse-cstr (cdr expr-list)))
              (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: STRING END ")
              (return-from parse-expression expr-list)))
        (if (and (equal ";" (car expr-list)) (equal "|" (cadr expr-list)))
            (progn
              (dbg "parse-expression: parse multiline comment")
              (setf expr-list (parse-multiline-comment (cddr expr-list)))
              (return-from parse-expression expr-list)))
        (if (equal ";" (car expr-list))
            (progn
              (dbg "parse-expression: parse singleiline comment")
              (setf expr-list (parse-single-line-comment expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "{" (car expr-list))
            (progn
              (dbg "parse-expression: parse null")
              (setf expr-list (parse-null expr-list))
                (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
            (return-from parse-expression expr-list)))
        (if (equal "[" (car expr-list))
            (progn
              (dbg "parse-expression: parse vector " (car expr-list))
              (add-code "{")
              (dbg "parse-expression: parse vector literal ")
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (equal "'" (car expr-list))
            (let ((type (get-next-token-type-string (cdddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-expression: parse list literal ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (is-bigint-p (car expr-list))
            (progn
              (setf expr-list (parse-bigint-number expr-list (get-bigint (car expr-list))))
              (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (numberp (parse-integer (car expr-list) :junk-allowed t))
            (progn
              (if (equal "ixx" *current-type-definition*)
                  (progn
                    (setf expr-list (parse-bigint-number expr-list (car expr-list))))
                  (progn
                    (dbg "parse-expression: NUM block " *block*
                         " number " (car expr-list))
                    (add-code (car expr-list))))
              (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
              (return-from parse-expression (cdr expr-list))))
        (if (or (is-variable-split-name-p (car expr-list))
                (is-iter-variable-p (car expr-list)))
            (let ((comp-name (build-dotted-type (car expr-list)))
                  (var-name (regex-replace ">>.*" (car expr-list) ""))
                  (tmp-target *target*)
                  (type (determine-type-of-symbol expr-list)))
              (dbg "parse-expression: VARIABLE "
                   (get-iter-variable-name var-name))
           (if (search ">>" (car expr-list))
               (add-code comp-name)
               (progn
                 (if (equal "ixx" type)
                     (progn
                       (if (equal type *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (not *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (is-fixed-math-type-p *current-type-definition*)
                           (progn
                             (add-code "mpz_get_si")
                             (add-code "(")
                             (add-code (get-iter-variable-name var-name))
                             (add-code ")")))))
                 (if (is-fixed-math-type-p type)
                     (progn
                       (if (is-fixed-math-type-p *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (not *current-type-definition*)
                           (add-code (get-iter-variable-name var-name)))
                       (if (equal "ixx" *current-type-definition*)
                           (progn
                             (set-target 'definition-buffer)
                             (setf (gethash *paranteses* *definition_buffer*) '(""))
                             (add-bigint-declaration-with-var (fgensym) var-name)
                             (set-target tmp-target)
                             (insert-definition-buffer)))))))
              (if (not omit-semicolon)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: VAR END " var-name)
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (is-iter-function-p (car expr-list))
         (let* ((fn-name (car expr-list))
                (fn-type (get-iter-function-args fn-name)))
           (dbg "parse-expression: FN: " (get-iter-function-name fn-name))
           (if (is-function-map-p fn-name)
               (progn
                 (add-code (format nil "~a_~a"
                                   (get-iter-function-name
                                    (get-function-value fn-name))
                                   fn-type))))
           (if (is-iter-function-p fn-name)
               (add-code (format nil "~a_~a"
                                 (get-iter-function-name
                                  (car expr-list))
                                 fn-type))
               (add-code (get-iter-function-name (car expr-list))))
           (if (not omit-semicolon)
               (add-code (format nil ";~%")))
           (setf expr-list (cdr expr-list))
           (return-from parse-expression expr-list)))
        (if (not (or (equal "," (car expr-list))
                     (equal "(" (car expr-list))
                     (equal ")" (car expr-list))
                     (equal "[" (car expr-list))
                     (equal "]" (car expr-list))
                     (equal "\"" (car expr-list))
                     (equal ";|" (car expr-list))
                     (equal "|;" (car expr-list))
                     (equal ";" (car expr-list))
                     (numberp (parse-integer (car expr-list) :junk-allowed t))))
            (progn
              (dbg "parse-expression: SYMBOL " (car expr-list))
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "(" (car expr-list))
            (let ((space nil)
                  (no-parens nil))
              
              ;; parse-open-parens
              (setf expr-list (parse-open-parens expr-list))
              (inc-parens)
              (dbg "parse-expression: OPEN parens "
                   *paranteses* " block " *block*)
              ;; omit-semicolon semicolon for blocks
              (if (or (equal "for" (car expr-list))
                      (equal "if" (car expr-list))
                      (equal "while" (car expr-list))
                      (equal "defn" (car expr-list))
                      (equal "defp" (car expr-list))
                      (equal "defv" (car expr-list))
                      (equal "defr" (car expr-list))
                      (equal "let" (car expr-list))
                      (equal "compose" (car expr-list))
                      (equal "module" (car expr-list))
                      (equal "break" (car expr-list))
                      (equal "continue" (car expr-list))
                      (equal "shiftl" (car expr-list))
                      (equal "shiftr" (car expr-list))
                      (equal ">>" (car expr-list))
                      (equal "<<" (car expr-list)))
                  (setf space t))
              (if (is-type-p (car expr-list))
                  (setf no-parens t))
              ;; parse-call
              (setf expr-list (parse-call expr-list))
              (dbg "parse-expression: CLOSE parens " *paranteses*
                   " block " *block*
                   " omit-semicolon " omit-semicolon)
              (if (car expr-list)
                  (setf expr-list (parse-close-parens expr-list)))
              ;; output parens?
              (if (and (not space)
                       (not no-parens)
                       (= *start-operation* -1))
                  (add-code ")"))
              (dec-parens)
              ;; output semicolon ?
              (if (and (not space) (not omit-semicolon))
                  (progn
                    (setf *current-type-definition* nil)
                    (add-code (format nil ";~%"))))
              ;; save pos
              (if (not omit-semicolon)
                  (set-insert-points))
              ;; exit
              (return-from parse-expression expr-list))))))

(defun parse (expression)
  "Parse expression."
  (dbg "parse: preprocess")
  (let ((expr-list (preprocess expression)))
    (dbg "parse: setup hashtables")
    (setup-data-structures)
    (dbg "parse: setup-signatures")
    (setup-signatures)
    (dbg "parse: parse-expressions")
    (loop while (> (length expr-list) 0) do
         (setf expr-list (parse-expression expr-list))))
  (emit-code-call))
