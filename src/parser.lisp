;;; -----------------------------------------------------
;;; next - parser file
;;; -----------------------------------------------------
;;; File:     src/parser.lisp
;;; Date:     09:29:15 of Wednesday, 8/14/2019 (GMT+1)
;;; Author:   Edward Puccini
;;; -----------------------------------------------------

(in-package :next)

(require 'parse-float)

(defvar *code_list* '(""))
(defvar *definition_list* '(""))
(defvar *implementation_list* '(""))
(defvar *target* 'code)
(defvar *paranteses* 0)
(defvar *variables* nil)
(defvar *functions* nil)
(defvar *signatures* nil)
(defvar *function-map* nil)
(defvar *current-function* nil)
(defvar *current-let-definition* nil)
(defvar *current-module* "")
(defvar *block* 0)
(defvar *generics-template* "")
(defvar *def-template* "")
(defvar *impl-template* "")
(defvar *is-main-defined* nil)
(defvar *infinite-arguments* 10000)

(defun load-templates ()
  (setf *def-template* (load-binary-data "../templates/code.h"))
  (setf *impl-template* (load-binary-data "../templates/code.c"))
  (setf *generics-template* (load-binary-data "../templates/generics.h")))

(defun is-main-defined-p ()
  *is-main-defined*)

(defun filter-expression (expression)
  (let* ((new-expr1 (regex-replace-all "-" expression "_"))
         (new-expr2 (regex-replace-all "\\√" new-expr1 "sqrt"))
         (new-expr3 (regex-replace-all "\\^" new-expr2 "power"))
         (new-expr4 (regex-replace-all "∑" new-expr3 "for"))
         (new-expr5 (regex-replace-all ">>" new-expr4 "__")))
    new-expr5))

(defun print-stack ()
  "Use swank to log a stack-trace."
  (let ((trace ""))
    (let* ((msg-lst (remove-if #'null
                               (swank-backend:call-with-debugging-environment
                                (lambda () (swank:backtrace 0 7)))))
           (stack-msg
            (progn
              (mapcar (lambda (msg)
                        (setf trace (concatenate 'string trace 
                                                   (format nil "~{~A ~}~%" msg))))
                      msg-lst) trace)))
      (print stack-msg))))

(defun error-msg (msg)
  (format t msg)
  (print-stack)
  (emit-code-call)
  (sb-ext:quit))

(defun error-parameter-max (cnt max)
  (error-msg (format nil "Error too many parameter to function (~a). Only ~a parameter expected!~%"
            cnt max)))

(defun error-operator-not-defined ()
  (error-msg "Error no operator defined!~%"))

(defun error-no-type-def ()
  (error-msg "Error no variable and type defined!~%"))

(defun error-function-not-defined ()
  (error-msg "Error function not defined!~%"))

(defun error-missing-expression ()
  (error-msg "Error missing expression!~%"))

(defun error-function-type-unkown (type)
  (error-msg (format nil "Error function type ~a unkown!~%" type)))

(defun error-syntax-error ()
  (error-msg "Error syntax error!~%"))

(defun error-missing-open-square-bracket ()
  (error-msg "Error missing square bracket!~%"))

(defun error-missing-open-parens ()
  (error-msg "Error missing open parens!~%"))

(defun error-missing-close-square-bracket ()
  (error-msg "Error missing square bracket!~%"))

(defun error-missing-close-parens ()
  (error-msg "Error missing close parens!~%"))

(defun error-variable-not-defined ()
  (error-msg "Error variable not defined!~%"))

(defun error-function-vector-malformed ()
  (error-msg "Error function vector malformed!~%"))

(defun error-let-vector-malformed ()
  (error-msg "Error let vector malformed!~%"))

(defun error-cant-infer-type ()
  (error-msg "Error cant determine type!~%"))

(defun error-only-lists-supported ()
  (error-msg "Error only lists supported!~%"))

(defun error-type-not-supported ()
  (error-msg "Error type not supported!~%"))

(defun upto-string (expression lower)
  (let ((str ""))
    (loop for x from lower to (1- (length expression)) do
         (if (equal #\" (elt expression x))
             (return-from upto-string str))
         (if (not (equal #\" (elt expression x)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-symbol (expression lower)
  (let ((str "")
        (stack '()))
    (loop for x from lower to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((equal #\" obj)
                  (return-from upto-symbol stack))
                 ((equal #\$ obj)
                  (push "$" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\; obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\( obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\) obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\[ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\] obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\% obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\& obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\, obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Newline obj)
                  (push "\n" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Return obj)
                  (push "\n" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Linefeed obj)
                  (push "\n" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Space obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 (t
                  (setf str (format nil "~a~a" str obj))))))
    (push str stack)))

(defun stack-length (stack)
  (let ((l 0))
    (mapcar #'(lambda (x) (setf l (+ l (length x))))
            stack)
    l))

(defun preprocess (expr)
  (let ((stack '())
        (expression (regex-replace-all "->" expr "$")))
    (loop for x from 0 to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((or (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\% obj)
                      (equal #\& obj)
                      (equal #\, obj)
                      (equal #\; obj)
                      (equal #\< obj)
                      (equal #\> obj)
                      (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\{ obj)
                      (equal #\} obj)
                      (equal #\# obj))
                  (push (format nil "~a" obj) stack))
                 ((equal #\∑ obj)
                  (push "∑" stack))
                 ((equal #\, obj)
                  (push "," stack))
                 ((equal #\Space obj)
                  (format nil " "))
                 ((equal #\Newline obj)
                  (push "\n" stack))
                 ((equal #\Return obj)
                  (push "\n" stack))
                 ((equal #\Linefeed obj)
                  (push "\n" stack))
                 ((equal #\Tab obj)
                  (format nil " "))
                 ((equal #\" obj)
                  (let ((str (upto-string expression (1+ x))))
                    (setf x (+ x 1 (length str)))
                    (push "\"" stack)
                    (push str stack)
                    (push "\"" stack)))
                 (t
                  (let ((inner-stack (upto-symbol expression x)))
                    (setf stack (append (reverse inner-stack) stack))
                    (setf x (+ x (1- (stack-length inner-stack)))))))))
    (reverse stack)))

(defun emit-code-call ()
  (let ((code "")
        (definition "")
        (implementation "")
        (pointers ""))
    (if *implementation_list*
        (format t "~%~{~a~}~%" *implementation_list*))
    (if *code_list*
        (format t "~%~{~a~}~%" *code_list*))
    (if *implementation_list*
        (setf implementation
              (format nil "~%~{~a~}~%" *implementation_list*)))
    (if *code_list*
        (progn
          (if (not (is-main-defined-p))
              (setf code (format nil "i32 main () ~%{~%~%~{~a~}~%" *code_list*))
              (setf code (format nil "~%~%~{~a~}~%" *code_list*)))))
    (if (not (is-main-defined-p))
        (setf code (format nil "~a~%destroy_ptr(pointer_list);~%return 0;~%}" code)))
    (values code definition implementation)))

(defun get-current-function ()
  (gethash *paranteses* *current-function*))

(defun get-last-function ()
  (gethash (1- *paranteses*) *current-function*))

(defun store-current-function (fun)
  (setf (gethash *paranteses* *current-function*) fun))

(defun get-variable-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-function-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-iter-variable-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *variables*)
              (progn
                (return-from get-iter-variable-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-variable-name-x name cnt)))))))

(defun get-iter-variable-name (name)
  (get-iter-variable-name-x name *block*))

(defun get-iter-function-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *functions*)
              (progn
                (return-from get-iter-function-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-function-name-x name cnt)))))))

(defun get-iter-function-name (name)
  (get-iter-function-name-x name *block*))

(defun set-signature (name signature)
  (setf (gethash name *signatures*) signature))

(defun append-signature (name signature)
  (setf (gethash name *signatures*)
        (append (gethash name *signatures*) (list signature))))

(defun inc-parens ()
  (setq *paranteses* (1+ *paranteses*)))

(defun dec-parens ()
  (setq *paranteses* (1- *paranteses*)))

(defun inc-block ()
  (setq *block* (+ 1 *block*)))

(defun dec-block ()
  (zero-hash-variables)
  (setq *block* (- *block* 1)))

(defun zero-parens ()
  (setq *paranteses* 0))

(defun zero-block ()
  (setq *block* 0))

(defun zero-hash-variables ()
  (dolist (var (hash-table-keys *variables*))
       (remhash (get-variable-name var) *variables*)))

(defun add-code (expression)
  ;(setf expression (filter-expression expression))
  (if expression
      (cond ((equal *target* 'code)
             (setf *code_list* (append *code_list* (list expression))))
            ((equal *target* 'implementation)
             (setf *implementation_list* (append *implementation_list*
                                                 (list expression))))
            ((equal *target* 'definition)
             (setf *definition_list* (append *definition_list*
                                             (list expression)))))))

(defun get-last-code ()
  (cond ((equal *target* 'code)
         (car (reverse *code_list*)))
        ((equal *target* 'implementation)
         (car (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (car (reverse *definition_list*)))))

(defun get-previous-code ()
  (cond ((equal *target* 'code)
         (cadr (reverse *code_list*)))
        ((equal *target* 'implementation)
         (cadr (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (cadr (reverse *definition_list*)))))

(defun get-function-value (fn-name)
  (gethash fn-name *function-map*))

(defun set-function-map (fn-name value)
  (setf (gethash fn-name *function-map*) value))

(defun is-function-map-p (fn-name)
  (remove-if-not #'(lambda (fn) (equal fn fn-name))
                 (hash-table-keys *function-map*)))

(defun register-function (name content)
  (set-function-map name content)
  (setf (gethash (get-function-name name) *functions*) 'function)
  (dbg "register-function: Register function >" name
       "< var >" content "<"))

(defun type-of-number-string (numstr)
  (cond ((and
          (typep (parse-integer numstr :junk-allowed t) 'integer)
          (not (find #\. numstr))) 'integer)
        ((search "d0" numstr)
         'double-float)
        ((typep (parse-float numstr
                             :junk-allowed t
                             :type 'single-float) 'single-float)
         'single-float)
        ((typep numstr 'string)
         'string)))

(defun inspect-function-type (expr-list)
  (dbg "inspect-function-type: next function: " (cadr expr-list))
  (if (equal "(" (car expr-list))
      (cond ((remove-if-not
              #'(lambda (x)
                  (equal x (get-iter-function-name (cadr expr-list))))
              (hash-table-keys *functions*))
             (return-from inspect-function-type
               (gethash
                (get-iter-function-name (cadr expr-list))
                *functions*))))
      (return-from inspect-function-type
        (gethash
         (get-iter-function-name (car expr-list))
         *functions*))))

(defun set-function-type (fn-name type)
  (setf (gethash (get-function-name fn-name) *functions*) type))

(defun parse-argument (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-argument: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           (dbg "parse-argument: OPEN ARG")
           (if (find #\: (car expr-list))
               (add-code ","))
           (setf expr-list (parse-argument expr-list)))))
  expr-list)

(defun parse-function-type (expr-list &optional (signature nil))
  (let ((fn-name (car (split ":" (car expr-list))))
        (type (cadr (split ":" (car expr-list)))))
    (cond ((equal "i16" type)
           (add-code "i16")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer)
           (setf expr-list (cdr expr-list)))
          ((equal "i32" type)
           (add-code "i32")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer)
           (setf expr-list (cdr expr-list)))
          ((equal "i64" type)
           (add-code "i64")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint)
           (setf expr-list (cdr expr-list)))
          ((equal "f32" type)
           (add-code "f32")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float)
           (setf expr-list (cdr expr-list)))
          ((equal "f64" type)
           (add-code "f64")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float)
           (setf expr-list (cdr expr-list)))
          ((equal "b8" type)
           (add-code "char")
           (setf (gethash (get-function-name fn-name) *functions*) 'char)
           (setf expr-list (cdr expr-list)))
          ((equal "c8" type)
           (add-code "char")
           (setf (gethash (get-function-name fn-name) *functions*) 'char)
           (setf expr-list (cdr expr-list)))
          ((equal "bool" type)
           (add-code "bool")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean)
           (setf expr-list (cdr expr-list)))
          
          ((equal "bool#" type)
           (add-code "bool")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-array)
           (setf expr-list (cdr expr-list)))
          ((equal "b8#" type)
           (add-code "b8")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf expr-list (cdr expr-list)))
          ((equal "c8#" type)
           (add-code "c8")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf expr-list (cdr expr-list)))
          ((equal "i16#" type)
           (add-code "i16")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-array)
           (setf expr-list (cdr expr-list)))
          ((equal "i32#" type)
           (add-code "i32")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-array)
           (setf expr-list (cdr expr-list)))
          ((equal "i64#" type)
           (add-code "i64")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-array)
           (setf expr-list (cdr expr-list)))
          ((equal "f32#" type)
           (add-code "f32")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-array)
           (setf expr-list (cdr expr-list)))
          ((equal "f64#" type)
           (add-code "f64")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-array)
           (setf expr-list (cdr expr-list)))
          
          ((equal "bool>" type)
           (add-code "bool*")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "b8>" type)
           (add-code "b8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "c8>" type)
           (add-code "c8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "i16>" type)
           (add-code "i16*")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "i32>" type)
           (add-code "i32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "i64>" type)
           (add-code "i64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "f32>" type)
           (add-code "f32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-pointer)
           (setf expr-list (cdr expr-list)))
          ((equal "f64>" type)
           (add-code "f64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-pointer)
           (setf expr-list (cdr expr-list)))

          ((equal "bool'" type)
           (add-code "node_bool*")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-list)
           (setf expr-list (cdr expr-list)))
          ((equal "b8'" type)
           (add-code "node_b8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-list)
           (setf expr-list (cdr expr-list)))
          ((equal "c8'" type)
           (add-code "node_c8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-list)
           (setf expr-list (cdr expr-list)))
          ((equal "i16'" type)
           (add-code "node_i16*")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-list)
           (setf expr-list (cdr expr-list)))
          ((equal "i32'" type)
           (add-code "node_i32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-list)
           (setf expr-list (cdr expr-list)))
          ((equal "i64'" type)
           (add-code "node_i64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-list)
           (setf expr-list (cdr expr-list)))
          ((equal "f32'" type)
           (add-code "node_f32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-list)
           (setf expr-list (cdr expr-list)))
          ((equal "f64'" type)
           (add-code "node_f64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-list)
           (setf expr-list (cdr expr-list)))

          ((equal "string" type)
           (add-code "const char*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf expr-list (cdr expr-list)))
          ((equal "void" type)
           (add-code "void")
           (setf (gethash (get-function-name fn-name) *functions*) 'void)
           (setf expr-list (cdr expr-list)))
          ((equal "[" type)
           (add-code "void")
           (setf (gethash (get-function-name fn-name) *functions*) 'void))
          ((equal "fun" type)
           (if signature
               (progn
                 (dbg "parse-function-type: signature " signature)
                 (dbg "parse-function-type: signature "
                      (format nil "~a (*~a)(~a)"
                              (car (reverse signature))
                              (get-function-name fn-name)
                              (cdr (reverse signature))))
                 (add-code (format nil "~a (*~a)(~a)"
                                   (car (reverse signature))
                                   (get-function-name fn-name)
                                   (cadr (reverse signature))))
                 (setf (gethash (get-function-name fn-name) *functions*) 'function))
               (progn
                 (add-code "single_fn_f32")
                 (setf (gethash (get-function-name fn-name) *functions*) 'function)))
           (setf expr-list (cdr expr-list)))
          (t
           (error-function-type-unkown type))))
   
  expr-list)

(defun parse-function-name-and-type (expr-list)
  (cond ((stringp (car expr-list))
         (let* ((def (split ":" (car expr-list)))
                (fn-name (car def)))
           (dbg "parse-function-name-and-type: Functionname " fn-name)
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-function-name-and-type: signature "
                      (gethash (car def) *signatures*))
                 (setf expr-list (parse-function-type expr-list
                                      (gethash (car def) *signatures*))))
               (progn
                 (setf expr-list (parse-function-type expr-list))))
           (add-code " ")
           (cond ((equal fn-name "main")
                  (setf *is-main-defined* t)
                  (add-code fn-name))
                 (t
                  (add-code (get-function-name fn-name)))))))
  (dbg "parse-function-name-and-type: EXIT Rest. ")
  expr-list)

(defun parse-variable-type (var-name type-name &optional (signature nil))
  (cond ((equal "i16" type-name)
         (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i32" type-name)
         (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i64" type-name)
         (add-code "long")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint))
        ((equal "f32" type-name)
         (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float))
        ((equal "f64" type-name)
         (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float))
        ((equal "bool" type-name)
         (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean))
        ((equal "b8" type-name)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "c8" type-name)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "string" type-name)
         (add-code "const char*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'string))
        
        ((equal "bool#" type-name)
         (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-array))
        ((equal "b8#" type-name)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "c8#" type-name)
         (add-code "c8")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "i16#" type-name)
         (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-array))
        ((equal "i32#" type-name)
         (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-array))
        ((equal "i64#" type-name)
         (add-code "i64")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-array))
        ((equal "f32#" type-name)
         (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-array))
        ((equal "f64#" type-name)
         (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-array))
        
        ((equal "bool>" type-name)
         (add-code "bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-pointer))
        ((equal "b8>" type-name)
         (add-code "b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "c8>" type-name)
         (add-code "c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "i16>" type-name)
         (add-code "i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-pointer))
        ((equal "i32>" type-name)
         (add-code "i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-pointer))
        ((equal "i64>" type-name)
         (add-code "i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-pointer))
        ((equal "f32>" type-name)
         (add-code "f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-pointer))
        ((equal "f64>" type-name)
         (add-code "f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-pointer))

        ((equal "bool'" type-name)
         (add-code "node_bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-list))
        ((equal "b8'" type-name)
         (add-code "node_b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "c8'" type-name)
         (add-code "node_c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "i16'" type-name)
         (add-code "node_i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-list))
        ((equal "i32'" type-name)
         (add-code "node_i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-list))
        ((equal "i64'" type-name)
         (add-code "node_i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-list))
        ((equal "f32'" type-name)
         (add-code "node_f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-list))
        ((equal "f64'" type-name)
         (add-code "node_f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-list))
        
        ((equal "fun" type-name)
         (if signature
             (progn
               (dbg "parse-variable-type: signature " signature)
               (dbg "parse-variable-type: signature "
                    (format nil "~a (*~a)(~a)"
                            (car (reverse signature))
                            (get-variable-name var-name)
                            (cdr (reverse signature))))
               (add-code (format nil "~a (*~a)(~a)"
                                 (car (reverse signature))
                                 (get-variable-name var-name)
                                 (cadr (reverse signature))))
               (setf (gethash (get-variable-name var-name) *variables*) 'function))
             (progn
               (add-code "single_fn_f32")
               (setf (gethash (get-variable-name var-name) *variables*) 'function))))
        (t
         (error-no-type-def))))

(defun parse-signature-vector (var-name expr-list)
  (dbg "parse-signature-vector: ENTRY " (car expr-list))
  (if (equal "$" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (equal "[" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-signature-vector: " (car expr-list))
        (setf (gethash var-name *signatures*) (append
                                               (gethash var-name *signatures*)
                                               (list (car expr-list))))
        (dbg "parse-signature-vector: " (gethash var-name *signatures*))
        (setf expr-list (parse-signature-vector var-name (cdr expr-list)))))
  (if (equal "]" (car expr-list))
      (progn
        (dbg "parse-signature-vector: EXIT " (car expr-list))
        (setf expr-list (cdr expr-list))
        (return-from parse-signature-vector expr-list)))
  expr-list)
  
(defun parse-variable (expr-list)
  (dbg "parse-variable: " (car expr-list))
  (cond ((equal "\n" (car expr-list))
         (dbg "parse-variable: RET")
         (setf expr-list (parse-variable (cdr expr-list))))
        ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-variable: DEFINE " (car expr-list))
           (if (or (equal "\n" (cadr expr-list))
                   (equal "]" (cadr expr-list)))
               (error-no-type-def))
           ;; store current variable
           (setf *current-let-definition* (cadr def))
           ;; parse signature
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list (parse-signature-vector
                                  (car def) (cdr expr-list)))
                 (dbg "parse-argument: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type (car def) (cadr def)
                                      (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type (car def) (cadr def))
                 (setf expr-list (cdr expr-list))))
           ;; if function then register function
           (if (equal (format nil "~a"
                              (gethash (get-variable-name
                                        (car def)) *variables*))
                      "FUNCTION")
               (register-function (car def) (car expr-list))
               (progn
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           ;; if array emit brackezs
           (if (search "#" (cadr def))
               (add-code "[]"))
           ;; initialisation
           (add-code "=")
           (dbg "parse-variable: OPEN ARG")
           (if (equal (car expr-list) "]")
               (error-missing-expression))
           ;; parse initialisation
           (dbg "parse-variable: next ")
           (setf expr-list (parse-expression expr-list))
           ;; store poiner
           (dbg "parse-variable: append size ")
           (if (search "#" (cadr def))
               (add-code
                (format nil "append_ptr(~a, sizeof(~a)/sizeof(~a), ARRAY);~%"
                                 (get-variable-name (car def))
                                 (get-variable-name (car def))
                                 (regex-replace "#" (cadr def) ""))))
           (if (search ">" (cadr def))
               (add-code
                (format nil "append_ptr(~a, 1, VARIABLE);~%"
                                 (get-variable-name (car def)))))
           (dbg "parse-variable: rest ")))
        ((not (find #\: (car expr-list)))
         (error-syntax-error)))
  expr-list)

(defun parse-operator (expr-list)
  (cond ((equal ">" (car expr-list))
         (add-code ">"))
        ((equal ">=" (car expr-list))
         (add-code ">="))
        ((equal "<" (car expr-list))
         (add-code "<"))
        ((equal "<=" (car expr-list))
         (add-code "<="))
        ((equal "!=" (car expr-list))
         (add-code "!="))
        ((equal "==" (car expr-list))
         (add-code "=="))
        ((stringp (car expr-list))
         (error-operator-not-defined)))
  (setf expr-list (cdr expr-list)))

(defun parse-condition (expr-list)
  (dbg "parse-condition: " (car expr-list))
  (let ((operator "")
        (left nil)
        (right nil))
    (cond ((not (equal "\n" (car expr-list)))
           (add-code "if")
           (add-code "(")
           (setf left expr-list)
           (dbg "parse-condition: parse left-side " (car expr-list))
           (setf expr-list (parse-expression expr-list t))
           (setf operator (car expr-list))
           (dbg "parse-condition: parse operator " operator)
           (setf expr-list (parse-operator expr-list))
           (setf right expr-list)
           (dbg "parse-condition: parse right-side " (car expr-list))
           (setf expr-list (parse-expression expr-list t))
           (add-code ")")
           (add-code (format nil "~%"))
           (dbg "parse-condition: rest "))
          ((equal "\n" (car expr-list))
           (dbg "parse-condition: RET")
           (setf expr-list (parse-condition expr-list))))
    expr-list))

(defun parse-range (expr-list)
  (dbg "parse-range: " (car expr-list))
  (let ((operator "")
        (from 0)
        (to 0)
        (var-name ""))
    (cond ((equal "\n" (car expr-list))
           (dbg "parse-range: RET")
           (setf expr-list (parse-range expr-list)))
          ((find #\: (car expr-list))
           (let ((def (split ":" (car expr-list))))
             (dbg "parse-range: DEFINE " (car expr-list))
             (parse-variable-type (car def) (cadr def))
             (dbg "parse-range: OPEN ARG")
             (if (or (equal "\n" (cadr expr-list)) (equal "]" (cadr expr-list)))
                 (error-no-type-def))
             (add-code " ")
             (setf var-name (get-variable-name (car def)))
             (dbg "parse-range: get-variable-name " var-name)
             (add-code var-name)
             (add-code "=")
             (if (equal (cadr expr-list) "]")
                 (error-missing-expression))
             (dbg "parse-range: parse from ")
             (setf from expr-list)
             (setf expr-list (parse-expression (cdr expr-list) t))
             (add-code (format nil ";~%"))
             (add-code "for")
             (add-code "(")
             (add-code var-name)
             (add-code "=")
             (setf expr-list (parse-expression (cdr from) t))
             (add-code ";")
             (dbg "parse-range: parse operator " (car expr-list))
             (add-code var-name)
             (setf operator (car expr-list))
             (setf expr-list (parse-operator expr-list))
             (dbg "parse-range: parse to " (car expr-list))
             (setf to expr-list)
             (setf expr-list (parse-expression expr-list t))
             (add-code (format nil ";"))
             (add-code var-name)
             (if (or (equal operator "<") (equal operator "<="))
                 (add-code "++"))
             (if (or (equal operator ">") (equal operator ">="))
                 (add-code "--"))
             (if (equal operator "!=")
                 (add-code "++"))
             (add-code ")")
             (add-code (format nil "~%"))
             (dbg "parse-range: rest ")))
          ((not (find #\: (car expr-list)))
           (error-syntax-error)))
    expr-list))

(defun parse-block (expr-list)
  (dbg "parse-block " (car expr-list) " block " *block*)
  (if (equal "(" (car expr-list))
      (progn
        (dbg "parse-block before expression " (car expr-list))
        (setf expr-list (parse-expression expr-list))
        (sb-ext:gc)))
  (if (not expr-list)
      (return-from parse-block expr-list))
  (if (equal "\"" (car expr-list))
      (progn
        (dbg "parse-expression: STRING block " *block*)
        (add-code "\"")
        (setf expr-list (parse-cstr (cdr expr-list)))
        (dbg "parse-expression: STRING END ")
        (add-code (format nil ";~%"))
        (return-from parse-block expr-list)))
  (if (equal ";|" (car expr-list))
      (progn
        (dbg "parse-expression: parse multiline comment")
        (setf expr-list (parse-multiline-comment expr-list))
        (return-from parse-block expr-list)))
  (if (equal ";" (car expr-list))
      (progn
        (dbg "parse-expression: parse singleline comment")
        (setf expr-list (parse-single-line-comment (cdr expr-list)))
        (return-from parse-block expr-list)))
  (if (equal "\n" (car expr-list))
      (setf expr-list (parse-block (cdr expr-list))))
  (if (equal ")" (car expr-list))
      (return-from parse-block expr-list))
  (if (not (equal ")" (car expr-list)))
      (progn
        (dbg "parse-block " (car expr-list))
        (setf expr-list (parse-block (cdr expr-list))))))

(defun parse-function-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-function-vector: parse variable")  
    (setf expr-list (parse-argument expr-list))
    (if (equal "]" (car expr-list))
        (return-from parse-function-vector expr-list))
    (if (and (not (find #\: (cadr expr-list))) (not (equal "]" (cadr expr-list))))
        (error-function-vector-malformed))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-function-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-function-vector expr-list))))))

(defun parse-if-vector (expr-list)
  (dbg "parse-if-vector: condition range" (car expr-list))  
  (setf expr-list (parse-condition expr-list))
  (loop while (equal "\n" (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-if-vector expr-list))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-if-vector: next variable")  
        (setf expr-list (parse-if-vector expr-list))))
  (dbg "parse-if-vector: exit" (car expr-list))
  expr-list)

(defun parse-for-vector (expr-list)
  (dbg "parse-for-vector: parse range")  
  (setf expr-list (parse-range expr-list))
  (if (equal "]" (car expr-list))
      (return-from parse-for-vector expr-list))
  (loop while (equal "\n" (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-for-vector: next variable")  
        (setf expr-list (parse-for-vector expr-list))))
  (dbg "parse-for-vector: exit" (car expr-list))
  expr-list)

(defun parse-let-vector (expr-list)
  (dbg "parse-let-vector: parse variable")  
  (setf expr-list (parse-variable expr-list))
  (if (equal "]" (car expr-list))
      (return-from parse-let-vector expr-list))
  (loop while (equal "\n" (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-let-vector: next variable")  
        (setf expr-list (parse-let-vector expr-list))))
  (dbg "parse-let-vector: exit" (car expr-list))
  expr-list)

(defun parse-open-square-bracket (expr-list)
  (dbg "parse-open-square-bracket")  
  (if (equal "[" (car expr-list))
      (return-from parse-open-square-bracket (cdr expr-list))
      (error-missing-open-square-bracket)))

(defun parse-close-square-bracket (expr-list)
  (dbg "parse-close-square-bracket")  
  (if (equal "]" (car expr-list))
      (return-from parse-close-square-bracket (cdr expr-list))
      (error-missing-close-square-bracket)))

(defun parse-open-parens (expr-list)
  (dbg "parse-open-parens")  
  (if (equal "(" (car expr-list))
      (return-from parse-open-parens (cdr expr-list))
      (error-missing-open-parens)))

(defun parse-close-parens (expr-list)
  (dbg "parse-close-parens")  
  (if (equal ")" (car expr-list))
      (return-from parse-close-parens (cdr expr-list))
      (error-missing-close-parens)))

(defun parse-if (expr-list)
  (inc-block)
  (dbg "parse-if: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-expression expr-list))
  (add-code (format nil "}~%"))
  (if (not (equal ")" (car expr-list)))
      (progn
        (add-code "else")
        (add-code (format nil "~%{~%"))
        (setf expr-list (parse-expression expr-list))
        (add-code (format nil "}~%"))))
  (dec-block)
  (dbg "parse-if BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-for (expr-list)
  (inc-block)
  (dbg "parse-for: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-for-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-for BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-for ")
  expr-list)

(defun parse-let (expr-list)
  (inc-block)
  (dbg "parse-let: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-let-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-let BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-let ")
  expr-list)

(defun parse-def-function (expr-list)
  (let ((fn-name (car expr-list)))
  (dbg "parse-def-function: name and type block " *block* " parens " *paranteses*)
  (setf expr-list (parse-function-name-and-type expr-list))
  (inc-block)
  (dbg "parse-def-function: open square")
  (add-code "(")
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-function-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code ")")
  (add-code (format nil "~%{~%"))
  (setf expr-list (parse-block expr-list))
  (if (search "main" fn-name)
      (add-code (format nil "destroy_ptr(pointer_list);~%")))
  (add-code (format nil "}~%"))
  (dec-block)
  (dbg "parse-def-function BLOCK END block " *block* " parens " *paranteses*)
  (dbg "parse-def-function " (car expr-list))
  expr-list))

(defun parse-module (expr-list)
  (setf *current-module* (car expr-list))
  (setf expr-list (cdr expr-list))
  (setf expr-list (parse-block expr-list))
  (setf *current-module* "")
  expr-list)

(defun parse-multiline-comment (expr-list)
  (cond ((equal "|;" (car expr-list))
         (dbg "parse-multiline-comment: CLOSE")
         (return-from parse-multiline-comment (cdr expr-list)))
        ((stringp (car expr-list))
         (dbg "parse-multiline-comment: COMMENT >" (car expr-list) "<")
         (setf expr-list (parse-multiline-comment (cdr expr-list))))))

(defun parse-single-line-comment (expr-list)
  (cond ((equal "\n" (car expr-list))
         (return-from parse-single-line-comment (cdr expr-list)))
        ((not (equal "\n" (car expr-list)))
         (dbg "parse-singleline-comment: COMMENT " (car expr-list))
         (setf expr-list (parse-single-line-comment (cdr expr-list))))))

(defun parse-cstr (expr-list)
  (cond ((equal "\"" (car expr-list))
         (add-code "\"")
         (setf expr-list (cdr expr-list))
         (return-from parse-cstr expr-list))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-cstr (cdr expr-list)))))
  expr-list)

(defun parse-element (expr-list)
  (dbg "parse-element " (car expr-list))
  (cond ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", ")))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", "))))
  (cdr expr-list))
             
(defun parse-vector (expr-list)
  (dbg "parse-vector " (car expr-list))
  (cond ((equal "[" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-vector expr-list))))
        ((equal "]" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-vector expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-vector expr-list)))))
  expr-list)
  
(defun parse-list (expr-list)
  (dbg "parse-list " (car expr-list))
  (cond ((equal "'(" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-list expr-list))))
        ((equal ")" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-list expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-list expr-list)))))
  expr-list)
  
(defun count-elements (expr-list)
  (let ((count 0)
        (parens 0))
    (loop for x from 0 to (1- (length expr-list)) do
         (if (equal "(" (elt expr-list x))
             (progn
               (if (= parens 0)
                   (setf count (1+ count)))
               (setf parens (1+ parens))))
         (if (equal ")" (elt expr-list x))
             (progn
               (setf parens (1- parens))
               (if (< parens 0)
                   (return-from count-elements count))))
         (if (and (not (equal "(" (elt expr-list x)))
                  (not (equal ")" (elt expr-list x))))
             (progn
               (if (= parens 0)
                   (setf count (1+ count))))))
    count))
(defun get-type (expr-list)
  (let ((variable-type (gethash (get-iter-variable-name (cadr expr-list)) *variables*))
        (number-type (type-of-number-string (cadr expr-list)))
        (function-type (inspect-function-type (cdr expr-list)))
        (tp nil)
        (tp-str ""))
    (cond ((remove-if-not #'(lambda (x)
                              (equal x (get-iter-variable-name (cadr expr-list))))
                          (hash-table-keys *variables*))
           (setf tp variable-type))
          (function-type
           (setf tp function-type))
          (number-type
           (setf tp number-type)))
    (cond ((equal tp 'boolean)
           (setf tp-str "bool"))
          ((equal tp 'b8)
           (setf tp-str "char"))
          ((equal tp 'short-integer)
           (setf tp-str "i16"))
          ((equal tp 'integer)
           (setf tp-str "i32"))
          ((equal tp 'bigint)
           (setf tp-str "i64"))
          ((equal tp 'double-float)
           (setf tp-str "f64"))
          ((equal tp 'single-float)
           (setf tp-str "f32"))
          ((equal tp 'string)
           (setf tp-str "string"))
          
          ((equal tp 'boolean-array)
           (setf tp-str "array_bool"))
          ((equal tp 'char-array)
           (setf tp-str "array_c8"))
          ((equal tp 'char-array)
           (setf tp-str "array_b8"))
          ((equal tp 'short-integer-array)
           (setf tp-str "array_i16"))
          ((equal tp 'integer-array)
           (setf tp-str "array_i32"))
          ((equal tp 'bigint-array)
           (setf tp-str "array_i64"))
          ((equal tp 'double-float-array)
           (setf tp-str "array_f64"))
          ((equal tp 'single-float-array)
           (setf tp-str "array_f32"))
          
          ((equal tp 'boolean-pointer)
           (setf tp-str "pointer_bool"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_c8"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_b8"))
          ((equal tp 'short-integer-pointer)
           (setf tp-str "pointer_i16"))
          ((equal tp 'integer-pointer)
           (setf tp-str "pointer_i32"))
          ((equal tp 'bigint-pointer)
           (setf tp-str "pointer_i64"))
          ((equal tp 'double-float-pointer)
           (setf tp-str "pointer_f64"))
          ((equal tp 'single-float-pointer)
           (setf tp-str "pointer_f32"))

          ((equal tp 'boolean-list)
           (setf tp-str "list_bool"))
          ((equal tp 'char-list)
           (setf tp-str "list_c8"))
          ((equal tp 'char-list)
           (setf tp-str "list_b8"))
          ((equal tp 'short-interger-list)
           (setf tp-str "list_i16"))
          ((equal tp 'integer-list)
           (setf tp-str "list_i32"))
          ((equal tp 'bigint-list)
           (setf tp-str "list_i64"))
          ((equal tp 'double-float-list)
           (setf tp-str "list_f64"))
          ((equal tp 'single-float-list)
           (setf tp-str "list_f32"))
          (t
           (setf tp-str "T")
           (error-cant-infer-type)))
    tp-str))


(defun get-math-type (expr-list)
  (let ((variable-type (gethash (get-iter-variable-name (cadr expr-list)) *variables*))
        (number-type (type-of-number-string (cadr expr-list)))
        (function-type (inspect-function-type (cdr expr-list)))
        (tp nil)
        (tp-str ""))
    (cond ((remove-if-not #'(lambda (x)
                              (equal x (get-iter-variable-name (cadr expr-list))))
                          (hash-table-keys *variables*))
           (setf tp variable-type))
          (function-type
           (setf tp function-type))
          (number-type
           (setf tp number-type)))
    (cond ((equal tp 'short-integer)
           (setf tp-str "i16"))
          ((equal tp 'integer)
           (setf tp-str "i32"))
          ((equal tp 'bigint)
           (setf tp-str "i64"))
          ((equal tp 'double-float)
           (setf tp-str "f64"))
          ((equal tp 'single-float)
           (setf tp-str "f32"))
          
          ((equal tp 'boolean-pointer)
           (setf tp-str "pointer_bool"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_c8"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_b8"))
          ((equal tp 'short-integer-pointer)
           (setf tp-str "pointer_i16"))
          ((equal tp 'integer-pointer)
           (setf tp-str "pointer_i32"))
          ((equal tp 'bigint-pointer)
           (setf tp-str "pointer_i64"))
          ((equal tp 'double-float-pointer)
           (setf tp-str "pointer_f64"))
          ((equal tp 'single-float-pointer)
           (setf tp-str "pointer_f32"))
          (t
           (setf tp-str "T")
           (error-cant-infer-type)))
    tp-str))

(defun parse-arguments (expr-list max)
  (dbg "parse-arguments: >" (car expr-list) "<")
  (cond ((equal "\"" (car expr-list))
         (if (and *paranteses*
                  (not (equal "(" (get-last-code))))
             (add-code ","))
         (add-code "\"")
         (dbg "parse-arguments: parse-cstr >" (car expr-list) "<")
         (setf expr-list (parse-cstr (cdr expr-list)))
         (setf expr-list (parse-arguments expr-list max)))
        ((equal ")" (car expr-list))
         (let ((fn (get-current-function)))
           (dbg "parse-arguments: " (car expr-list) " function " fn)
           (dbg "parse-arguments: block " *block* " Parens " *paranteses*)
           (return-from parse-arguments expr-list)))
        ((equal "," (car expr-list))
         (error-syntax-error))
        ((equal "\n" (car expr-list))
         (setf expr-list (parse-arguments (cdr expr-list) max)))
        ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (progn
           (dbg "parse-arguments: NUMBERP ")
           (if (not (equal "(" (get-last-code)))
               (add-code ","))
           (progn
             ; convert lisp double-float to c double
             (setf (car expr-list) (regex-replace-all "d0" (car expr-list) "f"))
             (add-code (car expr-list))
             (setf expr-list (parse-arguments (cdr expr-list) max)))))
        ((remove-if-not #'(lambda (x)
                             (equal x (get-iter-variable-name (car expr-list))))
                         (hash-table-keys *variables*))
         (progn
           (if (and (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code))))
               (add-code ","))
           (dbg "parse-arguments: VARIABLE " (get-iter-variable-name (car expr-list)))
           (add-code (get-iter-variable-name (car expr-list)))
           (setf expr-list (parse-arguments (cdr expr-list) max))
           (return-from parse-arguments expr-list)))
        ((remove-if-not #'(lambda (x)
                            (equal x (get-iter-function-name (car expr-list))))
                        (hash-table-keys *functions*))
         (progn
           (dbg "parse-arguments: last code " (get-previous-code))
           (add-code (get-iter-function-name (car expr-list)))
           (setf expr-list (parse-arguments (cdr expr-list) max))))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-arguments: VARIABLE not defined: "
              (get-iter-variable-name  (car expr-list))" block " *block*
              " hash " (hash-table-keys *variables*))
         (error-variable-not-defined))
        ((equal "(" (car expr-list))
         (progn
           (if (and *paranteses*
                    (not (equal "(" (get-last-code)))
                    (not (equal ")" (get-last-code))))
               (add-code ","))
           (dbg "parse-arguments: parse-expression ( block "
                *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t))
           (setf expr-list (parse-arguments expr-list
                                            (1- (count-elements expr-list)))))))
  expr-list)

(defun parse-infix (expr-list function)
  (if (equal ")" (car expr-list))
      (progn
        (dbg "parse-infix: parens ) parens " *paranteses* " block " *block*)
        (dbg "parse-infix: EXIT ")
        (return-from parse-infix expr-list)))
  (dbg "parse-infix: operand " (car expr-list))
  (setf expr-list (parse-expression expr-list t))
  (if (and (not (equal ")" (car expr-list)))
           (not (equal "\n" (car expr-list))))
      (progn
        (add-code function)
        (setf expr-list (parse-infix expr-list function))))
  expr-list)

(defun parse-call (expr-list)
  (cond ((equal ")" (car expr-list))
         (progn
           (return-from parse-call (cdr expr-list))))
        ((equal "," (car expr-list))
         (error-syntax-error))
        ((equal "\n" (car expr-list))
         (dbg "parse-call: RET")
         (setf expr-list (parse-call (cdr expr-list))))
        ((or (equal "set" (car expr-list)) (equal "::" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "set")
           (if (remove-if-not #'(lambda (x)
                                  (equal x (get-iter-variable-name
                                            (cadr expr-list))))
                                  (hash-table-keys *variables*))
               (progn
                 (add-code (format nil "set_pointer_~a" type))
                 (add-code "(")
                 (add-code "&"))
               (progn
                 (if (or (search "elt" (caddr expr-list)) (search "#" (caddr expr-list)))
                     (add-code (format nil "set_pointer_~a" type))
                     (add-code (format nil "set_~a" type)))
                 (add-code "(")))
           (progn
             (dbg "parse-call: set Next arg " (cadr expr-list))
             (setf expr-list (parse-arguments (cdr expr-list) 2)))))
        ((or (equal "elt" (car expr-list)) (equal "#" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "elt")
           (if (equal (cadr (gethash (get-last-function) *signatures*)) "value")
               (add-code "*"))
           (add-code (format nil "elt_~a" (regex-replace "pointer" type "array")))
           (add-code "(")
           (dbg "parse-call: elt Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list)
                                            (1- (count-elements expr-list))))))
         ((equal "prnfmt" (car expr-list))
          (store-current-function "prnfmt")
          (add-code "print_format")
          (add-code "(")
          (dbg "parse-call: prnfmt Next arg " (cadr expr-list))
          (setf expr-list (parse-arguments (cdr expr-list) *infinite-arguments*)))
        ((equal "prnl" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "prnl")
           (if (search "array" type)
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list)))))
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prnl Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prn" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "prn")
           (if (search "array" type)
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list)))))
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prn Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prnstr" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "prnstr")
           (add-code (format nil "print_str_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "let" (car expr-list))
         (store-current-function "let")
         (inf "Compile let in block " *block*)
         (dbg "parse-call: LET INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-let (cdr expr-list))))
        ((or (equal "for" (car expr-list)) (equal "∑" (car expr-list)))
         (store-current-function "for")
         (inf "Compile for in block " *block*)          
         (dbg "parse-call: FOR INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-for (cdr expr-list))))
        ((equal "defn" (car expr-list))
         (store-current-function "defn")
         (setf *target* 'implementation)
         (dbg "parse-call: DEFN INC BLOCK " (car expr-list))
         (inf "Compile function '" (cadr expr-list) "'")
         (setf expr-list (parse-def-function (cdr expr-list)))
         (setf *target* 'code))
        ((equal "return" (car expr-list))
         (store-current-function "return")
         (add-code "return")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "if" (car expr-list))
         (store-current-function "if")
         (inf "Compile condition in block " *block*)
         (dbg "parse-call: IF INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-if (cdr expr-list))))
        ((or (equal "mod" (car expr-list))
             (equal "%" (car expr-list)))
         (store-current-function "mod")
         (add-code "mod")
         (add-code "(")
         (dbg "parse-call: MOD block " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-arguments (cdr expr-list) 2)))
        ((equal "<" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "lt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "<=" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "leqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal ">" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "gt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal ">=" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "geqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "!=" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "neq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "==" (car expr-list))
         (let ((type (get-type expr-list)))
           (add-code (format nil "eq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "add" (car expr-list)) (equal "+" (car expr-list)))
         (store-current-function "add")
         (dbg "parse-call: operator + ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "+")))
             (error-operator-not-defined))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "sub" (car expr-list)) (equal "-" (car expr-list)))
         (store-current-function "sub")
         (dbg "parse-call: operator - ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "-")))
             (error-operator-not-defined))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "mul" (car expr-list)) (equal "*" (car expr-list)))
         (store-current-function "mul")
         (dbg "parse-call: operator * ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "*")))
             (error-operator-not-defined))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "div" (car expr-list)) (equal "/" (car expr-list)))
         (store-current-function "div")
         (dbg "parse-call: operator / ")
         (setf expr-list (cdr expr-list))
         (dbg "parse-call: max " (format nil "~a" (count-elements expr-list)))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "/")))
             (error-operator-not-defined))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "sqrt" (car expr-list)) (equal "√" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "sqrt")
           (add-code (format nil "sqrt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "power" (car expr-list)) (equal "^" (car expr-list)))
         (let ((type (get-type expr-list)))
           (store-current-function "power")
           (add-code (format nil "power_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "max" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "max")
           (add-code (format nil "max_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "min" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "min")
           (add-code (format nil "min_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "module" (car expr-list))
         (store-current-function "module")
         (setf expr-list (parse-module (cdr expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "size" (car expr-list)) (equal "@" (car expr-list)))
         (store-current-function "size")
         (add-code "sizeof")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "map" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "map")
           (add-code (format nil "map_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "mapn" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "mapn")
           (add-code (format nil "mapn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "reduce" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "reduce")
           (add-code (format nil "reduce_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "push" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "push")
           (add-code (format nil "push_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "car" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "car")
           (add-code (format nil "car_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdr" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "cdr")
           (add-code (format nil "cdr_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "append" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-type-not-supported))
           (store-current-function "append")
           (add-code (format nil "append_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "len" (car expr-list))
         (let ((type (get-type expr-list)))
           (store-current-function "len")
           (add-code (format nil "length_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "remove" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "remove")
           (add-code (format nil "remove_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "pop" (car expr-list))
         (let ((type (get-type expr-list)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "pop")
           (add-code (format nil "pop_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "break" (car expr-list))
         (add-code "break")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (add-code "destroy_ptr")
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "bool" (car expr-list))
         (store-current-function "bool")
         (add-code "(")
         (add-code "bool")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "b8" (car expr-list))
         (store-current-function "b8")
         (add-code "(")
         (add-code "b8")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "c8" (car expr-list))
         (store-current-function "c8")
         (add-code "(")
         (add-code "c8")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "i16" (car expr-list))
         (store-current-function "i16")
         (add-code "(")
         (add-code "i16")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "i32" (car expr-list))
         (store-current-function "i32")
         (add-code "(")
         (add-code "i32")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "i64" (car expr-list))
         (store-current-function "i64")
         (add-code "(")
         (add-code "i64")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "f64" (car expr-list))
         (store-current-function "f64")
         (add-code "(")
         (add-code "f64")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "f32" (car expr-list))
         (store-current-function "f32")
         (add-code "(")
         (add-code "f32")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "bool>" (car expr-list))
         (store-current-function "bool>")
         (add-code "(")
         (add-code "bool*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "c8>" (car expr-list))
         (store-current-function "c8>")
         (add-code "(")
         (add-code "c8*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "b8>" (car expr-list))
         (store-current-function "b8>")
         (add-code "(")
         (add-code "b8*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "i16>" (car expr-list))
         (store-current-function "i16>")
         (add-code "(")
         (add-code "i16*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "i32>" (car expr-list))
         (store-current-function "i32>")
         (add-code "(")
         (add-code "i32*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "i64>" (car expr-list))
         (store-current-function "i64>")
         (add-code "(")
         (add-code "i64*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "f64>" (car expr-list))
         (store-current-function "f64>")
         (add-code "(")
         (add-code "f64*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "f32>" (car expr-list))
         (store-current-function "f32>")
         (add-code "(")
         (add-code "f32*")
         (add-code ")")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "del" (car expr-list))
         (store-current-function "del")
         (add-code (format nil "delete_ptr"))
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (store-current-function "destroy")
         (add-code (format nil "destroy_ptr"))
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (parse-arguments (cdr expr-list) 0))
           (return-from parse-call expr-list))
        ((equal "new" (car expr-list))
         (if (not (search ">" *current-let-definition*))
             (error-type-not-supported))
         (let ((type (regex-replace ">" *current-let-definition* "")))
           (store-current-function "new")
           (add-code (format nil "new_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "new_bool" (car expr-list))
         (store-current-function "new_bool")
         (add-code "new_bool")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_c8" (car expr-list))
         (store-current-function "new_c8")
         (add-code "new_c8")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_b8" (car expr-list))
         (store-current-function "new_b8")
         (add-code "new_b8")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_i16" (car expr-list))
         (store-current-function "new_16")
         (add-code "new_i16")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_i32" (car expr-list))
         (store-current-function "new_i32")
         (add-code "new_i32")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_i64" (car expr-list))
         (store-current-function "new_i64")
         (add-code "new_i64")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_f32" (car expr-list))
         (store-current-function "new_f32")
         (add-code "new_f32")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "new_f64" (car expr-list))
         (store-current-function "new_f64")
         (add-code "new_f64")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((remove-if-not #'(lambda (x)
                            (equal x (get-iter-function-name (car expr-list))))
                        (hash-table-keys *functions*))
         (progn
           (dbg "parse-call: FN: " (get-iter-function-name (car expr-list)))
           (if (is-function-map-p (car expr-list))
               (add-code (get-iter-function-name (get-function-value (car expr-list))))
               (add-code (get-iter-function-name (car expr-list))))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) *infinite-arguments*))))
        ((get-iter-variable-name (car expr-list))
         (dbg "parse-call: FN emit: " (get-function-name (car expr-list)))         (add-code "(")
         (add-code "*")
         (add-code (get-function-name (car expr-list)))
         (add-code ")")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list)
                                          *infinite-arguments*)))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-call: FN not defined: " (get-function-name (car expr-list)))
         (error-function-not-defined))
        ((equal "(" (car expr-list))
         (progn
           (dbg "parse-call: CALL OPEN ( block " *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t))))
        )
   expr-list)


(defun parse-expression (expr-list &optional (omit nil))
  (if (car expr-list)
      (progn
        (if (equal "," (car expr-list))
            (error-syntax-error))        
         (if (equal "\"" (car expr-list))
            (progn
              (dbg "parse-expression: STRING block " *block*)
              (add-code "\"")
              (setf expr-list (parse-cstr (cdr expr-list)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: STRING END ")
              (return-from parse-expression expr-list)))
        (if (equal ";|" (car expr-list))
            (progn
              (dbg "parse-expression: parse multiline comment")
              (setf expr-list (parse-multiline-comment expr-list))
              (return-from parse-expression expr-list)))
        (if (equal ";" (car expr-list))
            (progn
              (dbg "parse-expression: parse singleiline comment")
              (setf expr-list (parse-single-line-comment expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "[" (car expr-list))
            (progn
              (add-code "{")
              (dbg "parse-expression: parse vector " (car expr-list))
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (equal "'" (car expr-list))
            (let ((type (get-type (cddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-expression: parse list ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (numberp (parse-integer (car expr-list) :junk-allowed t))
            (progn
              (dbg "parse-expression: NUM block " *block*
                   " number " (car expr-list))
              (add-code (car expr-list))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression (cdr expr-list))))
        (if (remove-if-not
             #'(lambda (x)
                 (equal x (get-iter-function-name (car expr-list))))
             (hash-table-keys *functions*))
            (progn
              (add-code (get-iter-function-name (car expr-list)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: parse function symbol "
                   (car expr-list))))
        (if (remove-if-not
             #'(lambda (x)
                 (equal x (get-iter-variable-name (car expr-list))))
             (hash-table-keys *variables*))
         (progn
           (dbg "parse-expression: VARIABLE "
                (get-iter-variable-name (car expr-list)))
           (if (search ">" *current-let-definition*)
               (add-code "&"))
           (add-code (get-iter-variable-name (car expr-list)))
           (if (not omit)
               (add-code (format nil ";~%")))
           (dbg "parse-expression: VAR END " (car expr-list))
           (return-from parse-expression (cdr expr-list))))
        (if (not (or (equal "," (car expr-list))
                     (equal "\n" (car expr-list))
                     (equal "(" (car expr-list))
                     (equal ")" (car expr-list))
                     (equal "[" (car expr-list))
                     (equal "]" (car expr-list))
                     (equal "\"" (car expr-list))
                     (equal ";|" (car expr-list))
                     (equal "|;" (car expr-list))
                     (equal ";" (car expr-list))
                     (numberp (parse-integer (car expr-list) :junk-allowed t))))
            (progn
              (dbg "parse-expression: SYMBOL " (car expr-list))
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "(" (car expr-list))
            (let ((space nil))
              (setf expr-list (parse-open-parens expr-list))
              (inc-parens)
              (dbg "parse-expression: OPEN parens "
                   *paranteses* " block " *block*)
              ;; omit semicolon for blocks
              (if (or (equal "for" (car expr-list))
                      (equal "if" (car expr-list))
                      (equal "defn" (car expr-list))
                      (equal "let" (car expr-list))
                      (equal "module" (car expr-list)))
                  (setf space t))
              (setf expr-list (parse-call expr-list))
              (dbg "parse-expression: CALL END rest " (car expr-list)
                   " parens " *paranteses* " block " *block*)
              (if (car expr-list)
                  (setf expr-list (parse-close-parens expr-list)))
              (dbg "parse-expression: CLOSE parens " *paranteses* " block " *block*
                   " omit " omit)
              (let ((fn (get-last-function)))
                (dbg "parse-expression: function " fn)
                (if (and
                     (not (equal "i16" fn))
                     (not (equal "i32" fn))
                     (not (equal "i64" fn))
                     (not (equal "f32" fn))
                     (not (equal "f64" fn))
                     (not (equal "bool" fn))
                     (not (equal "b8" fn))
                     (not (equal "c8" fn))
                     (not (equal "i16>" fn))
                     (not (equal "i32>" fn))
                     (not (equal "i64>" fn))
                     (not (equal "f32>" fn))
                     (not (equal "f64>" fn))
                     (not (equal "bool>" fn))
                     (not (equal "b8>" fn))
                     (not (equal "c8>" fn))
                     (not space))
                    (add-code ")")))
              (dec-parens)
              (if (and (not space) (not omit))
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (equal "\n" (car expr-list))
            (progn
              (setf expr-list (cdr expr-list))
              (dbg "parse-expression: caught \n")
              (return-from parse-expression expr-list))))))
  
(defun parse (expression)
  "Parse expression."
  (let ((expr-list (preprocess expression)))
    (setf *code_list* '(""))
    (setf *implementation_list* '(""))
    (setf *definition_list* '(""))
    (setf *paranteses* 0)
    (setf  *block* 0)
    (setf *variables* (make-hash-table :test 'equal))
    (setf *functions* (make-hash-table :test 'equal))
    (setf *function-map* (make-hash-table :test 'equal))
    (setf *signatures* (make-hash-table :test 'equal))
    (setf *current-function* (make-hash-table :test 'equal))
    (setup-signatures)
    (loop while (and (find "(" expr-list :test #'equal)
                     (> (length expr-list) 0)) do
         (setf expr-list (parse-expression expr-list))))
  (emit-code-call))
