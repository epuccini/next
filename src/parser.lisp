;;; -----------------------------------------------------
;;; next - parser file
;;; -----------------------------------------------------
;;; File:     src/parser.lisp
;;; Date:     09:29:15 of Wednesday, 8/14/2019 (GMT+1)
;;; Author:   Edward Puccini
;;; -----------------------------------------------------

(in-package :next)

(require 'parse-float)

(defvar *code_list* '(""))
(defvar *definition_list* '(""))
(defvar *implementation_list* '(""))
(defvar *target* 'code)
(defvar *paranteses* 0)
(defvar *variables* nil)
(defvar *functions* nil)
(defvar *variable-type* nil)
(defvar *function-type* nil)
(defvar *function-args* nil)
(defvar *compositions* nil)
(defvar *signatures* nil)
(defvar *function-map* nil)
(defvar *current-function* nil)
(defvar *current-composition* nil)
(defvar *current-let-definition* nil)
(defvar *current-module* "")
(defvar *block* 0)
(defvar *error* nil)
(defvar *emitted* nil)
(defvar *generics-template* "")
(defvar *def-template* "")
(defvar *impl-template* "")
(defvar *is-main-defined* nil)
(defvar *infinite-arguments* 10000)
(defvar *types*
  '("i16"
    "i32"
    "i64"
    "ui16"
    "ui32"
    "ui64"
    "f32"
    "f64"
    "f80"
    "bool"
    "b8"
    "c8"
    "string"
    "file"
    "fun"
    "void"
    "i16>"
    "i32>"
    "i64>"
    "ui16>"
    "ui32>"
    "ui64>"
    "f32>"
    "f64>"
    "f80>"
    "bool>"
    "b8>"
    "c8>"
    "string>"
    "file>"
    "fun>"
    "void>"
    "i16#"
    "i32#"
    "i64#"
    "ui16#"
    "ui32#"
    "ui64#"
    "f32#"
    "f64#"
    "f80#"
    "bool#"
    "b8#"
    "c8#"
    "string#"
    "file#"
    "fun#"
    "void#"
    "i16'"
    "i32'"
    "i64'"
    "ui16'"
    "ui32'"
    "ui64'"
    "f32'"
    "f64'"
    "f80'"
    "bool'"
    "b8'"
    "c8'"
    "string'"
    "file'"
    "fun'"
    "void'"
    "i16>>"
    "i32>>"
    "i64>>"
    "ui16>>"
    "ui32>>"
    "ui64>>"
    "f32>>"
    "f64>>"
    "f80>>"
    "bool>>"
    "b8>>"
    "c8>>"
    "string>>"
    "file>>"
    "fun>>"
    "void>>"))

(defun load-templates ()
  (setf *def-template* (load-binary-data "../templates/code.h"))
  (setf *impl-template* (load-binary-data "../templates/code.c"))
  (setf *generics-template* (load-binary-data "../templates/generics.h")))

(defun is-main-defined-p ()
  *is-main-defined*)

(defun filter-expression (expression)
  (let* ((new-expr1 (regex-replace-all "-" expression "_"))
         (new-expr2 (regex-replace-all "\\√" new-expr1 "sqrt"))
         (new-expr3 (regex-replace-all "\\^" new-expr2 "power"))
         (new-expr4 (regex-replace-all "∑" new-expr3 "for"))
         (new-expr5 (regex-replace-all ">>" new-expr4 "__")))
    new-expr5))

(defun print-stack ()
  "Use swank to log a stack-trace."
  (let ((trace ""))
    (let* ((msg-lst (remove-if #'null
                               (swank-backend:call-with-debugging-environment
                                (lambda () (swank:backtrace 0 7)))))
           (stack-msg
            (progn
              (mapcar (lambda (msg)
                        (setf trace (concatenate 'string trace 
                                                   (format nil "~{~A ~}~%" msg))))
                      msg-lst) trace)))
      (print stack-msg))))

(defun final-error-msg (expr-list msg)
  (if (not *emitted*)
      (emit-code-call))
  (format t msg)
  (ignore-errors
   (regex-replace "\n" (format t "~%~{~a ~}~%" (subseq expr-list 0 40)) " "))
  (print-stack)
  (sb-ext:quit))

(defun error-msg (expr-list msg)
  (if (not *emitted*)
      (emit-code-call))
  (format t msg)
  (setf *error* t)
  (sb-ext:quit)
  (ignore-errors
   (regex-replace "\n" (format t "~%~{~a ~}~%" (subseq expr-list 0 40)) " ")))

(defun error-parameter-max (expr-list cnt max)
  (error-msg expr-list (format nil "Error too many parameter to function (~a). Only ~a parameter expected!~%"
             cnt max)))

(defun error-operator-not-defined (expr-list)
  (final-error-msg expr-list "~%Error no operator defined!~%"))

(defun error-no-type-def (expr-list)
  (error-msg expr-list "~%Error no type defined!~%"))

(defun error-function-not-defined (expr-list)
  (error-msg expr-list "~%Error function not defined!~%"))

(defun error-missing-expression (expr-list)
  (error-msg expr-list "~%Error missing expression!~%"))

(defun error-function-type-unkown (expr-list type)
  (error-msg expr-list (format nil "~%Error function type >~a< unkown!~%" type)))

(defun error-syntax-error (expr-list)
  (final-error-msg expr-list "~%Error syntax error!~%"))

(defun error-missing-open-square-bracket (expr-list)
  (final-error-msg expr-list "~%Error missing square bracket!~%"))

(defun error-missing-open-parens (expr-list)
  (final-error-msg expr-list "~%Error missing open parens!~%"))

(defun error-missing-close-square-bracket (expr-list)
  (final-error-msg expr-list "~%Error missing square bracket!~%"))

(defun error-missing-close-parens (expr-list)
  (final-error-msg expr-list "~%Error missing close parens!~%"))

(defun error-variable-not-defined (expr-list variable)
  (error-msg expr-list
             (format nil "~%Error variable >~a< not defined!~%" variable)))

(defun error-function-vector-malformed (expr-list)
  (error-msg expr-list "~%Error function vector malformed!~%"))

(defun error-composition-vector-malformed (expr-list)
  (error-msg expr-list "~%Error composition vector malformed!~%"))

(defun error-let-vector-malformed (expr-list)
  (error-msg expr-list "~%Error let vector malformed!~%"))

(defun error-cant-infer-type (expr-list)
  (error-msg expr-list "~%Error cant determine type!~%"))

(defun error-only-lists-supported (expr-list)
  (error-msg expr-list "~%Error only lists supported!~%"))

(defun error-type-not-supported (expr-list type)
  (error-msg expr-list (format nil "~%Error type >~a< not supported!~%" type)))

(defun error-too-many-parens (expr-list)
  (error-msg expr-list "~%Error too many paranteses!~%"))

(defun upto-string (expression lower)
  (let ((str ""))
    (loop for x from lower to (1- (length expression)) do
         (if (equal #\" (elt expression x))
             (return-from upto-string str))
         (if (not (equal #\" (elt expression x)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-symbol (expression lower)
  (let ((str "")
        (stack '()))
    (loop for x from lower to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((equal #\" obj)
                  (return-from upto-symbol stack))
                 ((equal #\$ obj)
                  (push "$" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\; obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\( obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\) obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\{ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\} obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\[ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\] obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\% obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\& obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\, obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Newline obj)
                  (push (format nil "~a" #\Newline) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Return obj)
                  (push (format nil "~a" #\Newline) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Linefeed obj)
                  (push (format nil "~a" #\Newline) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Space obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 (t
                  (setf str (format nil "~a~a" str obj))))))
    (push str stack)))

(defun stack-length (stack)
  (let ((l 0))
    (mapcar #'(lambda (x) (setf l (+ l (length x))))
            stack)
    l))

(defun preprocess (expr)
  (let ((stack '())
        (expression (regex-replace-all "->" expr "$")))
    (loop for x from 0 to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((or (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\{ obj)
                      (equal #\} obj)
                      (equal #\% obj)
                      (equal #\& obj)
                      (equal #\, obj)
                      (equal #\; obj)
                      (equal #\< obj)
                      (equal #\> obj)
                      (equal #\# obj))
                  (push (format nil "~a" obj) stack))
                 ((equal #\∑ obj)
                  (push "∑" stack))
                 ((equal #\, obj)
                  (push "," stack))
                 ((equal #\Space obj)
                  (format nil " "))
                 ((equal #\Newline obj)
                  (push (format nil "~a" #\Newline) stack))
                 ((equal #\Return obj)
                  (push (format nil "~a" #\Newline) stack))
                 ((equal #\Linefeed obj)
                  (push (format nil "~a" #\Newline) stack))
                 ((equal #\Tab obj)
                  (format nil " "))
                 ((equal #\" obj)
                  (let ((str (upto-string expression (1+ x))))
                    (setf x (+ x 1 (length str)))
                    (push "\"" stack)
                    (push str stack)
                    (push "\"" stack)))
                 (t
                  (let ((inner-stack (upto-symbol expression x)))
                    (setf stack (append (reverse inner-stack) stack))
                    (setf x (+ x (1- (stack-length inner-stack)))))))))
    (reverse stack)))

(defun emit-code-call ()
  (let ((code "")
        (definition "")
        (implementation ""))
    (if *implementation_list*
        (format t "~%~{~a~}~%" *implementation_list*))
    (if *code_list*
        (format t "~%~{~a~}~%" *code_list*))
    (if *implementation_list*
        (setf implementation
              (format nil "~%~{~a~}~%" *implementation_list*)))
    (if *code_list*
        (progn
          (if (not (is-main-defined-p))
              (setf code (format nil "i32 main () ~%{~%~%~{~a~}~%" *code_list*))
              (setf code (format nil "~%~%~{~a~}~%" *code_list*)))))
    (if (not (is-main-defined-p))
        (setf code (format nil "~a~%destroy_ptr(pointer_list);~%return 0;~%}" code)))
    (setf *emitted* t)
    (values code definition implementation)))

(defun get-current-function ()
  (gethash *paranteses* *current-function*))

(defun get-last-function ()
  (gethash (1- *paranteses*) *current-function*))

(defun store-current-function (fun)
  (setf (gethash *paranteses* *current-function*) fun))

(defun get-composition-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-variable-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-function-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-iter-variable-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *variables*)
              (progn
                (return-from get-iter-variable-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-variable-name-x name cnt)))))))

(defun get-iter-variable-name (name)
  (get-iter-variable-name-x name *block*))

(defun get-iter-function-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *functions*)
              (progn
                (return-from get-iter-function-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-function-name-x name cnt)))))))


(defun get-iter-function-name (name)
  (get-iter-function-name-x name *block*))

(defun get-iter-composition-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *compositions*)
              (progn
                (return-from get-iter-composition-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-composition-name-x name cnt)))))))

(defun get-iter-composition-name (name)
  (get-iter-composition-name-x name *block*))

(defun is-function-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-function-name name)))
                 (hash-table-keys *function-type*)))

(defun is-variable-p (name)
  (remove-if-not #'(lambda (x)
                            (equal x (get-variable-name name)))
                 (hash-table-keys *variables*)))

(defun get-iter-function-type (fn-name)
  (gethash (get-iter-function-name fn-name) *function-type*))

(defun is-iter-function-p (name)
  (get-iter-function-type name))

(defun get-iter-variable-type (fn-name)
  (gethash (get-iter-variable-name fn-name) *variable-type*))

(defun is-iter-variable-p (name)
  (get-iter-variable-type name))

(defun get-iter-composition-type (type-name)
  (remove-if-not #'(lambda (x) (equal x (get-iter-composition-name type-name)))
                 (hash-table-keys *compositions*)))

(defun is-iter-composition-p (type-name)
  (get-iter-composition-type type-name))

(defun is-iter-composition-type-p (expr-list)
  (let* ((split (split ">>" (car expr-list)))
         (struct-type (gethash (get-iter-variable-name (car split)) *variable-type*))
         (struct-name (get-iter-composition-name (format nil "~a" struct-type))))
    (gethash (format nil "~a>>~a" struct-name (cadr split)) *variable-type*)))
  
(defun set-signature (name signature)
  (setf (gethash name *signatures*) signature))

(defun append-signature (name signature)
  (setf (gethash name *signatures*)
        (append (gethash name *signatures*) (list signature))))

(defun inc-parens ()
  (setq *paranteses* (1+ *paranteses*)))

(defun dec-parens ()
  (setq *paranteses* (1- *paranteses*)))

(defun inc-block ()
  (setq *block* (+ 1 *block*)))

(defun dec-block ()
  (zero-hash-variables)
  (setq *block* (- *block* 1)))

(defun zero-parens ()
  (setq *paranteses* 0))

(defun zero-block ()
  (setq *block* 0))

(defun zero-hash-variables ()
  (dolist (var (hash-table-keys *variables*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-variable-name var) *variables*)))))

(defun zero-hash-functions ()
  (dolist (var (hash-table-keys *functions*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-function-name var) *functions*)))))

(defun zero-hash-compositions ()
  (dolist (var (hash-table-keys *compositions*))
    (if (equal (format nil "~a" *block*)
               (subseq (reverse var) 0 1))
        (progn
          (remhash (get-function-name var) *compositions*)))))

(defun add-code (expression)
  ;(setf expression (filter-expression expression))
  (if expression
      (cond ((equal *target* 'code)
             (setf *code_list* (append *code_list* (list expression))))
            ((equal *target* 'implementation)
             (setf *implementation_list* (append *implementation_list*
                                                 (list expression))))
            ((equal *target* 'definition)
             (setf *definition_list* (append *definition_list*
                                             (list expression)))))))

(defun get-last-code ()
  (cond ((equal *target* 'code)
         (car (reverse *code_list*)))
        ((equal *target* 'implementation)
         (car (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (car (reverse *definition_list*)))))

(defun get-previous-code ()
  (cond ((equal *target* 'code)
         (cadr (reverse *code_list*)))
        ((equal *target* 'implementation)
         (cadr (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (cadr (reverse *definition_list*)))))

(defun get-function-value (fn-name)
  (gethash fn-name *function-map*))

(defun set-function-map (fn-name value)
  (setf (gethash fn-name *function-map*) value))

(defun is-function-map-p (fn-name)
  (remove-if-not #'(lambda (fn) (equal fn fn-name))
                 (hash-table-keys *function-map*)))

(defun register-function (name content)
  (set-function-map name content)
  (setf (gethash (get-function-name name) *functions*) 'function)
  (dbg "register-function: Register function >" name
       "< var >" content "<"))

(defun type-of-number-string (numstr)
  (cond ((and
          (typep (parse-integer numstr :junk-allowed t) 'integer)
          (not (find #\. numstr)))
         (return-from type-of-number-string "i32"))
        ((search "d0" numstr)
         (return-from type-of-number-string "f64"))
        ((typep (parse-float numstr
                             :junk-allowed t
                             :type 'single-float) 'single-float)
         (return-from type-of-number-string "f32"))
        (t
         (return-from type-of-number-string nil))))

(defun inspect-function-type (expr-list)
  (dbg "inspect-function-type: next function: "
       (car expr-list) " " (cadr expr-list))
  (if (equal "(" (car expr-list))
      (cond ((is-iter-function-p (cadr expr-list))
             (dbg "inspect-function-type case type " (cadr expr-list))
             (return-from inspect-function-type
               (gethash
                (get-iter-function-name (cadr expr-list))
                *function-type*)))
            (t
             (dbg "inspect-function-type case value " (cadr expr-list))
             (return-from inspect-function-type
               (get-iter-function-name
                (get-function-value (cadr expr-list))))))
      (if (is-iter-function-p (car expr-list))
          (progn
            (dbg "inspect-function-type case 2 type " (car expr-list))
            (return-from inspect-function-type
              (gethash
               (get-iter-function-name (car expr-list))
               *function-type*)))
          (progn
            (dbg "inspect-function-type case 2 value " (car expr-list))
            (return-from inspect-function-type
              (get-iter-function-name
               (get-function-value (car expr-list))))))))

(defun set-function-type (fn-name type)
  (setf (gethash (get-function-name fn-name) *functions*) type)
  (setf (gethash (get-function-name fn-name) *function-type*) type))

(defun parse-argument (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-argument: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           (dbg "parse-argument: OPEN ARG")
           (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
                (setf expr-list (cdr expr-list)))
           (if (find #\: (car expr-list))
               (add-code ","))
           (setf expr-list (parse-argument expr-list)))))
  expr-list)

(defun store-composition-variable (var-name type)
  (setf (gethash (format nil "~a>>~a"
                         (get-composition-name *current-composition*)
                         var-name) *variable-type*) type))

(defun parse-types (expr-list)
  (cond ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-types: DEFINE " (car expr-list))
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-argumemt: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list
                  (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))
                 (add-code " ")
                 (add-code (car def))
                 (dbg "parse-types: store composition variable "
                      (format nil "~a>>~a"
                              (get-composition-name *current-composition*) (car def))
                      " type " (cadr def))
                 (store-composition-variable (car def) (cadr def))
                 (dbg "parse-types: store composition "
                      (get-composition-name *current-composition*)
                      " " (car def))
                 (setf (gethash (get-composition-name *current-composition*) *compositions*)
                       (car def))))
           (dbg "parse-types: OPEN ARG")
           (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
                (setf expr-list (cdr expr-list)))
           (add-code (format nil ";~%"))
           (setf expr-list (parse-types expr-list)))))
  expr-list)

(defun parse-function-type (expr-list &optional (signature nil))
  (let ((fn-name (car (split ":" (car expr-list))))
        (type (cadr (split ":" (car expr-list))))
        (code-type ""))
    ;; base type ?
    (if (is-type-p type)
        (progn
          (cond ((search "'" type)
                 (setf code-type (format nil "node_~a*"
                                         (regex-replace "'" type ""))))
                ((search "#" type)
                 (setf code-type (regex-replace "#" type "")))
                ((search ">>" type)
                 (setf code-type (regex-replace ">>" type "**")))
                ((search ">" type)
                 (setf code-type (regex-replace ">" type "*")))
                (t
                 (setf code-type type)))))
    (if (and (not (equal "fun" type))
             (not (is-iter-composition-p type)))
        (add-code code-type))
    ;; composition ?
    (if (is-iter-composition-p type)
        (progn
          (add-code "struct ")
          (add-code (get-iter-composition-name type))))
    ;; function ?
    (if (equal "fun" type)
           (if signature
               (progn
                 (dbg "parse-function-type: signature " signature)
                 (dbg "parse-function-type: signature "
                      (format nil "~a (*~a)(~a)"
                              (car (reverse signature))
                              (get-function-name fn-name)
                              (cdr (reverse signature))))
                 (add-code (format nil "~a (*~a_~a)(~a)"
                                   (car (reverse signature))
                                   (get-function-name fn-name)
                                   (get-iter-function-type (get-function-name fn-name))
                                   (cadr (reverse signature)))))
               (progn
                 (add-code "single_fn_f32")
                 (setf (gethash (get-function-name fn-name) *functions*) 'function)))
           (setf expr-list (cdr expr-list)))
    ;; errors ?
    (if (and (not type) (is-iter-composition-p type))
        (error-no-type-def expr-list))
    (if (and type (is-iter-composition-p type))
        (error-function-type-unkown expr-list type))
    (setf (gethash (get-function-name fn-name) *function-type*) type)
    (setf (gethash (get-function-name fn-name) *functions*) 'function)
  expr-list))

(defun set-function-arg (name type)
  (setf (gethash (get-function-name name) *function-args*) type))
  
(defun get-iter-function-args (name)
  (gethash (get-iter-function-name name) *function-args*))

(defun parse-function-name-and-type (expr-list)
  (let* ((def (split ":" (car expr-list)))
         (fn-name (car def))
         (first-arg (split ":" (caddr expr-list)))
         (fn-type ""))
    (if (>= (length first-arg) 2)
        (setf fn-type (cadr def))
        (setf fn-type "void"))
    (set-function-arg (car def) fn-type)
    (cond ((stringp (car expr-list))
           (dbg "parse-function-name-and-type: Functionname " fn-name)
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list
                       (parse-signature-vector (car def) (cdr expr-list)))
                 (dbg "parse-function-name-and-type: signature "
                      (gethash (car def) *signatures*))
                 (setf expr-list
                       (parse-function-type expr-list
                                            (gethash (car def) *signatures*))))
               (progn
                 (setf expr-list (parse-function-type expr-list))))
           (add-code " ")))
    (cond ((equal fn-name "main")
           (setf *is-main-defined* t)
           (add-code fn-name))
          (t
           (add-code (format nil "~a_~a"
                             (get-function-name fn-name)
                             fn-type))))
    (dbg "parse-function-name-and-type: EXIT Rest. ")
    expr-list))
  
(defun parse-variable-type (expr-list var-name type &optional (signature nil))
  (let ((code-type ""))
    (if (is-type-p type)
        (progn
          (cond ((search "'" type)
                 (setf code-type (format nil "node_~a*"
                                         (regex-replace "'" type ""))))
                ((search "#" type)
                 (setf code-type (regex-replace "#" type "")))
                ((search ">>" type)
                 (setf code-type (regex-replace ">>" type "**")))
                ((search ">" type)
                 (setf code-type (regex-replace ">" type "*")))
                (t
                 (setf code-type type)))))
    (if (and (not (equal "fun" type))
             (not (is-iter-composition-p type)))
        (add-code code-type))
    (if (is-iter-composition-p type)
        (progn
          (add-code "struct ")
          (add-code (get-iter-composition-name type))))
    (setf (gethash (get-variable-name var-name) *variable-type*) type)
    (cond ((equal "i16" type)
         ; (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i32" type)
         ; (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i64" type)
         ; (add-code "i64")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint))
        ((equal "ui16" type)
         ; (add-code "ui16")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-short-integer))
        ((equal "ui32" type)
         ; (add-code "ui32")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer))
        ((equal "ui64" type)
         ; (add-code "ui64")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint))
        ((equal "f32" type)
         ; (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float))
        ((equal "f64" type)
         ; (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float))
        ((equal "f80" type)
         ; (add-code "f80")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float))
        ((equal "bool" type)
         ; (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean))
        ((equal "b8" type)
         ; (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "c8" type)
         ; (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "file" type)
         ; (add-code "file")         
         (setf (gethash (get-variable-name var-name) *variables*) 'file))
        ((equal "string" type)
         ; (add-code "string")         
         (setf (gethash (get-variable-name var-name) *variables*) 'string))
        ((equal "cstring" type)
         ; (add-code "const string")         
         (setf (gethash (get-variable-name var-name) *variables*) 'const-string))
        
        ((equal "bool#" type)
         ; (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-array))
        ((equal "b8#" type)
         ; (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "c8#" type)
         ; (add-code "c8")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "i16#" type)
         ; (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-array))
        ((equal "i32#" type)
         ; (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-array))
        ((equal "i64#" type)
         ; (add-code "i64")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-array))
        ((equal "ui16#" type)
         ; (add-code "ui16")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-array))
        ((equal "ui32#" type)
         ; (add-code "ui32")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-array))
        ((equal "ui64#" type)
         ; (add-code "ui64")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-array))
        ((equal "f32#" type)
         ; (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-array))
        ((equal "f64#" type)
         ; (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-array))
        ((equal "f80#" type)
         ; (add-code "f80")
         (setf (gethash (get-variable-name var-name) *variables*) 'longdouble-float-array))
        
        ((equal "bool>>" type)
         ; (add-code "bool**")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-handle))
        ((equal "b8>>" type)
         ; (add-code "b8**")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-handle))
        ((equal "c8>>" type)
         ; (add-code "c8**")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-handle))
        ((equal "i16>>" type)
         ; (add-code "i16**")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-handle))
        ((equal "i32>>" type)
         ; (add-code "i32**")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-handle))
        ((equal "i64>>" type)
         ; (add-code "i64**")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-handle))
        ((equal "ui16>>" type)
         ; (add-code "ui16**")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-handle))
        ((equal "ui32>>" type)
         ; (add-code "ui32**")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-handle))
        ((equal "ui64>>" type)
         ; (add-code "ui64**")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-handle))
        ((equal "f32>>" type)
         ; (add-code "f32**")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-handle))
        ((equal "f64>>" type)
         ; (add-code "f64**")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-handle))
        ((equal "f80>>" type)
         ; (add-code "f80**")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float-handle))
        
        ((equal "bool>" type)
         ; (add-code "bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-pointer))
        ((equal "b8>" type)
         ; (add-code "b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "c8>" type)
         ; (add-code "c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "i16>" type)
         ; (add-code "i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-pointer))
        ((equal "i32>" type)
         ; (add-code "i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-pointer))
        ((equal "i64>" type)
         ; (add-code "i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-pointer))
        ((equal "ui16>" type)
         ; (add-code "ui16*")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-pointer))
        ((equal "ui32>" type)
         ; (add-code "ui32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-pointer))
        ((equal "ui64>" type)
         ; (add-code "ui64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-pointer))
        ((equal "f32>" type)
         ; (add-code "f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-pointer))
        ((equal "f64>" type)
         ; (add-code "f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-pointer))
        ((equal "f80>" type)
         ; (add-code "f80*")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float-pointer))
        ((equal "file>" type)
         ; (add-code "file*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'file-pointer))
        ((equal "string>" type)
         ; (add-code "string*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'string-pointer))
        ((equal "cstring>" type)
         ; (add-code "cstring*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'const-string-pointer))


        
        ((equal "bool'" type)
         ; (add-code "node_bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-list))
        ((equal "b8'" type)
         ; (add-code "node_b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "c8'" type)
         ; (add-code "node_c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "i16'" type)
         ; (add-code "node_i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-list))
        ((equal "i32'" type)
         ; (add-code "node_i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-list))
        ((equal "i64'" type)
         ; (add-code "node_i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-list))
        ((equal "ui16'" type)
         ; (add-code "node_ui16*")
         (setf (gethash (get-variable-name var-name) *variables*)
               'unsigned-short-integer-list))
        ((equal "ui32'" type)
         ; (add-code "node_ui32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-integer-list))
        ((equal "ui64'" type)
         ; (add-code "node_ui64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'unsigned-bigint-list))
        ((equal "f32'" type)
         ; (add-code "node_f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-list))
        ((equal "f64'" type)
         ; (add-code "node_f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-list))
        ((equal "f80'" type)
         ; (add-code "node_f80*")
         (setf (gethash (get-variable-name var-name) *variables*) 'long-double-float-list))
        ((is-iter-composition-p type)
;         (add-code "struct ")
 ;        (add-code (get-iter-composition-name type))
         (setf (gethash (get-variable-name var-name) *variables*) type)
         (setf (gethash (get-variable-name var-name) *variable-type*) type))
        ((equal "fun" type)
         (if signature
             (progn
               (dbg "parse-variable-type: signature " signature)
               (dbg "parse-variable-type: signature "
                    (format nil "~a (*~a)(~a)"
                            (car (reverse signature))
                            (get-variable-name var-name)
                            (cdr (reverse signature))))
               (add-code (format nil "~a (*~a)(~a)"
                                 (car (reverse signature))
                                 (get-variable-name var-name)
                                 (cadr (reverse signature))))
               (setf (gethash (get-variable-name var-name) *variable-type*) type)
               (setf (gethash (get-variable-name var-name) *variables*) 'function))
             (progn
               (add-code "single_fn_f32")
               (setf (gethash (get-variable-name var-name) *variables*) 'function))))
        (t
         (dbg "parse-variable-type: " (hash-table-keys *compositions*) " type " type)
         (if (not type)
             (error-no-type-def expr-list)
             (error-type-not-supported expr-list type))))))

(defun parse-signature-vector (var-name expr-list)
  (dbg "parse-signature-vector: ENTRY " (car expr-list))
  (if (equal "$" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (equal "[" (car expr-list))
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-signature-vector: " (car expr-list))
        (setf (gethash var-name *signatures*) (append
                                               (gethash var-name *signatures*)
                                               (list (car expr-list))))
        (dbg "parse-signature-vector: " (gethash var-name *signatures*))
        (setf expr-list (parse-signature-vector var-name (cdr expr-list)))))
  (if (equal "]" (car expr-list))
      (progn
        (dbg "parse-signature-vector: EXIT " (car expr-list))
        (setf expr-list (cdr expr-list))
        (return-from parse-signature-vector expr-list)))
  expr-list)
  
(defun parse-variable (expr-list)
  (dbg "parse-variable: " (car expr-list))
  (cond ((equal (format nil "~a" #\Newline) (car expr-list))
         (dbg "parse-variable: RET")
         (setf expr-list (parse-variable (cdr expr-list))))
        ((find #\: (car expr-list))
         (let ((def (split ":" (car expr-list))))
           (dbg "parse-variable: DEFINE " (car expr-list))
           (if (or (equal (format nil "~a" #\Newline) (cadr expr-list))
                   (equal "]" (cadr expr-list)))
               (error-no-type-def expr-list))
           ;; store current variable
           (setf *current-let-definition* (cadr def))
           ;; parse signature
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr expr-list)))
               (progn
                 (setf expr-list (parse-signature-vector
                                  (car def) (cdr expr-list)))
                 (dbg "parse-argument: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type expr-list (car def) (cadr def)
                                      (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type expr-list (car def) (cadr def))
                 (setf expr-list (cdr expr-list))))
           ;; if function then register function
           (if (equal (format nil "~a"
                              (gethash (get-variable-name
                                        (car def)) *variables*))
                      "FUNCTION")
               (register-function (car def) (car expr-list))
               (progn
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           ;; if array emit brackezs
           (if (search "#" (cadr def))
               (add-code "[]"))
           ;; initialisation
           (add-code "=")
           (dbg "parse-variable: OPEN ARG")
           (if (equal (car expr-list) "]")
               (error-missing-expression expr-list))
           ;; parse initialisation
           (dbg "parse-variable: next ")
           (setf expr-list (parse-expression expr-list))
           ;; store poiner
           (dbg "parse-variable: append size ")
           (if (search "#" (cadr def))
               (add-code
                (format nil "append_ptr(~a, sizeof(~a)/sizeof(~a), ARRAY);~%"
                                 (get-variable-name (car def))
                                 (get-variable-name (car def))
                                 (regex-replace "#" (cadr def) ""))))
           (if (search ">" (cadr def))
               (add-code
                (format nil "append_ptr(~a, 1, VARIABLE);~%"
                                 (get-variable-name (car def)))))
           (dbg "parse-variable: rest " (car expr-list))))
        ((not (find #\: (car expr-list)))
         (setf expr-list (cdr expr-list))
         (error-syntax-error expr-list)))
  expr-list)

(defun parse-logic-operator (expr-list)
  (dbg "parse-logic-operator " (car expr-list) " next " (cadr expr-list))
  (cond ((and (equal ">" (car expr-list)) (equal "=" (cadr expr-list)))
         (return-from parse-logic-operator ">="))
        ((and (equal "<" (car expr-list)) (equal "=" (cadr expr-list)))
         (return-from parse-logic-operator "<="))
        ((and (equal ">" (car expr-list)) (not (equal "=" (cadr expr-list))))
         (return-from parse-logic-operator ">"))
        ((and (equal "<" (car expr-list)) (not (equal "=" (cadr expr-list))))
         (return-from parse-logic-operator "<"))
        ((equal "!=" (car expr-list))
         (return-from parse-logic-operator "!="))
        ((equal "==" (car expr-list))
         (return-from parse-logic-operator "=="))))

(defun parse-arithmetic-operator (expr-list)
  (dbg "parse-arithmetic-operator " (car expr-list) " next " (cadr expr-list))
  (cond ((and (equal ">" (car expr-list)) (equal "=" (cadr expr-list)))
         (setf expr-list (cddr expr-list))
         (add-code ">="))
        ((and (equal "<" (car expr-list)) (equal "=" (cadr expr-list)))
         (setf expr-list (cddr expr-list))
         (add-code "<="))
        ((and (equal ">" (car expr-list)) (not (equal "=" (cadr expr-list))))
         (setf expr-list (cdr expr-list))
         (add-code ">"))
        ((and (equal "<" (car expr-list)) (not (equal "=" (cadr expr-list))))
         (setf expr-list (cdr expr-list))
         (add-code "<"))
        ((equal "!=" (car expr-list))
         (setf expr-list (cdr expr-list))
         (add-code "!="))
        ((equal "=" (car expr-list))
         (setf expr-list (cdr expr-list))
         (add-code "="))
        (t
         (error-operator-not-defined expr-list)))
  expr-list)

(defun parse-condition (expr-list)
  (dbg "parse-condition: " (car expr-list))
  (let ((operator nil))
    (cond ((not expr-list)
           (return-from parse-condition (cdr expr-list)))
          ((not (equal (format nil "~a" #\Newline) (car expr-list)))
           (setf operator (parse-logic-operator expr-list))
           (if (not operator)
               (progn 
                 (if (and (not (equal "]" (car expr-list)))
                          (equal "(" (car expr-list)))
                     (progn
                       (setf expr-list (parse-expression expr-list t))
                       (add-code ")")
                       (add-code (format nil "~%")))
                     (error-operator-not-defined expr-list))
                 (return-from parse-condition expr-list)))
           (if (and (not (equal "<=" operator))
                    (not (equal ">=" operator)))
               (setf expr-list (cdr expr-list))
               (setf expr-list (cddr expr-list)))
           (dbg "parse-condition: parse left-side " (car expr-list))
           (setf expr-list (parse-expression expr-list t))
           (add-code operator)
           (dbg "parse-condition: parse right-side " (car expr-list))
           (setf expr-list (parse-expression expr-list t))
           (add-code ")")
           (add-code (format nil "~%"))
           (dbg "parse-condition: rest " (car expr-list))
           (return-from parse-condition expr-list))
          ((equal (format nil "~a" #\Newline) (car expr-list))
           (dbg "parse-condition: RET")
           (setf expr-list (parse-condition expr-list))))
    expr-list))

(defun parse-range (expr-list)
  (dbg "parse-range: " (car expr-list))
  (let ((operator "")
        (from 0)
        (to 0)
        (var-name ""))
    (cond ((equal (format nil "~a" #\Newline) (car expr-list))
           (dbg "parse-range: RET")
           (setf expr-list (parse-range expr-list)))
          ((equal "]" (car expr-list))
           (add-code "for")
           (add-code "(")
           (add-code ";;")
           (add-code (format nil ")~%"))
          (return-from parse-range expr-list))
          ((find #\: (car expr-list))
           (let ((def (split ":" (car expr-list))))
             (dbg "parse-range: DEFINE " (car expr-list))
             (parse-variable-type expr-list (car def) (cadr def))
             (dbg "parse-range: OPEN ARG")
             (if (or (equal (format nil "~a" #\Newline) (cadr expr-list)) (equal "]" (cadr expr-list)))
                 (error-no-type-def expr-list))
             (add-code " ")
             (setf var-name (get-variable-name (car def)))
             (dbg "parse-range: get-variable-name " var-name)
             (add-code var-name)
             (add-code "=")
             (if (equal (cadr expr-list) "]")
                 (error-missing-expression expr-list))
             (dbg "parse-range: parse from ")
             (setf from expr-list)
             (setf expr-list (parse-expression (cdr expr-list) t))
             (add-code (format nil ";~%"))
             (add-code "for")
             (add-code "(")
             (add-code var-name)
             (add-code "=")
             (setf expr-list (parse-expression (cdr from) t))
             (add-code ";")
             (dbg "parse-range: parse operator " (car expr-list))
             (add-code var-name)
             (setf operator (car expr-list))
             (setf expr-list (parse-arithmetic-operator expr-list))
             (dbg "parse-range: parse to " (car expr-list))
             (setf to expr-list)
             (setf expr-list (parse-expression expr-list t))
             (add-code (format nil ";"))
             (add-code var-name)
             (if (or (equal operator "<") (equal operator "<="))
                 (add-code "++"))
             (if (or (equal operator ">") (equal operator ">="))
                 (add-code "--"))
             (if (equal operator "!=")
                 (add-code "++"))
             (add-code ")")
             (add-code (format nil "~%"))
             (dbg "parse-range: rest ")))
          ((not (find #\: (car expr-list)))
           (setf expr-list (cdr expr-list))
           (error-no-type-def expr-list)))
    expr-list))

(defun parse-block (expr-list)
  (dbg "parse-block " (car expr-list) " block " *block*)
  (if (not expr-list)
      (return-from parse-block expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
       (setf expr-list (cdr expr-list)))
  (if (and (equal ";" (car expr-list)) (equal "|" (cadr expr-list)))
      (progn
        (dbg "parse-expression: parse multiline comment")
        (setf expr-list (parse-multiline-comment (cddr expr-list)))
        (setf expr-list (parse-block expr-list))))
  (if (equal ";" (car expr-list))
      (progn
        (dbg "parse-expression: parse singleline comment")
        (setf expr-list (parse-single-line-comment (cdr expr-list)))
        (setf expr-list (parse-block expr-list))))
  (if (equal "(" (car expr-list))
      (progn
        (dbg "parse-block before expression " (car expr-list))
        (setf expr-list (parse-expression expr-list))
        (sb-ext:gc)))
  (if (equal "\"" (car expr-list))
      (progn
        (dbg "parse-expression: STRING block " *block*)
        (add-code "\"")
        (setf expr-list (parse-cstr (cdr expr-list)))
        (dbg "parse-expression: STRING END ")
        (add-code (format nil ";~%"))
        (return-from parse-block expr-list)))
  (if (equal ")" (car expr-list))
      (return-from parse-block expr-list))
  (if (and (not (equal ")" (car expr-list)))
           (not (equal "(" (car expr-list))))
      (progn
        (dbg "parse-block " (car expr-list))
        (setf expr-list (cdr expr-list))
        (setf expr-list (parse-block expr-list)))))

(defun parse-function-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-function-vector: parse variable")  
    (setf expr-list (parse-argument expr-list))
    (if (equal "]" (car expr-list))
        (return-from parse-function-vector expr-list))
    (if (and (not (find #\: (cadr expr-list))) (not (equal "]" (cadr expr-list))))
        (error-function-vector-malformed expr-list))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-function-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-function-vector expr-list))))))

(defun parse-type-vector (expr-list)
  (let ((temp-list expr-list))
    (dbg "parse-typevector: parse variable")  
    (setf expr-list (parse-types expr-list))
  (if (not expr-list)
      (return-from parse-type-vector (cdr expr-list)))
    (if (equal "]" (car expr-list))
        (return-from parse-type-vector expr-list))
    (if (and (not (find #\: (cadr expr-list)))
             (not (equal "]" (cadr expr-list))))
        (error-composition-vector-malformed expr-list))
    (if (not (equal "]" (car expr-list)))
        (progn
          (dbg "parse-type-vector: next variable " (car expr-list))
          (if (equal temp-list expr-list)
              (setf expr-list (cdr expr-list)))
          (setf expr-list (parse-type-vector expr-list))))))

(defun parse-if-vector (expr-list)
  (dbg "parse-if-vector: condition range" (car expr-list))  
  (setf expr-list (parse-condition expr-list))
  (dbg "parse-if-vector: after condition " (car expr-list))
  (if (not expr-list)
      (return-from parse-if-vector (cdr expr-list)))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-if-vector expr-list))
  (dbg "parse-if-vector: after loop " (car expr-list))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-if-vector: next variable" (car expr-list))  
        (setf expr-list (parse-if-vector expr-list))))
  (dbg "parse-if-vector: exit" (car expr-list))
  expr-list)

(defun parse-for-vector (expr-list)
  (dbg "parse-for-vector: parse range")  
  (setf expr-list (parse-range expr-list))
  (if (not expr-list)
      (return-from parse-for-vector (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-for-vector expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-for-vector: next variable")  
        (setf expr-list (parse-for-vector expr-list))))
  (dbg "parse-for-vector: exit" (car expr-list))
  expr-list)

(defun parse-let-vector (expr-list)
  (dbg "parse-let-vector: parse variable")  
  (setf expr-list (parse-variable expr-list))
  (if (equal "]" (car expr-list))
      (return-from parse-let-vector expr-list))
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (not (equal "]" (car expr-list)))
      (progn
        (dbg "parse-let-vector: next variable")  
        (setf expr-list (parse-let-vector expr-list))))
  (dbg "parse-let-vector: exit" (car expr-list))
  expr-list)

(defun parse-open-square-bracket (expr-list)
  (dbg "parse-open-square-bracket")  
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "[" (car expr-list))
      (return-from parse-open-square-bracket (cdr expr-list))
      (error-missing-open-square-bracket expr-list)))

(defun parse-close-square-bracket (expr-list)
  (dbg "parse-close-square-bracket")  
  (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
      (setf expr-list (cdr expr-list)))
  (if (equal "]" (car expr-list))
      (return-from parse-close-square-bracket (cdr expr-list))
      (error-missing-close-square-bracket expr-list)))

(defun parse-open-parens (expr-list)
  (dbg "parse-open-parens")  
  (if (equal "(" (car expr-list))
      (return-from parse-open-parens (cdr expr-list))
      (error-missing-open-parens expr-list)))

(defun parse-close-parens (expr-list)
  (dbg "parse-close-parens")  
  (if (equal ")" (car expr-list))
      (return-from parse-close-parens (cdr expr-list))
      (error-missing-close-parens expr-list)))

(defun parse-if (expr-list)
  (inc-block)
  (dbg "parse-if: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-expression expr-list))
  (add-code (format nil "}~%"))
  (if (not (equal ")" (car expr-list)))
      (progn
        (add-code "else")
        (add-code (format nil "~%{~%"))

        (setf expr-list (parse-expression expr-list))
        (add-code (format nil "}~%"))))
  (dec-block)
  (dbg "parse-if BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-while (expr-list)
  (inc-block)
  (dbg "parse-while: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-if-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-block expr-list))
  (add-code (format nil "};~%"))
  (dec-block)
  (dbg "parse-while BLOCK END  block " *block* " parens " *paranteses*)
  expr-list)

(defun parse-for (expr-list)
  (inc-block)
  (dbg "parse-for: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-for-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-for BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-for ")
  expr-list)

(defun parse-let (expr-list)
  (inc-block)
  (dbg "parse-let: open square block " *block* " parens " *paranteses*)
  (setf expr-list (parse-open-square-bracket expr-list))
  (add-code (format nil "{~%"))
  (setf expr-list (parse-let-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-let BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-let ")
  expr-list)

(defun parse-compose (expr-list)
  (let ((composition-name (get-composition-name (car expr-list))))
    (setf *current-composition* (car expr-list))
    (dbg "parse-compose: name " *current-composition*
         " and type block " *block*
         " parens " *paranteses*)
    (dbg "parse-compose: open square")
    (add-code (format nil "struct ~a" composition-name))
    (add-code (format nil "~%{~%"))
    (setf expr-list (cdr expr-list))
    (setf expr-list (parse-open-square-bracket expr-list))
    (setf expr-list (parse-type-vector expr-list))
    (setf expr-list (parse-close-square-bracket expr-list))
    (add-code (format nil "};~%"))
    (add-code (format nil "typedef struct ~a ~a;~%" composition-name composition-name))
    (dbg "parse-compose BLOCK END block " *block* " parens " *paranteses*)
    (dbg "parse-compose " (car expr-list))
    (setf *current-composition* "")
    expr-list))

(defun parse-def-function (expr-list)
  (let ((fn-name (car expr-list)))
  (dbg "parse-def-function: name and type block " *block* " parens " *paranteses*)
  (setf expr-list (parse-function-name-and-type expr-list))
  (inc-block)
  (dbg "parse-def-function: open square")
  (add-code "(")
  (setf expr-list (parse-open-square-bracket expr-list))
  (setf expr-list (parse-function-vector expr-list))
  (setf expr-list (parse-close-square-bracket expr-list))
  (add-code ")")
  (add-code (format nil "~%{~%"))
  (setf expr-list (parse-block expr-list))
  (if (search "main" fn-name)
      (add-code (format nil "destroy_ptr(pointer_list);~%")))
  (add-code (format nil "}~%"))
  (dec-block)
  (dbg "parse-def-function BLOCK END block " *block* " parens " *paranteses*)
  (dbg "parse-def-function " (car expr-list))
  expr-list))

(defun parse-module (expr-list)
  (setf *current-module* (car expr-list))
  (inc-block)
  (setf expr-list (cdr expr-list))
  (setf expr-list (parse-block expr-list))
  (dec-block)
  (setf *current-module* "")
  expr-list)

(defun parse-multiline-comment (expr-list)
  (if (not expr-list) (return-from parse-multiline-comment expr-list))
  (cond ((and (equal "|" (car expr-list)) (equal ";" (cadr expr-list)))
         (dbg "parse-multiline-comment: CLOSE")
         (return-from parse-multiline-comment (cddr expr-list)))
        ((stringp (car expr-list))
         (dbg "parse-multiline-comment: COMMENT >" (car expr-list) "<")
         (setf expr-list (parse-multiline-comment (cdr expr-list))))))

(defun parse-single-line-comment (expr-list)
  (if (not expr-list) (return-from parse-single-line-comment expr-list))
  (cond ((equal (format nil "~a" #\Newline) (car expr-list))
         (if (or (equal (format nil "~a" #\Newline) (cadr expr-list))
                 (equal ";" (cadr expr-list)))
             (setf expr-list (parse-single-line-comment (cdr expr-list)))
             (setf expr-list (cdr expr-list)))
         (return-from parse-single-line-comment expr-list))
        ((not (equal (format nil "~a" #\Newline) (car expr-list)))
         (dbg "parse-singleline-comment: COMMENT " (car expr-list))
         (setf expr-list (parse-single-line-comment (cdr expr-list))))))

(defun parse-null (expr-list)
  (cond ((equal "}" (car expr-list))
         (add-code (car expr-list))
         (return-from parse-null (cdr expr-list)))
        ((not (equal "}" (car expr-list)))
         (dbg "parse-null: " (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-null (cdr expr-list))))))

(defun parse-cstr (expr-list)
  (cond ((equal "\"" (car expr-list))
         (add-code "\"")
         (setf expr-list (cdr expr-list))
         (return-from parse-cstr expr-list))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (setf expr-list (parse-cstr (cdr expr-list)))))
  expr-list)

(defun parse-element (expr-list)
  (dbg "parse-element " (car expr-list))
  (cond ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", ")))
        ((stringp (car expr-list))
         (add-code (car expr-list))
         (if (and (not (equal "]" (cadr expr-list)))
                  (not (equal ")" (cadr expr-list))))
             (add-code ", "))))
  (cdr expr-list))
             
(defun parse-vector (expr-list)
  (dbg "parse-vector " (car expr-list))
  (cond ((equal "[" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-vector expr-list))))
        ((equal "]" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-vector expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-vector expr-list)))))
  expr-list)
  
(defun parse-list (expr-list)
  (dbg "parse-list " (car expr-list))
  (cond ((equal "'(" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-list expr-list))))
        ((equal ")" (car expr-list))
         (progn
           (setf expr-list (cdr expr-list))
           (return-from parse-list expr-list)))
        ((stringp (car expr-list))
         (progn
           (setf expr-list (parse-element expr-list))
           (setf expr-list (parse-list expr-list)))))
  expr-list)
  
(defun count-elements (expr-list)
  (let ((count 0)
        (parens 0))
    (loop for x from 0 to (1- (length expr-list)) do
         (if (or (equal "(" (elt expr-list x))
                 (equal "[" (elt expr-list x)))
             (progn
               (if (= parens 0)
                   (setf count (1+ count)))
               (setf parens (1+ parens))))
         (if (or (equal ")" (elt expr-list x))
                 (equal "]" (elt expr-list x)))
             (progn
               (setf parens (1- parens))
               (if (< parens 0)
                   (return-from count-elements count))))
         (if (and (not (equal "(" (elt expr-list x)))
                  (not (equal ")" (elt expr-list x))))
             (progn
               (if (= parens 0)
                   (setf count (1+ count))))))
    count))

(defun compose-iter-composition-type (expr-list)
  (let* ((split (split ">>" (car expr-list)))
         (lst (cdr (reverse (cdr (reverse split)))))
         (struct-type (gethash (get-iter-variable-name (car split)) *variable-type*))
         (struct-name (get-iter-composition-name (format nil "~a" struct-type)))
         (var-name (cadr split))
         (count 2)
         (composition (format nil "~a>>~a" struct-name var-name)))
    (if (= (length split) 2)
        (progn
          (dbg "compose-iter-composition-type: composition " composition)
          (return-from compose-iter-composition-type (gethash composition *variable-type*))))
    (loop for sub-name in lst do
         (dbg "get-iter-composition: sub-name " sub-name)
         (dbg "get-iter-composition: composition " composition)
         (setf struct-type
               (gethash composition *variable-type*))
         (dbg "compose-iter-composition-type: struct-type " struct-type)
         (setf struct-name (get-iter-composition-name (format nil "~a" struct-type)))
         (dbg "compose-iter-composition-type: struct-name " struct-name)
         (setf var-name (elt split count))
         (dbg "compose-iter-composition-type: var-name " var-name)
         (setf count (1+ count))
         (setf composition (format nil "~a>>~a" struct-name var-name))
         (dbg "compose-iter-composition-type: composition " composition))
    (gethash composition *variable-type*)))

(defun build-dotted-type (composition)
  (let* ((split (split ">>" composition))
         (lst (cdr split))
         (var-name (elt split 0))
         (str nil))
    (setf str (concatenate 'string (get-iter-variable-name var-name)))
    (loop for sub-name in lst do
         (setf str (concatenate 'string str "." sub-name)))
    (dbg "build-dotted-type " str)
    str))

(defun lisp-to-next-type (token)
  (let ((type (string-downcase (format nil "~a" token)))
        (type-str))
    (if token
        (progn
          (cond ((equal type "boolean")
                 (setq type-str "bool"))
                ((equal type "char")
                 (setq type-str "c8"))
                ((equal type "integer")
                 (setq type-str "i32"))
                ((equal type "fixnum")
                 (setq type-str "i64"))
                ((equal type "double-float")
                 (setq type-str "f64"))
                ((equal type "single-float")
                 (setq type-str "f32"))
                ((equal type "char-array")
                 (setq type-str "c8#"))
                ((equal type "string")
                 (setq type-str "string"))
                ((equal type "file")
                 (setq type-str "file"))
                ((equal type "boolean-array")
                 (setq type-str "bool#"))
                ((equal type "char-array")
                 (setq type-str "string"))
                ((equal type "integer-array")
                 (setq type-str "i32#"))
                ((equal type "fixnum-array")
                 (setq type-str "i64#"))
                ((equal type "double-float-array")
                 (setq type-str "f64#"))
                ((equal type "single-float-array")
                 (setq type-str "f32#"))
                ((equal type "boolean-pointer")
                 (setq type-str "bool>"))
                ((equal type "char-pointer")
                 (setq type-str "c8>"))
                ((equal type "integer-pointer")
                 (setq type-str "i32>"))
                ((equal type "double-float-pointer")
                 (setq type-str "f64>"))
                ((equal type "single-float-pointer")
                 (setq type-str "f32>"))))
        (setq type-str type))
    (dbg (format nil "lisp-to-next-type ~a" type))
    (dbg "lisp-to-next-type " type-str)
    type-str))

(defun get-literal-type (symbol-value)
  (progn
    (if (equal "\"" symbol-value)
        "string")))

(defun determine-type-of-symbol (expr-list)
  (let* ((symbol-value (car expr-list))
         (literal-type (get-literal-type symbol-value))
         (variable-type (get-iter-variable-type symbol-value))
         (number-type (type-of-number-string symbol-value))
         (inspect-type (lisp-to-next-type
                        (inspect-function-type expr-list)))
         (function-type (get-iter-function-type symbol-value))
         (type-str ""))
    (dbg "determine-type-of-symbol " symbol-value)
    (if literal-type
        (dbg "literal-type " literal-type))
    (if variable-type
        (dbg "variable-type " variable-type))
    (if number-type
        (dbg "number-type " (format nil "~a" number-type)))
    (if inspect-type
        (dbg "inspect-type " inspect-type))
    (if function-type
        (dbg "function-type " (format nil "~a" function-type)))
    (cond ((is-iter-composition-type-p expr-list)
           (dbg "get-type: composition found! "
                (compose-iter-composition-type expr-list))
           (setf type-str (compose-iter-composition-type expr-list))
           (dbg "get-type: var-type: " (format nil "~a" type-str)))
          ((is-type-p variable-type)
           (setf type-str variable-type))
          ((is-type-p inspect-type)
           (setf type-str inspect-type))
          ((is-type-p function-type)
           (setf type-str function-type))
          ((is-type-p number-type)
           (setf type-str number-type))
          ((is-type-p literal-type)
           (setf type-str literal-type))
          (t
           (setf type-str "void")))
;           (error-cant-infer-type symbol-value)))
    (dbg "determine-type-of-symbol: type-str " type-str)
    type-str))

(defun get-next-token-type-string (expr-list)
  (let ((type-str (determine-type-of-symbol expr-list)))
    (dbg "get-next-token-type-string: " type-str)
    ;; turn next-type into c-type-string
    (if (is-type-p type-str)
        (progn
          (cond ((search "cstring" type-str)
                 (setf type-str "cstring"))
                ((search "'" type-str)
                 (setf type-str (format nil "list_~a"
                                        (regex-replace "'" type-str ""))))
                ((search "#" type-str)
                 (setf type-str (format nil "array_~a"
                                        (regex-replace "#" type-str ""))))
                ((search ">>" type-str)
                 (setf type-str (format nil "handle_~a"
                                        (regex-replace ">>" type-str ""))))
                ((search ">" type-str)
                 (setf type-str (format nil "pointer_~a"
                                        (regex-replace ">" type-str "")))))))
    (dbg "get-next-token-type-string: type-str " type-str)
    type-str))

(defun is-type-p (cast)
  (dolist (type *types*)
    (if (equal type cast)
        (return-from is-type-p t))))

(defun is-previous-cast-p ()
  (dolist (type (mapcar #'(lambda (tp)
                            (regex-replace ">" tp "*")) *types*))
    (if (and (equal ")" (get-last-code))
             (equal type (get-previous-code)))
        (return-from is-previous-cast-p t)))
  nil)
                    
(defun parse-arguments (expr-list max)
  (dbg "parse-arguments: >" (car expr-list) "<")
  (cond ((equal "\"" (car expr-list))
         (if (and *paranteses*
                  (not (equal "(" (get-last-code)))
                  (not (equal "&" (get-last-code)))
                  (not (equal "*" (get-last-code)))
                  (not (is-previous-cast-p)))
             (add-code ","))
         (add-code "\"")
         (dbg "parse-arguments: parse-cstr >" (car expr-list) "<")
         (setf expr-list (parse-cstr (cdr expr-list)))
         (setf expr-list (parse-arguments expr-list max)))
        ((equal ")" (car expr-list))
         (let ((fn (get-current-function)))
           (dbg "parse-arguments: " (car expr-list) " function " fn)
           (dbg "parse-arguments: block " *block* " Parens " *paranteses*)
           (return-from parse-arguments expr-list)))
        ((equal "]" (car expr-list))
         (let ((fn (get-current-function)))
           (dbg "parse-arguments: " (car expr-list) " function " fn)
           (dbg "parse-arguments: block " *block* " Parens " *paranteses*)
           (return-from parse-arguments expr-list)))
        ((equal "," (car expr-list))
         (error-syntax-error expr-list))
        ((equal (format nil "~a" #\Newline) (car expr-list))
         (setf expr-list (parse-arguments (cdr expr-list) max)))
        ((equal "'" (car expr-list))
            (let ((type (get-next-token-type-string (cdddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-arguments: parse list literal ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (return-from parse-arguments expr-list)))
        ((equal "[" (car expr-list))
            (let ((type (get-next-token-type-string (cddr expr-list)))
                  (start (cdr expr-list)))
              (add-code (format nil "create_array_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-arguments: parse array literal ")
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (return-from parse-arguments expr-list)))
        ((equal "(" (car expr-list))
         (progn
           (if (and *paranteses*
                    (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (is-previous-cast-p)))
               (add-code ","))
           (dbg "parse-arguments: parse-expression ( block "
                *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t))
           (setf expr-list (parse-arguments expr-list
                                            (1- (count-elements expr-list))))))
        ((numberp (parse-integer (car expr-list) :junk-allowed t))
         (progn
           (dbg "parse-arguments: NUMBERP ")
           (if (and (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (equal "*" (get-last-code)))
                    (not (is-previous-cast-p)))
               (add-code ","))
           (progn
             ; convert lisp double-float to c double
             (setf (car expr-list) (regex-replace-all "d0" (car expr-list) "f"))
             (add-code (car expr-list))
             (setf expr-list (parse-arguments (cdr expr-list) max)))))
        ((or (is-variable-split-name-p (car expr-list))
             (is-iter-variable-p (car expr-list)))
         (let ((comp-name (build-dotted-type (car expr-list)))
               (var-name (regex-replace ">>.*" (car expr-list) "")))
           (if (and (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (equal "*" (get-last-code)))
                    (not (is-previous-cast-p)))
               (add-code ","))
           (dbg "parse-arguments: VARIABLE " (get-iter-variable-name var-name))
           (if (search ">>" (car expr-list))
               (add-code comp-name)
               (add-code (get-iter-variable-name var-name)))
           (setf expr-list (parse-arguments (cdr expr-list) max))
           (return-from parse-arguments expr-list)))
        ((is-iter-function-p (car expr-list))
         (let* ((fn-name (car expr-list))
                (fn-type (get-iter-function-args fn-name)))
           (dbg "parse-arguments: FN: " (get-iter-function-name fn-name))
           (if (and (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code)))
                    (not (equal "*" (get-last-code)))
                    (not (is-previous-cast-p)))
               (add-code ","))
           (if (is-function-map-p fn-name)
               (progn
                 (setf fn-name (get-iter-function-type
                                 (get-function-value fn-name)))
                 (add-code (format nil "~a_~a"
                                   (get-iter-function-name
                                    (get-function-value fn-name))
                                   fn-type))))
           (if (is-iter-function-p fn-name)
               (add-code (format nil "~a_~a"
                                 (get-iter-function-name
                                  (car expr-list))
                                 fn-type))
               (add-code (get-iter-function-name (car expr-list))))
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list max))
           (return-from parse-arguments expr-list)))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-arguments: VARIABLE not defined: "
              (get-iter-variable-name  (car expr-list))" block " *block*
              " hash " (hash-table-keys *variable-type*))
         (error-variable-not-defined expr-list (car expr-list))))
  expr-list)

(defun parse-infix (expr-list function)
  (if (equal ")" (car expr-list))
      (progn
        (dbg "parse-infix: parens ) parens " *paranteses* " block " *block*)
        (dbg "parse-infix: EXIT ")
        (return-from parse-infix expr-list)))
  (dbg "parse-infix: operand " (car expr-list))
  (setf expr-list (parse-expression expr-list t))
  (if (and (not (equal ")" (car expr-list)))
           (not (equal (format nil "~a" #\Newline) (car expr-list))))
      (progn
        (dbg "parse-infix: function " function)
        (add-code function)
        (setf expr-list (parse-infix expr-list function))))
  expr-list)

(defmacro parse-map (expr-list form &optional (max 1))
  `(progn
    (store-current-function ,form)
     (add-code ,form)
     (add-code "(")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defmacro parse-math (expr-list form &optional (max 1))
  `(let ((type (get-next-token-type-string (cdr ,expr-list))))
    (store-current-function ,form)
     (add-code (format nil "~a_~a" ,form type))
     (add-code "(")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defmacro parse-type-cast (expr-list current form &optional (max 1))
  `(progn
     (store-current-function ,current)
     (add-code "(")
     (add-code ,form)
     (add-code ")")
     (setf expr-list (parse-arguments (cdr ,expr-list) ,max))
     (return-from parse-call ,expr-list)))

(defun parse-call (expr-list)
  (cond ((equal ")" (car expr-list))
         (return-from parse-call (cdr expr-list)))
        ((equal "," (car expr-list))
         (error-syntax-error expr-list))
        ((equal (format nil "~a" #\Newline) (car expr-list))
         (dbg "parse-call: RET")
         (setf expr-list (parse-call (cdr expr-list))))
        ((or (equal "set" (car expr-list)) (equal "::" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "set")
           (if (or (is-iter-variable-p (cadr expr-list))
                   (is-iter-composition-type-p (cdr expr-list)))
               (progn
                 (add-code (format nil "set_pointer_~a" type))
                 (add-code "(")
                 (add-code "&"))
               (progn
                 (if (or (search "elt" (caddr expr-list)) (search "#" (caddr expr-list)))
                     (progn
                       (add-code (format nil "set_pointer_~a" type))
                       (add-code "("))
                     (progn
                       (add-code (format nil "set_~a" type))
                       (add-code "(")))))
           (dbg "parse-call: set Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((or (equal "elt" (car expr-list)) (equal "#" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "elt")
           (if (equal (cadr (gethash (get-last-function) *signatures*)) "value")
               (add-code "*"))
           (add-code (format nil "elt_~a" (regex-replace "pointer" type "array")))
           (add-code "(")
           (dbg "parse-call: elt Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list)
                                            (1- (count-elements expr-list))))))
         ((equal "prnfmt" (car expr-list))
          (store-current-function "prnfmt")
          (add-code "printf")
          (add-code "(")
          (dbg "parse-call: prnfmt Next arg " (cadr expr-list))
          (setf expr-list (cdr expr-list))
          (setf expr-list (parse-arguments expr-list *infinite-arguments*)))
        ((equal "prnl" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "prnl")
           (if (search "array" type)
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list)))))
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prnl Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prn" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "prn")
           (if (search "array" type)
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr expr-list)))))
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")))
           (dbg "parse-call: prn Next arg " (cadr expr-list))
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "prnstr" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "prnstr")
           (add-code (format nil "print_str_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))))
        ((equal "of" (car expr-list))
         (add-code "(")
         (if (equal "set" (get-current-function))
             (add-code "&"))
         (store-current-function "of")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-expression expr-list t))
         (add-code ".")
         (add-code (car expr-list))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "let" (car expr-list))
         (store-current-function "let")
         (inf "Compile let in block " *block*)
         (dbg "parse-call: LET INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-let (cdr expr-list))))
        ((or (equal "for" (car expr-list)) (equal "∑" (car expr-list)))
         (store-current-function "for")
         (inf "Compile for in block " *block*)          
         (dbg "parse-call: FOR INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-for (cdr expr-list))))
        ((equal "defn" (car expr-list))
         (store-current-function "defn")
         (setf *target* 'implementation)
         (dbg "parse-call: DEFN INC BLOCK " (car expr-list))
         (inf "Compile function '" (cadr expr-list) "'")
         (setf expr-list (parse-def-function (cdr expr-list)))
         (setf *target* 'code))
        ((equal "compose" (car expr-list))
         (setf *target* 'implementation)
         (store-current-function "compose")
         (dbg "parse-call: COMPOSE INC BLOCK " (car expr-list))
         (setf expr-list (parse-compose (cdr expr-list)))
         (setf *target* 'code))
        ((equal "return" (car expr-list))
         (store-current-function "return")
         (add-code "return")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "while" (car expr-list))
         (store-current-function "while")
         (add-code "while")
         (add-code "(")
         (dbg "parse-call: WHILE INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-while (cdr expr-list))))
        ((equal "if" (car expr-list))
         (store-current-function "if")
         (add-code "if")
         (add-code "(")
         (dbg "parse-call: IF INC BLOCK " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-if (cdr expr-list))))
        ((or (equal "mod" (car expr-list))
             (equal "%" (car expr-list)))
         (store-current-function "mod")
         (add-code "mod")
         (add-code "(")
         (dbg "parse-call: MOD block " *block* " PARENS " *paranteses*)
         (setf expr-list (parse-arguments (cdr expr-list) 2)))
        ((and (equal "<" (car expr-list)) (not (equal "<" (cadr expr-list))))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "lt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((and (equal "<" (car expr-list)) (equal "=" (cadr expr-list)))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (add-code (format nil "leqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cddr expr-list) 2))
           (return-from parse-call expr-list)))
        ((and (equal ">" (car expr-list)) (not (equal ">" (cadr expr-list))))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "gt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((and (equal ">" (car expr-list)) (equal "=" (cdar expr-list)))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (add-code (format nil "geqt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cddr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "!=" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "neq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "==" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (add-code (format nil "eq_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "add" (car expr-list)) (equal "+" (car expr-list)))
         (store-current-function "add")
         (dbg "parse-call: operator + ")
         (setf expr-list (cdr expr-list))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (get-iter-variable-name (car expr-list)))
               (setf expr-list (parse-infix expr-list "+")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "sub" (car expr-list)) (equal "-" (car expr-list)))
         (store-current-function "sub")
         (dbg "parse-call: operator - ")
         (setf expr-list (cdr expr-list))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "-")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "mul" (car expr-list)) (equal "*" (car expr-list)))
         (store-current-function "mul")
         (dbg "parse-call: operator * ")
         (setf expr-list (cdr expr-list))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "*")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "div" (car expr-list)) (equal "/" (car expr-list)))
         (store-current-function "div")
         (dbg "parse-call: operator / ")
         (setf expr-list (cdr expr-list))
         (add-code "(")
         (if (not (equal ")" (car expr-list)))
             (progn
               (dbg "parse-call: parse-infix notation " (car expr-list))
               (setf expr-list (parse-infix expr-list "/")))
             (error-operator-not-defined expr-list))
         (setf expr-list (parse-arguments expr-list
                                              (count-elements expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "sqrt" (car expr-list)) (equal "√" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "sqrt")
           (add-code (format nil "sqrt_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "fabs" (car expr-list))
           (store-current-function "fabs")
           (add-code (format nil "fabs_f64"))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list))
        ((or (equal "or" (car expr-list)) (equal "||" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "or")
           (add-code (format nil "or_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "and" (car expr-list)) (equal "&&" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "and")
           (add-code (format nil "and_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((or (equal "not" (car expr-list)) (equal "!" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "not")
           (add-code (format nil "not_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "atan" (car expr-list))
         (parse-math expr-list "atan"))
        ((equal "atan2" (car expr-list))
         (parse-math expr-list "atan2" 2))
        ((equal "acos" (car expr-list))
         (parse-math expr-list "acos"))
        ((equal "asin" (car expr-list))
         (parse-math expr-list "asin"))
        ((equal "asin2" (car expr-list))
         (parse-math expr-list "atan2"))
        ((equal "cos" (car expr-list))
         (parse-math expr-list "cos"))
        ((equal "cosh" (car expr-list))
         (parse-math expr-list "cosh"))
        ((equal "sin" (car expr-list))
         (parse-math expr-list "sin"))
        ((equal "sinh" (car expr-list))
         (parse-math expr-list "sinh"))
        ((equal "tanh" (car expr-list))
         (parse-math expr-list "tanh"))
        ((equal "exp" (car expr-list))
         (parse-math expr-list "exp"))
        ((equal "log" (car expr-list))
         (parse-math expr-list "log"))
        ((equal "log10" (car expr-list))
         (parse-math expr-list "log10"))
        ((equal "floor" (car expr-list))
         (parse-math expr-list "floor"))
        ((equal "ceil" (car expr-list))
         (parse-math expr-list "ceil"))
        ((equal "round" (car expr-list))
         (parse-math expr-list "round"))
        ((equal "fmod" (car expr-list))
         (parse-math expr-list "fmod" 2))
        ((equal "open" (car expr-list))
         (parse-map expr-list "open" 2))
        ((equal "read-line" (car expr-list))
         (parse-map expr-list "read_line" 1))
        ((equal "write-line" (car expr-list))
         (parse-map expr-list "write_line" 2))
        ((equal "read-binary" (car expr-list))
         (parse-map expr-list "read_binary" 4))
        ((equal "write-binary" (car expr-list))
         (parse-map expr-list "write_binary" 4))
        ((equal "close" (car expr-list))
         (parse-map expr-list "close" 1))
        ((equal "string-to-i32" (car expr-list))
         (parse-map expr-list "atoi" 1))
        ((equal "string-to-f32" (car expr-list))
         (parse-map expr-list "atof" 1))
        ((equal "trunc" (car expr-list))
         (parse-map expr-list "trunc" 1))
        ((or (equal "power" (car expr-list)) (equal "^" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "power")
           (add-code (format nil "power_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "max" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "max")
           (add-code (format nil "max_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "min" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "min")
           (add-code (format nil "min_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "module" (car expr-list))
         (store-current-function "module")
         (setf expr-list (parse-module (cdr expr-list)))
         (return-from parse-call expr-list))
        ((or (equal "len" (car expr-list)) (equal "@" (car expr-list)))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (store-current-function "size")
           (if (or (search "array" type)
                   (search "list" type)
                   (search "pointer" type))
               (add-code (format nil "length_~a" type))
               (if (search "string" type)
                   (add-code "sizeof")
                   (error-type-not-supported expr-list type)))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "equal" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (store-current-function "equal")
           (add-code (format nil "equal_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "map" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (store-current-function "map")
           (add-code (format nil "map_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "mapn" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (store-current-function "mapn")
           (add-code (format nil "mapn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "reduce" (car expr-list))
         (let ((type (get-next-token-type-string (cddr expr-list))))
           (store-current-function "reduce")
           (add-code (format nil "reduce_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "push" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "push")
           (add-code (format nil "push_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 2))
           (return-from parse-call expr-list)))
        ((equal "car" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "car")
           (add-code (format nil "car_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdr" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (store-current-function "cdr")
           (add-code (format nil "cdr_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "cdrn" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (store-current-function "cdrn")
           (add-code (format nil "cdrn_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "rev" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-only-lists-supported expr-list))
           (store-current-function "rev")
           (add-code (format nil "reverse_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "append" (car expr-list))
         (store-current-function "append")
         (let ((typea (get-next-token-type-string (cdr expr-list)))
               (typeb (get-next-token-type-string (cddr expr-list))))
           (if (and (not (search "list" typea))
                    (not (search "array" typea))
                    (not (search "pointer" typea)))
               (error-type-not-supported expr-list typea))
           (if (search "array" typeb)
               (add-code (format nil "append_array_~a" typeb)))
           (if (search "list" typeb)
               (add-code (format nil "append_list_~a" typeb)))
           (if (search "pointer" typeb)
               (add-code (format nil "append_pointer_~a" typeb)))
           (if (and (not (search "list" typeb))
                    (not (search "array" typeb))
                    (not (search "pointer" typeb)))
               (add-code (format nil "append_~a" typea)))
           (add-code "(")
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list 2))
           (return-from parse-call expr-list)))
        ((equal "size" (car expr-list))
         (store-current-function "size")
         (add-code "sizeof")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list) 1))
         (return-from parse-call expr-list))
        ((equal "remove" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "remove")
           (add-code (format nil "remove_~a" type))
           (add-code "(")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "pop" (car expr-list))
         (let ((type (get-next-token-type-string (cdr expr-list))))
           (if (not (search "list" type))
               (error-only-lists-supported expr-list))
           (store-current-function "pop")
           (add-code (format nil "pop_~a" type))
           (add-code "(")
           (add-code "&")
           (setf expr-list (parse-arguments (cdr expr-list) 1))
           (return-from parse-call expr-list)))
        ((equal "break" (car expr-list))
         (add-code "break")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "continue" (car expr-list))
         (add-code "continue")
         (add-code (format nil ";~%"))
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (add-code "destroy_ptr")
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (cdr expr-list))
         (return-from parse-call expr-list))
        ((equal "bool" (car expr-list))
         (parse-type-cast expr-list "bool" "bool"))
        ((equal "b8" (car expr-list))
         (parse-type-cast expr-list "b8" "b8"))
        ((equal "c8" (car expr-list))
         (parse-type-cast expr-list "c8" "c8"))
        ((equal "i16" (car expr-list))
         (parse-type-cast expr-list "i16" "i16"))
        ((equal "i32" (car expr-list))
         (parse-type-cast expr-list "i32" "i32"))
        ((equal "i64" (car expr-list))
         (parse-type-cast expr-list "i64" "i64"))
        ((equal "ui16" (car expr-list))
         (parse-type-cast expr-list "ui16" "ui16"))
        ((equal "ui32" (car expr-list))
         (parse-type-cast expr-list "ui32" "ui32"))
        ((equal "ui64" (car expr-list))
         (parse-type-cast expr-list "ui64" "ui64"))
        ((equal "f32" (car expr-list))
         (parse-type-cast expr-list "f32" "f32"))
        ((equal "f64" (car expr-list))
         (parse-type-cast expr-list "f64" "f64"))
        ((equal "f80" (car expr-list))
         (parse-type-cast expr-list "f80" "f80"))
        ((equal "string" (car expr-list))
         (parse-type-cast expr-list "string" "string"))
        ((equal "cstring" (car expr-list))
         (parse-type-cast expr-list "cstring" "cstring"))
        ((equal "file" (car expr-list))
         (parse-type-cast expr-list "file" "file"))
        ((equal "bool>" (car expr-list))
         (parse-type-cast expr-list "bool>" "bool*"))
        ((equal "b8>" (car expr-list))
         (parse-type-cast expr-list "b8>" "b8*"))
        ((equal "c8>" (car expr-list))
         (parse-type-cast expr-list "c8>" "c8*"))
        ((equal "i16>" (car expr-list))
         (parse-type-cast expr-list "i16>" "i16*"))
        ((equal "i32>" (car expr-list))
         (parse-type-cast expr-list "i32>" "i32*"))
        ((equal "i64>" (car expr-list))
         (parse-type-cast expr-list "i64>" "i64*"))
        ((equal "ui16>" (car expr-list))
         (parse-type-cast expr-list "ui16>" "ui16*"))
        ((equal "ui32>" (car expr-list))
         (parse-type-cast expr-list "ui32>" "ui32*"))
        ((equal "ui64>" (car expr-list))
         (parse-type-cast expr-list "ui64>" "ui64*"))
        ((equal "f32>" (car expr-list))
         (parse-type-cast expr-list "f32>" "f32*"))
        ((equal "f64>" (car expr-list))
         (parse-type-cast expr-list "f64>" "f64*"))
        ((equal "f80>" (car expr-list))
         (parse-type-cast expr-list "f80>" "f80*"))
        ((equal "string>" (car expr-list))
         (parse-type-cast expr-list "string>" "string*"))
        ((equal "cstring>" (car expr-list))
         (parse-type-cast expr-list "cstring>" "cstring*"))
        ((equal "file>" (car expr-list))
         (parse-type-cast expr-list "file>" "file*"))
        ((equal "bool>>" (car expr-list))
         (parse-type-cast expr-list "bool>>" "bool**"))
        ((equal "b8>>" (car expr-list))
         (parse-type-cast expr-list "b8>>" "b8**"))
        ((equal "c8>>" (car expr-list))
         (parse-type-cast expr-list "c8>>" "c8**"))
        ((equal "i16>>" (car expr-list))
         (parse-type-cast expr-list "i16>>" "i16**"))
        ((equal "i32>>" (car expr-list))
         (parse-type-cast expr-list "i32>>" "i32**"))
        ((equal "i64>>" (car expr-list))
         (parse-type-cast expr-list "i64>>" "i64**"))
        ((equal "ui16>>" (car expr-list))
         (parse-type-cast expr-list "ui16>>" "ui16**"))
        ((equal "ui32>>" (car expr-list))
         (parse-type-cast expr-list "ui32>>" "ui32**"))
        ((equal "ui64>>" (car expr-list))
         (parse-type-cast expr-list "ui64>>" "ui64**"))
        ((equal "f32>>" (car expr-list))
         (parse-type-cast expr-list "f32>>" "f32**"))
        ((equal "f64>>" (car expr-list))
         (parse-type-cast expr-list "f64>>" "f64**"))
        ((equal "f80>>" (car expr-list))
         (parse-type-cast expr-list "f80>>" "f80**"))
        ((equal "string>>" (car expr-list))
         (parse-type-cast expr-list "string>>" "string**"))
        ((equal "cstring>>" (car expr-list))
         (parse-type-cast expr-list "cstring>>" "cstring**"))
        ((equal "file>>" (car expr-list))
         (parse-type-cast expr-list "file>>" "file**"))
        ((or (equal "?" (car expr-list)) (equal "deref" (car expr-list)))
         (store-current-function "deref")
         (add-code (format nil "("))
         (add-code (format nil "*"))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((or (equal "&" (car expr-list)) (equal "ref" (car expr-list)))
         (store-current-function "ref")
         (add-code (format nil "("))
         (add-code (format nil "&"))
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "del" (car expr-list))
         (store-current-function "del")
         (add-code (format nil "delete_ptr"))
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "destroy" (car expr-list))
         (store-current-function "destroy")
         (add-code (format nil "destroy_ptr"))
         (add-code "(")
         (add-code "pointer_list")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 0))
         (return-from parse-call expr-list))
        ((equal "new" (car expr-list))
         (if (not (search ">" *current-let-definition*))
             (error-type-not-supported expr-list *current-let-definition*))
         (let ((type (regex-replace ">" *current-let-definition* "")))
           (store-current-function "new")
           (add-code (format nil "new_~a" type))
           (add-code "(")
           (setf expr-list (cdr expr-list))
           (setf expr-list (parse-arguments expr-list 1))
           (return-from parse-call expr-list)))
        ((equal "new_bool" (car expr-list))
         (store-current-function "new_bool")
         (add-code "new_bool")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_c8" (car expr-list))
         (store-current-function "new_c8")
         (add-code "new_c8")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_b8" (car expr-list))
         (store-current-function "new_b8")
         (add-code "new_b8")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_i16" (car expr-list))
         (store-current-function "new_16")
         (add-code "new_i16")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_i32" (car expr-list))
         (store-current-function "new_i32")
         (add-code "new_i32")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_i64" (car expr-list))
         (store-current-function "new_i64")
         (add-code "new_i64")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_ui16" (car expr-list))
         (store-current-function "new_u16")
         (add-code "new_ui16")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_ui32" (car expr-list))
         (store-current-function "new_ui32")
         (add-code "new_ui32")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_ui64" (car expr-list))
         (store-current-function "new_ui64")
         (add-code "new_ui64")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_f32" (car expr-list))
         (store-current-function "new_f32")
         (add-code "new_f32")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_f64" (car expr-list))
         (store-current-function "new_f64")
         (add-code "new_f64")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "new_f80" (car expr-list))
         (store-current-function "new_f80")
         (add-code "new_f80")
         (add-code "(")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-arguments expr-list 1))
         (return-from parse-call expr-list))
        ((equal "defp" (car expr-list))
         (setf *target* 'implementation)
         (store-current-function "defp")
         (add-code "static")
         (add-code " ")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-variable expr-list))
         (setf *target* 'code)
         (return-from parse-call expr-list))
        ((equal "defv" (car expr-list))
         (setf *target* 'implementation)
         (store-current-function "defv")
         (add-code "volatile")
         (add-code " ")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-variable expr-list))
         (setf *target* 'code)
         (return-from parse-call expr-list))
        ((equal "defr" (car expr-list))
         (store-current-function "defr")
         (add-code "register")
         (add-code " ")
         (setf expr-list (cdr expr-list))
         (setf expr-list (parse-variable expr-list))
         (return-from parse-call expr-list))
        ((or (equal "shitfl" (car expr-list))
          (and (equal "<" (car expr-list)) (equal "<" (cadr expr-list))))
         (store-current-function "shiftl")
         (if (equal "shitfl" (car expr-list))
             (setf expr-list (cdr expr-list))
             (setf expr-list (cddr expr-list)))
         (setf expr-list (parse-expression expr-list t))
         (add-code "<<")
         (setf expr-list (parse-expression expr-list t))
         (return-from parse-call expr-list))
        ((or (equal "shitfr" (car expr-list))
          (and (equal ">>" (car expr-list)) (equal ">>" (cadr expr-list))))
         (store-current-function "shiftr")
         (if (equal "shitfl" (car expr-list))
             (setf expr-list (cdr expr-list))
             (setf expr-list (cddr expr-list)))
         (setf expr-list (parse-expression expr-list t))
         (add-code ">>")
         (setf expr-list (parse-expression expr-list t))
         (return-from parse-call expr-list))
        ((is-iter-function-p (car expr-list))
         (let* ((fn-name (car expr-list))
                (fn-type (get-next-token-type-string (cdr expr-list))))
           (dbg "parse-call: FN: " (get-iter-function-name fn-name))
            (if (is-function-map-p fn-name)
               (progn
                 (setf fn-name (get-iter-function-type
                                 (get-function-value fn-name)))
                 (add-code (format nil "~a_~a"
                                   (get-iter-function-name
                                    (get-function-value fn-name))
                                   fn-type)))
               (add-code (format nil "~a_~a"
                                 (get-iter-function-name
                                  (car expr-list))
                                 fn-type)))
            (add-code "(")
            (setf expr-list (cdr expr-list))
            (setf expr-list (parse-arguments expr-list *infinite-arguments*))))
        ((is-iter-variable-p (car expr-list))
         (dbg "parse-call: FN emit: " (get-function-name (car expr-list)))
         (add-code "(")
         (add-code "*")
         (add-code (get-function-name (car expr-list)))
         (add-code ")")
         (add-code "(")
         (setf expr-list (parse-arguments (cdr expr-list)
                                          *infinite-arguments*)))
        ((not (equal "(" (car expr-list)))
         (dbg "parse-call: FN not defined: " (get-iter-function-name (car expr-list)))
         (error-function-not-defined expr-list))
        ((equal "(" (car expr-list))
         (progn
           (dbg "parse-call: CALL OPEN ( block " *block* " Parens " *paranteses*)
           (setf expr-list (parse-expression expr-list t)))))
   expr-list)

(defun is-variable-split-name-p (expression)
  (let ((split (split ">>" expression)))
    (remove-if-not
     #'(lambda (x)
         (equal x (get-iter-variable-name (car split))))
     (hash-table-keys *variable-type*))))

(defun parse-expression (expr-list &optional (omit nil))
  (if expr-list
      (progn
        (dbg "parse-expression: enter " (car expr-list))
        (loop while (equal (format nil "~a" #\Newline) (car expr-list)) do
             (setf expr-list (cdr expr-list)))
        (if (not expr-list)
            (return-from parse-expression expr-list))
        (if (equal "," (car expr-list))
            (error-syntax-error expr-list))        
        (if (equal "EOF" (car expr-list))
            (add-code "EOF"))
        (if (equal ")" (car expr-list))
            (error-too-many-parens expr-list))
        (if (equal "\"" (car expr-list))
            (progn
              (dbg "parse-expression: STRING block " *block*)
              (add-code "\"")
              (setf expr-list (parse-cstr (cdr expr-list)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: STRING END ")
              (return-from parse-expression expr-list)))
        (if (and (equal ";" (car expr-list)) (equal "|" (cadr expr-list)))
            (progn
              (dbg "parse-expression: parse multiline comment")
              (setf expr-list (parse-multiline-comment (cddr expr-list)))
              (return-from parse-expression expr-list)))
        (if (equal ";" (car expr-list))
            (progn
              (dbg "parse-expression: parse singleiline comment")
              (setf expr-list (parse-single-line-comment expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "{" (car expr-list))
            (progn
              (dbg "parse-expression: parse null")
              (setf expr-list (parse-null expr-list))
                (if (not omit)
                  (add-code (format nil ";~%")))
            (return-from parse-expression expr-list)))
        (if (equal "[" (car expr-list))
            (progn
              (dbg "parse-expression: parse vector " (car expr-list))
              (add-code "{")
              (dbg "parse-expression: parse vector literal ")
              (setf expr-list (parse-vector (cdr expr-list)))
              (add-code (format nil "}"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (equal "'" (car expr-list))
            (let ((type (get-next-token-type-string (cdddr expr-list)))
                  (start (cddr expr-list)))
              (add-code (format nil "create_list_~a" type))
              (add-code "(")
              (add-code "(")
              (add-code type)
              (add-code "[]")
              (add-code ")")
              (add-code "{")
              (dbg "parse-expression: parse list literal ")
              (setf expr-list (parse-list (cddr expr-list)))
              (add-code (format nil "}"))
              (add-code ",")
              (add-code (format nil "~a" (count-elements start)))
              (add-code (format nil ")"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression expr-list)))
        (if (numberp (parse-integer (car expr-list) :junk-allowed t))
            (progn
              (dbg "parse-expression: NUM block " *block*
                   " number " (car expr-list))
              (add-code (car expr-list))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression (cdr expr-list))))
        (if (or (is-variable-split-name-p (car expr-list))
                (is-iter-variable-p (car expr-list)))
            (let ((comp-name (build-dotted-type (car expr-list)))
                  (var-name (regex-replace ">>.*" (car expr-list) "")))
              (dbg "parse-expression: VARIABLE "
                   (get-iter-variable-name var-name))
              (if (and (equal "let" (get-current-function))
                       (search ">" *current-let-definition*))
                  (add-code "&"))
              (if (search ">>" (car expr-list))
                  (add-code comp-name)
                  (add-code (get-iter-variable-name var-name)))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: VAR END " var-name)
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (is-iter-function-p (car expr-list))
         (let* ((fn-name (car expr-list))
                (fn-type (get-iter-function-args fn-name)))
           (dbg "parse-expression: FN: " (get-iter-function-name fn-name))
           (if (is-function-map-p fn-name)
               (progn
                 (add-code (format nil "~a_~a"
                                   (get-iter-function-name
                                    (get-function-value fn-name))
                                   fn-type))))
           (if (is-iter-function-p fn-name)
               (add-code (format nil "~a_~a"
                                 (get-iter-function-name
                                  (car expr-list))
                                 fn-type))
               (add-code (get-iter-function-name (car expr-list))))
           (if (not omit)
               (add-code (format nil ";~%")))
           (setf expr-list (cdr expr-list))
           (return-from parse-expression expr-list)))
        (if (not (or (equal "," (car expr-list))
                     (equal (format nil "~a" #\Newline) (car expr-list))
                     (equal "(" (car expr-list))
                     (equal ")" (car expr-list))
                     (equal "[" (car expr-list))
                     (equal "]" (car expr-list))
                     (equal "\"" (car expr-list))
                     (equal ";|" (car expr-list))
                     (equal "|;" (car expr-list))
                     (equal ";" (car expr-list))
                     (numberp (parse-integer (car expr-list) :junk-allowed t))))
            (progn
              (dbg "parse-expression: SYMBOL " (car expr-list))
              (setf expr-list (cdr expr-list))
              (return-from parse-expression expr-list)))
        (if (equal "(" (car expr-list))
            (let ((space nil)
                  (no-parens nil))
              ;; parse-open-parens
              (setf expr-list (parse-open-parens expr-list))
              (inc-parens)
              (dbg "parse-expression: OPEN parens "
                   *paranteses* " block " *block*)
              ;; omit semicolon for blocks
              (if (or (equal "for" (car expr-list))
                      (equal "if" (car expr-list))
                      (equal "while" (car expr-list))
                      (equal "defn" (car expr-list))
                      (equal "defp" (car expr-list))
                      (equal "defv" (car expr-list))
                      (equal "defr" (car expr-list))
                      (equal "let" (car expr-list))
                      (equal "compose" (car expr-list))
                      (equal "module" (car expr-list))
                      (equal "break" (car expr-list))
                      (equal "continue" (car expr-list))
                      (equal "shiftl" (car expr-list))
                      (equal "shiftr" (car expr-list))
                      (and (equal ">" (car expr-list))
                           (equal ">" (cadr expr-list)))
                      (and (equal "<" (car expr-list))
                           (equal "<" (cadr expr-list)))
                      (equal "i16" (car expr-list)))
                  (setf space t))
              (if (is-type-p (car expr-list))
                  (setf no-parens t))
              ;; parse-call
              (setf expr-list (parse-call expr-list))
              (dbg "parse-expression: CALL END rest " (car expr-list)
                   " parens " *paranteses* " block " *block*)
              (dbg "parse-expression: CLOSE parens " *paranteses* " block " *block*
                   " omit " omit)
              (if (car expr-list)
                  (setf expr-list (parse-close-parens expr-list)))
              (if (and (not space) (not no-parens))
                  (add-code ")"))
              (dec-parens)
              (if (and (not space) (not omit))
                  (add-code (format nil ";~%")))
              ;; exit
              (return-from parse-expression expr-list)))
        (if (equal (format nil "~a" #\Newline) (car expr-list))
            (progn
              (setf expr-list (cdr expr-list))
              (dbg "parse-expression: caught \n")
              (return-from parse-expression expr-list))))))
  
(defun parse (expression)
  "Parse expression."
  (dbg "parse: preprocess")
  (let ((expr-list (preprocess expression)))
    (dbg "parse: setup hashtables")
    (setf *code_list* '(""))
    (setf *implementation_list* '(""))
    (setf *definition_list* '(""))
    (setf *paranteses* 0)
    (setf  *block* 0)
    (setf *function-args* (make-hash-table :test 'equal))
    (setf *function-type* (make-hash-table :test 'equal))
    (setf *variable-type* (make-hash-table :test 'equal))
    (setf *variables* (make-hash-table :test 'equal))
    (setf *compositions* (make-hash-table :test 'equal))
    (setf *functions* (make-hash-table :test 'equal))
    (setf *function-map* (make-hash-table :test 'equal))
    (setf *signatures* (make-hash-table :test 'equal))
    (setf *current-function* (make-hash-table :test 'equal))
    (dbg "parse: setup-signatures")
    (setup-signatures)
    (dbg "parse: parse-expressions")
    (loop while (> (length expr-list) 0) do
         (setf expr-list (parse-expression expr-list))))
  (emit-code-call))
