;;; -----------------------------------------------------
;;; next - parser file
;;; -----------------------------------------------------
;;; File:     src/parser.lisp
;;; Date:     09:29:15 of Wednesday, 8/14/2019 (GMT+1)
;;; Author:   Edward Puccini
;;; -----------------------------------------------------

(in-package :next)

(require 'parse-float)

(defvar *code_list* '(""))
(defvar *definition_list* '(""))
(defvar *implementation_list* '(""))
(defvar *target* 'code)
(defvar *paranteses* 0)
(defvar *variables* nil)
(defvar *functions* nil)
(defvar *signatures* nil)
(defvar *function-map* nil)
(defvar *current-function* nil)
(defvar *current-let-definition* nil)
(defvar *current-module* "")
(defvar *arguments* 0)
(defvar *block* 0)
(defvar *generics-template* "")
(defvar *def-template* "")
(defvar *impl-template* "")
(defvar *is-main-defined* nil)
(defvar *infinite-arguments* 10000)
(defvar *expr-list*)

(defun load-templates ()
  (setf *def-template* (load-binary-data "../templates/code.h"))
  (setf *impl-template* (load-binary-data "../templates/code.c"))
  (setf *generics-template* (load-binary-data "../templates/generics.h")))

(defun is-main-defined-p ()
  *is-main-defined*)

(defun filter-expression (expression)
  (let* ((new-expr1 (regex-replace-all "-" expression "_"))
         (new-expr2 (regex-replace-all "\\√" new-expr1 "sqrt"))
         (new-expr3 (regex-replace-all "\\^" new-expr2 "power"))
         (new-expr4 (regex-replace-all "∑" new-expr3 "for"))
         (new-expr5 (regex-replace-all ">>" new-expr3 "__")))
    new-expr5))

(defun print-stack ()
  "Use swank to log a stack-trace."
  (let ((trace ""))
    (let* ((msg-lst (remove-if #'null
                               (swank-backend:call-with-debugging-environment
                                (lambda () (swank:backtrace 0 7)))))
           (stack-msg
            (progn
              (mapcar (lambda (msg)
                        (setf trace (concatenate 'string trace 
                                                   (format nil "~{~A ~}~%" msg))))
                      msg-lst) trace)))
      (print stack-msg))))

(defun error-msg (msg)
  (format t msg)
  (print-stack)
  (emit-code-call)
  (sb-ext:quit))

(defun error-parameter-max (cnt max)
  (error-msg (format nil "Error too many parameter to function (~a). Only ~a parameter expected!~%"
            cnt max)))

(defun error-operator-not-defined ()
  (error-msg "Error no operator defined!~%"))

(defun error-no-type-def ()
  (error-msg "Error no variable and type defined!~%"))

(defun error-function-not-defined ()
  (error-msg "Error function not defined!~%"))

(defun error-missing-expression ()
  (error-msg "Error missing expression!~%"))

(defun error-function-type-unkown (type)
  (error-msg (format nil "Error function type ~a unkown!~%" type)))

(defun error-syntax-error ()
  (error-msg "Error syntax error!~%"))

(defun error-missing-open-square-bracket ()
  (error-msg "Error missing square bracket!~%"))

(defun error-missing-open-parens ()
  (error-msg "Error missing open parens!~%"))

(defun error-missing-close-square-bracket ()
  (error-msg "Error missing square bracket!~%"))

(defun error-missing-close-parens ()
  (error-msg "Error missing close parens!~%"))

(defun error-variable-not-defined ()
  (error-msg "Error variable not defined!~%"))

(defun error-function-vector-malformed ()
  (error-msg "Error function vector malformed!~%"))

(defun error-let-vector-malformed ()
  (error-msg "Error let vector malformed!~%"))

(defun error-cant-infer-type ()
  (error-msg "Error cant determine type!~%"))

(defun error-only-lists-supported ()
  (error-msg "Error only lists supported!~%"))

(defun error-type-not-supported ()
  (error-msg "Error type not supported!~%"))

(defun upto-string (expression lower)
  (let ((str ""))
    (loop for x from lower to (1- (length expression)) do
         (if (equal #\" (elt expression x))
             (return-from upto-string str))
         (if (not (equal #\" (elt expression x)))
             (setf str (format nil "~a~a" str (elt expression x)))))
  str))

(defun upto-symbol (expression lower)
  (let ((str "")
        (stack '()))
    (loop for x from lower to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((equal #\" obj)
                  (return-from upto-symbol stack))
                 ((equal #\$ obj)
                  (push "$" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\; obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\( obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                ((equal #\) obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\[ obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\] obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\% obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\& obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\, obj)
                  (push (format nil "~a" obj) stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Newline obj)
                  (push "\n" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Return obj)
                  (push "\n" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Linefeed obj)
                  (push "\n" stack)
                  (push str stack)
                  (return-from upto-symbol stack))
                 ((equal #\Space obj)
                  (push str stack)
                  (return-from upto-symbol stack))
                 (t
                  (setf str (format nil "~a~a" str obj))))))
    (push str stack)))

(defun stack-length (stack)
  (let ((l 0))
    (mapcar #'(lambda (x) (setf l (+ l (length x))))
            stack)
    l))

(defun preprocess (expr)
  (let ((stack '())
        (expression (regex-replace-all "->" expr "$")))
    (loop for x from 0 to (1- (length expression)) do
         (let ((obj (elt expression x)))
           (cond ((or (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\% obj)
                      (equal #\& obj)
                      (equal #\, obj)
                      (equal #\; obj)
                      (equal #\< obj)
                      (equal #\> obj)
                      (equal #\( obj)
                      (equal #\) obj)
                      (equal #\[ obj)
                      (equal #\] obj)
                      (equal #\{ obj)
                      (equal #\} obj)
                      (equal #\# obj))
                  (push (format nil "~a" obj) stack))
                 ((equal #\∑ obj)
                  (push "∑" stack))
                 ((equal #\, obj)
                  (push "," stack))
                 ((equal #\Space obj)
                  (format nil " "))
                 ((equal #\Newline obj)
                  (push "\n" stack))
                 ((equal #\Return obj)
                  (push "\n" stack))
                 ((equal #\Linefeed obj)
                  (push "\n" stack))
                 ((equal #\Tab obj)
                  (format nil " "))
                 ((equal #\" obj)
                  (let ((str (upto-string expression (1+ x))))
                    (setf x (+ x 1 (length str)))
                    (push "\"" stack)
                    (push str stack)
                    (push "\"" stack)))
                 (t
                  (let ((inner-stack (upto-symbol expression x)))
                    (setf stack (append (reverse inner-stack) stack))
                    (setf x (+ x (1- (stack-length inner-stack)))))))))
    (reverse stack)))

(defun emit-code-call ()
  (let ((code "")
        (definition "")
        (implementation "")
        (pointers ""))
    (if *implementation_list*
        (format t "~%~{~a~}~%" *implementation_list*))
    (if *code_list*
        (format t "~%~{~a~}~%" *code_list*))
    (if *implementation_list*
        (setf implementation
              (format nil "~%~{~a~}~%" *implementation_list*)))
    (if *code_list*
        (progn
          (if (not (is-main-defined-p))
              (setf code (format nil "i32 main () ~%{~%~%~{~a~}~%" *code_list*))
              (setf code (format nil "~%~%~{~a~}~%" *code_list*)))))
    (if (not (is-main-defined-p))
        (setf code (format nil "~a~%destroy_ptr(pointer_list);~%return 0;~%}" code)))
    (values code definition implementation)))

(defun get-current-function ()
  (gethash *paranteses* *current-function*))

(defun get-last-function ()
  (gethash (1- *paranteses*) *current-function*))

(defun store-current-function (fun)
  (setf (gethash *paranteses* *current-function*) fun))

(defun get-variable-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-function-name (name)
  (if (equal *current-module* "")
      (format nil "~a_~a" (filter-expression name) *block*)
      (format nil "~a__~a_~a" *current-module* (filter-expression name) *block*)))

(defun get-iter-variable-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *variables*)
              (progn
                (return-from get-iter-variable-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-variable-name-x name cnt)))))))

(defun get-iter-variable-name (name)
  (get-iter-variable-name-x name *block*))

(defun get-iter-function-name-x (name cnt)
  (let ((hash  ""))
    (if (>= cnt 0)
        (progn
          (if (equal *current-module* "")
              (setf hash (format nil "~a_~a" (filter-expression name) cnt))
              (setf hash (format nil "~a__~a_~a" *current-module*
                                 (filter-expression name) cnt)))
          (if (gethash hash *functions*)
              (progn
                (return-from get-iter-function-name-x hash))
              (progn
                (setf cnt (- cnt 1))
                (get-iter-function-name-x name cnt)))))))

(defun get-iter-function-name (name)
  (get-iter-function-name-x name *block*))

(defun set-signature (name signature)
  (setf (gethash name *signatures*) signature))

(defun append-signature (name signature)
  (setf (gethash name *signatures*)
        (append (gethash name *signatures*) (list signature))))

(defun inc-parens ()
  (setq *paranteses* (1+ *paranteses*)))

(defun dec-parens ()
  (setq *paranteses* (1- *paranteses*)))

(defun inc-block ()
  (setq *block* (+ 1 *block*))
  (zero-hash-variables))

(defun dec-block ()
  (zero-hash-variables)
  (setq *block* (- *block* 1)))

(defun zero-parens ()
  (setq *paranteses* 0))

(defun zero-block ()
  (setq *block* 0))

(defun zero-hash-variables ()
  (mapcar #'(lambda (var)
              (setf (gethash (get-variable-name var) *variables*) nil) var)
          (hash-table-keys *variables*)))

(defun dec-arg ()
  (if (>= *paranteses* 0)
      (setf (gethash *paranteses* *arguments*)
            (1- (gethash *paranteses* *arguments*)))
      (if (not (gethash *paranteses* *arguments*))
          (setf (gethash *paranteses* *arguments*) 0))))

(defun inc-arg ()
  (if (not (gethash *paranteses* *arguments*))
      (setf (gethash *paranteses* *arguments*) 0))
  (setf (gethash *paranteses* *arguments*)
        (1+ (gethash *paranteses* *arguments*))))

(defun set-arg (value)
  (setf (gethash *paranteses* *arguments*) value))

(defun get-arg ()
  (gethash *paranteses* *arguments*))

(defun zero-arg ()
  (set-arg 0))

(defun add-code (expression)
  ;(setf expression (filter-expression expression))
  (if expression
      (cond ((equal *target* 'code)
             (setf *code_list* (append *code_list* (list expression))))
            ((equal *target* 'implementation)
             (setf *implementation_list* (append *implementation_list*
                                                 (list expression))))
            ((equal *target* 'definition)
             (setf *definition_list* (append *definition_list*
                                             (list expression)))))))

(defun get-last-code ()
  (cond ((equal *target* 'code)
         (car (reverse *code_list*)))
        ((equal *target* 'implementation)
         (car (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (car (reverse *definition_list*)))))

(defun get-previous-code ()
  (cond ((equal *target* 'code)
         (cadr (reverse *code_list*)))
        ((equal *target* 'implementation)
         (cadr (reverse  *implementation_list*)))
        ((equal *target* 'definition)
         (cadr (reverse *definition_list*)))))

(defun get-function-value (fn-name)
  (gethash fn-name *function-map*))

(defun set-function-map (fn-name value)
  (setf (gethash fn-name *function-map*) value))

(defun is-function-map-p (fn-name)
  (remove-if-not #'(lambda (fn) (equal fn fn-name)) (hash-table-keys *function-map*)))

(defun register-function (name content)
  (set-function-map name content)
  (setf (gethash (get-function-name name) *functions*) 'function)
  (dbg "register-function: Register function >" name
       "< var >" content "<"))

(defun emit-named-function-call (sym-name fn-name)
  (add-code (format nil "if(strcmp(~a, \"~a\") == 0)"
                    (get-iter-variable-name sym-name) fn-name))
  (add-code fn-name)
  (add-code "("))
  
(defun type-of-number-string (numstr)
  (cond ((and
          (typep (parse-integer numstr :junk-allowed t) 'integer)
          (not (find #\. numstr))) 'integer)
        ((search "d0" numstr)
         'double-float)
        ((typep (parse-float numstr
                             :junk-allowed t
                             :type 'single-float) 'single-float)
         'single-float)
        ((typep numstr 'string)
         'string)))

(defun inspect-function-type (expr-list)
  (dbg "inspect-function-type: next function: " (cadr expr-list))
  (if (equal "(" (car expr-list))
      (cond ((remove-if-not #'(lambda (x)
                                (equal x (get-iter-function-name (cadr expr-list))))
                            (hash-table-keys *functions*))
             (return-from inspect-function-type (gethash
                                                 (get-iter-function-name (cadr expr-list))
                                                 *functions*))))
        (return-from inspect-function-type (gethash
                                            (get-iter-function-name (car expr-list))
                                            *functions*))))

(defun set-function-type (fn-name type)
  (setf (gethash (get-function-name fn-name) *functions*) type))

(defun parse-argument ()
  (cond ((find #\: (car *expr-list*))
         (let ((def (split ":" (car *expr-list*))))
           (dbg "parse-argument: DEFINE " (car *expr-list*))
           (inc-arg)
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr *expr-list*)))
               (progn
                 (setf *expr-list* (cdr *expr-list*))
                 (parse-signature-vector (car def))
                 (dbg "parse-argumemt: signature " (gethash (car def) *signatures*))
                 (parse-variable-type (car def) (cadr def) (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type (car def) (cadr def))
                 (setf *expr-list* (cdr *expr-list*))
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           (dbg "parse-argument: OPEN ARG")
           (if (find #\: (car *expr-list*))
               (add-code ","))
           (parse-argument)))))

(defun parse-function-type (&optional (signature nil))
  (let ((fn-name (car (split ":" (car *expr-list*))))
        (type (cadr (split ":" (car *expr-list*)))))
    (cond ((equal "i16" type)
           (add-code "i16")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i32" type)
           (add-code "i32")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i64" type)
           (add-code "i64")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f32" type)
           (add-code "f32")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f64" type)
           (add-code "f64")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "b8" type)
           (add-code "char")
           (setf (gethash (get-function-name fn-name) *functions*) 'char)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "c8" type)
           (add-code "char")
           (setf (gethash (get-function-name fn-name) *functions*) 'char)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "bool" type)
           (add-code "bool")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean)
           (setf *expr-list* (cdr *expr-list*)))
          
          ((equal "bool#" type)
           (add-code "bool")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "b8#" type)
           (add-code "b8")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "c8#" type)
           (add-code "c8")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i16#" type)
           (add-code "i16")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i32#" type)
           (add-code "i32")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i64#" type)
           (add-code "i64")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f32#" type)
           (add-code "f32")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f64#" type)
           (add-code "f64")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-array)
           (setf *expr-list* (cdr *expr-list*)))
          
          ((equal "bool>" type)
           (add-code "bool*")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "b8>" type)
           (add-code "b8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "c8>" type)
           (add-code "c8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i16>" type)
           (add-code "i16*")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i32>" type)
           (add-code "i32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i64>" type)
           (add-code "i64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f32>" type)
           (add-code "f32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-pointer)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f64>" type)
           (add-code "f64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-pointer)
           (setf *expr-list* (cdr *expr-list*)))

          ((equal "bool'" type)
           (add-code "node_bool*")
           (setf (gethash (get-function-name fn-name) *functions*) 'boolean-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "b8'" type)
           (add-code "node_b8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "c8'" type)
           (add-code "node_c8*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i16'" type)
           (add-code "node_i16*")
           (setf (gethash (get-function-name fn-name) *functions*) 'short-integer-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i32'" type)
           (add-code "node_i32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'integer-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "i64'" type)
           (add-code "node_i64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'bigint-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f32'" type)
           (add-code "node_f32*")
           (setf (gethash (get-function-name fn-name) *functions*) 'single-float-list)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "f64'" type)
           (add-code "node_f64*")
           (setf (gethash (get-function-name fn-name) *functions*) 'double-float-list)
           (setf *expr-list* (cdr *expr-list*)))

          ((equal "string" type)
           (add-code "const char*")
           (setf (gethash (get-function-name fn-name) *functions*) 'char-array)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "void" type)
           (add-code "void")
           (setf (gethash (get-function-name fn-name) *functions*) 'void)
           (setf *expr-list* (cdr *expr-list*)))
          ((equal "[" type)
           (add-code "void")
           (setf (gethash (get-function-name fn-name) *functions*) 'void))
          ((equal "fun" type)
           (if signature
               (progn
                 (dbg "parse-function-type: signature " signature)
                 (dbg "parse-function-type: signature "
                      (format nil "~a (*~a)(~a)"
                              (car (reverse signature))
                              (get-function-name fn-name)
                              (cdr (reverse signature))))
                 (add-code (format nil "~a (*~a)(~a)"
                                   (car (reverse signature))
                                   (get-function-name fn-name)
                                   (cadr (reverse signature))))
                 (setf (gethash (get-function-name fn-name) *functions*) 'function))
               (progn
                 (add-code "single_fn_f32")
                 (setf (gethash (get-function-name fn-name) *functions*) 'function)))
           (setf *expr-list* (cdr *expr-list*)))
          (t
           (error-function-type-unkown type))))
   
  *expr-list*)

(defun parse-function-name-and-type ()
  (cond ((stringp (car *expr-list*))
         (let* ((def (split ":" (car *expr-list*)))
                (fn-name (car def)))
           (dbg "parse-function-name-and-type: Functionname " fn-name)
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr *expr-list*)))
               (progn
                 (setf *expr-list* (cdr *expr-list*))
                 (parse-signature-vector (car def))
                 (dbg "parse-function-name-and-type: signature "
                      (gethash (car def) *signatures*))
                 (parse-function-type (gethash (car def) *signatures*)))
               (progn
                 (parse-function-type)))
           (add-code " ")
           (cond ((equal fn-name "main")
                  (setf *is-main-defined* t)
                  (add-code fn-name))
                 (t
                  (add-code (get-function-name fn-name)))))))
  (dbg "parse-function-name-and-type: EXIT Rest. " *expr-list*))

(defun parse-variable-type (var-name type-name &optional (signature nil))
  (cond ((equal "i16" type-name)
         (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i32" type-name)
         (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer))
        ((equal "i64" type-name)
         (add-code "long")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint))
        ((equal "f32" type-name)
         (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float))
        ((equal "f64" type-name)
         (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float))
        ((equal "bool" type-name)
         (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean))
        ((equal "b8" type-name)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "c8" type-name)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char))
        ((equal "string" type-name)
         (add-code "const char*")         
         (setf (gethash (get-variable-name var-name) *variables*) 'string))
        
        ((equal "bool#" type-name)
         (add-code "bool")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-array))
        ((equal "b8#" type-name)
         (add-code "char")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "c8#" type-name)
         (add-code "c8")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-array))
        ((equal "i16#" type-name)
         (add-code "i16")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-array))
        ((equal "i32#" type-name)
         (add-code "i32")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-array))
        ((equal "i64#" type-name)
         (add-code "i64")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-array))
        ((equal "f32#" type-name)
         (add-code "f32")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-array))
        ((equal "f64#" type-name)
         (add-code "f64")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-array))
        
        ((equal "bool>" type-name)
         (add-code "bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-pointer))
        ((equal "b8>" type-name)
         (add-code "b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "c8>" type-name)
         (add-code "c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-pointer))
        ((equal "i16>" type-name)
         (add-code "i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-pointer))
        ((equal "i32>" type-name)
         (add-code "i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-pointer))
        ((equal "i64>" type-name)
         (add-code "i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-pointer))
        ((equal "f32>" type-name)
         (add-code "f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-pointer))
        ((equal "f64>" type-name)
         (add-code "f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-pointer))

        ((equal "bool'" type-name)
         (add-code "node_bool*")
         (setf (gethash (get-variable-name var-name) *variables*) 'boolean-list))
        ((equal "b8'" type-name)
         (add-code "node_b8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "c8'" type-name)
         (add-code "node_c8*")
         (setf (gethash (get-variable-name var-name) *variables*) 'char-list))
        ((equal "i16'" type-name)
         (add-code "node_i16*")
         (setf (gethash (get-variable-name var-name) *variables*) 'short-integer-list))
        ((equal "i32'" type-name)
         (add-code "node_i32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'integer-list))
        ((equal "i64'" type-name)
         (add-code "node_i64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'bigint-list))
        ((equal "f32'" type-name)
         (add-code "node_f32*")
         (setf (gethash (get-variable-name var-name) *variables*) 'single-float-list))
        ((equal "f64'" type-name)
         (add-code "node_f64*")
         (setf (gethash (get-variable-name var-name) *variables*) 'double-float-list))
        
        ((equal "fun" type-name)
         (if signature
             (progn
               (dbg "parse-variable-type: signature " signature)
               (dbg "parse-variable-type: signature "
                    (format nil "~a (*~a)(~a)"
                            (car (reverse signature))
                            (get-variable-name var-name)
                            (cdr (reverse signature))))
               (add-code (format nil "~a (*~a)(~a)"
                                 (car (reverse signature))
                                 (get-variable-name var-name)
                                 (cadr (reverse signature))))
               (setf (gethash (get-variable-name var-name) *variables*) 'function))
             (progn
               (add-code "single_fn_f32")
               (setf (gethash (get-variable-name var-name) *variables*) 'function))))
        (t
         (error-no-type-def))))

(defun parse-signature-vector (var-name)
  (dbg "parse-signature-vector: ENTRY " (car *expr-list*))
  (if (equal "$" (car *expr-list*))
      (setf *expr-list* (cdr *expr-list*)))
  (if (equal "[" (car *expr-list*))
      (setf *expr-list* (cdr *expr-list*)))
  (if (not (equal "]" (car *expr-list*)))
      (progn
        (dbg "parse-signature-vector: " (car *expr-list*))
        (setf (gethash var-name *signatures*) (append
                                               (gethash var-name *signatures*)
                                               (list (car *expr-list*))))
        (dbg "parse-signature-vector: " (gethash var-name *signatures*))
        (setf *expr-list* (cdr *expr-list*))
        (parse-signature-vector var-name)))
  (if (equal "]" (car *expr-list*))
      (progn
        (dbg "parse-signature-vector: EXIT " (car *expr-list*))
        (setf *expr-list* (cdr *expr-list*))
        (return-from parse-signature-vector))))
  
(defun parse-variable ()
  (dbg "parse-variable: " (car *expr-list*))
  (cond ((equal "\n" (car *expr-list*))
         (dbg "parse-variable: RET")
         (setf *expr-list* (cdr *expr-list*))
         (parse-variable))
        ((find #\: (car *expr-list*))
         (let ((def (split ":" (car *expr-list*))))
           (dbg "parse-variable: DEFINE " (car *expr-list*))
           (if (or (equal "\n" (cadr *expr-list*))
                   (equal "]" (cadr *expr-list*)))
               (error-no-type-def))
           ;; store current variable
           (setf *current-let-definition* (cadr def))
           ;; parse signature
           (if (and (equal "fun" (cadr def)) (equal "[" (cadr *expr-list*)))
               (progn
                 (setf *expr-list* (cdr *expr-list*))
                 (parse-signature-vector (car def))
                 (dbg "parse-argument: signature "
                      (gethash (car def) *signatures*))
                 (parse-variable-type (car def) (cadr def)
                                      (gethash (car def) *signatures*)))
               (progn
                 (parse-variable-type (car def) (cadr def))
                 (setf *expr-list* (cdr *expr-list*))))
           ;; if function then register function
           (if (equal (format nil "~a"
                              (gethash (get-variable-name
                                        (car def)) *variables*))
                      "FUNCTION")
               (register-function (car def) (car *expr-list*))
               (progn
                 (add-code " ")
                 (add-code (get-variable-name (car def)))))
           ;; if array emit brackezs
           (if (search "#" (cadr def))
               (add-code "[]"))
           ;; initialisation
           (add-code "=")
           (dbg "parse-variable: OPEN ARG")
           (if (equal (car *expr-list*) "]")
               (error-missing-expression))
           ;; parse initialisation
           (dbg "parse-variable: next " *expr-list*)
           (parse-expression)
           ;; store poiner
           (dbg "parse-variable: append size " *expr-list*)
           (if (search "#" (cadr def))
               (add-code
                (format nil "append_ptr(~a, sizeof(~a)/sizeof(~a), ARRAY);~%"
                                 (get-variable-name (car def))
                                 (get-variable-name (car def))
                                 (regex-replace "#" (cadr def) ""))))
           (if (search ">" (cadr def))
               (add-code
                (format nil "append_ptr(~a, 1, VARIABLE);~%"
                                 (get-variable-name (car def)))))
           (dbg "parse-variable: rest " *expr-list*)))
        ((not (find #\: (car *expr-list*)))
         (error-syntax-error)))
  *expr-list*)

(defun parse-operator ()
  (cond ((equal ">" (car *expr-list*))
         (add-code ">"))
        ((equal ">=" (car *expr-list*))
         (add-code ">="))
        ((equal "<" (car *expr-list*))
         (add-code "<"))
        ((equal "<=" (car *expr-list*))
         (add-code "<="))
        ((equal "!=" (car *expr-list*))
         (add-code "!="))
        ((equal "==" (car *expr-list*))
         (add-code "=="))
        ((stringp (car *expr-list*))
         (error-operator-not-defined)))
  (setf *expr-list* (cdr *expr-list*)))

(defun parse-condition ()
  (dbg "parse-condition: " (car *expr-list*))
  (let ((operator "")
        (left nil)
        (right nil))
    (cond ((not (equal "\n" (car *expr-list*)))
           (add-code "if")
           (add-code "(")
           (setf left *expr-list*)
           (dbg "parse-condition: parse left-side " (car *expr-list*))
           (parse-expression t)
           (dbg "parse-condition: left expression end")
           (setf operator (car *expr-list*))
           (dbg "parse-condition: parse operator " operator)
           (parse-operator)
           (setf right *expr-list*)
           (dbg "parse-condition: parse right-side " (car *expr-list*))
           (parse-expression t)
           (dbg "parse-condition: right expression end")
           (add-code ")")
           (add-code (format nil "~%"))
           (dbg "parse-condition: rest " *expr-list*))
          ((equal "\n" (car *expr-list*))
           (dbg "parse-condition: RET")
           (parse-condition)))))

(defun parse-range ()
  (dbg "parse-range: " (car *expr-list*))
  (let ((operator "")
        (from 0)
        (to 0)
        (var-name ""))
    (cond ((equal "\n" (car *expr-list*))
           (dbg "parse-range: RET")
           (parse-range))
          ((find #\: (car *expr-list*))
           (let ((def (split ":" (car *expr-list*))))
             (dbg "parse-range: DEFINE " (car *expr-list*))
             (parse-variable-type (car def) (cadr def))
             (dbg "parse-range: OPEN ARG")
             (if (or (equal "\n" (cadr *expr-list*)) (equal "]" (cadr *expr-list*)))
                 (error-no-type-def))
             (add-code " ")
             (setf var-name (get-variable-name (car def)))
             (dbg "parse-range: get-variable-name " var-name)
             (add-code var-name)
             (add-code "=")
             (if (equal (cadr *expr-list*) "]")
                 (error-missing-expression))
             (dbg "parse-range: parse from ")
             (setf from *expr-list*)
             (setf *expr-list* (cdr *expr-list*))
             (parse-expression t)
             (dbg "parse-range: from expression end")
             (add-code (format nil ";~%"))
             (add-code "for")
             (add-code "(")
             (add-code var-name)
             (add-code "=")
             (setf *expr-list* (cdr from))
             (parse-expression t)
             (dbg "parse-range: operator expression end")
             (add-code ";")
             (dbg "parse-range: parse operator " (car *expr-list*))
             (add-code var-name)
             (setf operator (car *expr-list*))
             (parse-operator)
             (dbg "parse-range: parse to " (car *expr-list*))
             (setf to *expr-list*)
             (parse-expression t)
             (dbg "parse-range: to expression end")
             (add-code (format nil ";"))
             (add-code var-name)
             (if (or (equal operator "<") (equal operator "<="))
                 (add-code "++"))
             (if (or (equal operator ">") (equal operator ">="))
                 (add-code "--"))
             (if (equal operator "!=")
                 (add-code "++"))
             (add-code ")")
             (add-code (format nil "~%"))
             (dbg "parse-range: rest " *expr-list*)))
          ((not (find #\: (car *expr-list*)))
           (error-syntax-error)))))

(defun parse-block ()
  (dbg "parse-block " (car *expr-list*) " block " *block*)
  (dbg *expr-list*)
  (if (equal "(" (car *expr-list*))
      (progn
        (dbg "parse-block before expression " (car *expr-list*))
        (parse-expression)
        (dbg "parse-block: after expression")))
  (dbg "parse-block: after-expression " *expr-list*)
  (if (not *expr-list*)
      (return-from parse-block))
  (if (equal "\"" (car *expr-list*))
      (progn
        (dbg "parse-expression: STRING block " *block*)
        (add-code "\"")
        (setf *expr-list* (cdr *expr-list*))
        (parse-cstr)
        (dbg "parse-expression: STRING END " *expr-list*)
        (add-code (format nil ";~%"))
        (return-from parse-block)))
  (if (equal ";|" (car *expr-list*))
      (progn
        (dbg "parse-expression: parse multiline comment")
        (parse-multiline-comment)
        (return-from parse-block)))
  (if (equal ";" (car *expr-list*))
      (progn
        (dbg "parse-expression: parse singleline comment")
        (setf *expr-list* (cdr *expr-list*))
        (parse-single-line-comment)
        (return-from parse-block)))
  (if (equal "\n" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
        (parse-block)))
  (if (equal ")" (car *expr-list*))
      (progn
        (dbg "parse-block ) " (car *expr-list*))
        (return-from parse-block)))
  (if (not (equal ")" (car *expr-list*)))
      (progn
        (dbg "parse-block " (car *expr-list*))
        (setf *expr-list* (cdr *expr-list*))
        (parse-block))))

(defun parse-function-vector ()
  (let ((temp-list *expr-list*))
    (dbg "parse-function-vector: parse variable")  
    (parse-argument)
    (if (equal "]" (car *expr-list*))
        (return-from parse-function-vector))
    (if (and (not (find #\: (cadr *expr-list*))) (not (equal "]" (cadr *expr-list*))))
        (error-function-vector-malformed))
    (if (not (equal "]" (car *expr-list*)))
        (progn
          (dbg "parse-function-vector: next variable " (car *expr-list*))
          (if (equal temp-list *expr-list*)
              (setf *expr-list* (cdr *expr-list*)))
          (parse-function-vector)))))

(defun parse-if-vector ()
  (dbg "parse-if-vector: condition range" (car *expr-list*))  
  (parse-condition)
  (if (equal "\n" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
        (parse-if-vector)))
  (if (equal "]" (car *expr-list*))
      (return-from parse-if-vector))
  (if (not (equal "]" (car *expr-list*)))
      (progn
        (dbg "parse-if-vector: next variable")  
        (parse-if-vector)))
  (dbg "parse-if-vector: exit" (car *expr-list*)))

(defun parse-for-vector ()
  (dbg "parse-for-vector: parse range")  
  (parse-range)
  (if (equal "]" (car *expr-list*))
      (return-from parse-for-vector))
  (if (equal "\n" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
      (parse-for-vector)))
  (if (not (equal "]" (car *expr-list*)))
      (progn
        (dbg "parse-for-vector: next variable")  
        (parse-for-vector)))
  (dbg "parse-for-vector: exit" (car *expr-list*)))

(defun parse-let-vector ()
  (dbg "parse-let-vector: parse variable")  
  (parse-variable)
  (if (equal "]" (car *expr-list*))
      (return-from parse-let-vector))
  (if (equal "\n" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
        (parse-let-vector)))
  (if (not (equal "]" (car *expr-list*)))
      (progn
        (dbg "parse-let-vector: next variable")  
        (parse-let-vector)))
  (dbg "parse-let-vector: exit" (car *expr-list*)))

(defun parse-open-square-bracket ()
  (dbg "parse-open-square-bracket")  
  (if (equal "[" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
        (return-from parse-open-square-bracket))
      (error-missing-open-square-bracket)))

(defun parse-close-square-bracket ()
  (dbg "parse-close-square-bracket")  
  (if (equal "]" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
        (return-from parse-close-square-bracket))
      (error-missing-close-square-bracket)))

(defun parse-open-parens ()
  (dbg "parse-open-parens")  
  (if (equal "(" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
        (return-from parse-open-parens))
      (error-missing-open-parens)))

(defun parse-close-parens ()
  (dbg "parse-close-parens")  
  (if (equal ")" (car *expr-list*))
      (progn
        (setf *expr-list* (cdr *expr-list*))
      (return-from parse-close-parens))
      (error-missing-close-parens)))

(defun parse-if ()
  (zero-arg)
  (inc-block)
  (dbg "parse-if: open square block " *block* " parens " *paranteses*)
  (parse-open-square-bracket)
  (parse-if-vector)
  (parse-close-square-bracket)
  (if (equal "\n" (car *expr-list*))
      (setf *expr-list* (cdr *expr-list*)))
  (if (equal "\n" (car *expr-list*))
      (setf *expr-list* (cdr *expr-list*)))
  (add-code (format nil "{~%"))
  (parse-expression)
  (dbg "parse-if: end expr " (car *expr-list*))
  (add-code (format nil "}~%"))
  (if (not (equal ")" (car *expr-list*)))
      (progn
        (add-code "else")
        (add-code (format nil "~%{~%"))
        (if (equal "\n" (car *expr-list*))
            (setf *expr-list* (cdr *expr-list*)))
        (if (equal "\n" (car *expr-list*))
            (setf *expr-list* (cdr *expr-list*)))
        (parse-expression)
        (dbg "parse-if: end else expr " (car *expr-list*))
        (add-code (format nil "}~%"))))
  (dec-block)
  (dbg "parse-if BLOCK END  block " *block* " parens " *paranteses* " " (car *expr-list*)))

(defun parse-for ()
  (zero-arg)
  (inc-block)
  (dbg "parse-for: open square block " *block* " parens " *paranteses*)
  (parse-open-square-bracket)
  (parse-for-vector)
  (parse-close-square-bracket)
  (add-code (format nil "{~%"))
  (parse-block)
  (dbg "parse-for: end block " (car *expr-list*))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-for BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-for " *expr-list*))

(defun parse-let ()
  (zero-arg)
  (inc-block)
  (dbg "parse-let: open square block " *block* " parens " *paranteses*)
  (parse-open-square-bracket)
  (add-code (format nil "{~%"))
  (parse-let-vector)
  (parse-close-square-bracket)
  (parse-block)
  (dbg "parse-let: end block " (car *expr-list*))
  (dec-block)
  (add-code (format nil "}~%"))
  (dbg "parse-let BLOCK END  block " *block* " parens " *paranteses*)
  (dbg "parse-let " *expr-list*))

(defun parse-def-function ()
  (let ((fn-name (car *expr-list*)))
  (zero-arg)
  (dbg "parse-def-function: name and type block " *block* " parens " *paranteses*)
  (parse-function-name-and-type)
  (inc-block)
  (dbg "parse-def-function: open square")
  (add-code "(")
  (parse-open-square-bracket)
  (parse-function-vector)
  (parse-close-square-bracket)
  (add-code ")")
  (add-code (format nil "~%{~%"))
  (parse-block)
  (dbg "parse-def-function: end block " (car *expr-list*))
  (if (search "main" fn-name)
      (add-code (format nil "destroy_ptr(pointer_list);~%")))
  (add-code (format nil "}~%"))
  (dec-block)
  (dbg "parse-def-function BLOCK END block " *block* " parens " *paranteses*)
  (dbg "parse-def-function " (car *expr-list*))))

(defun parse-module ()
  (setf *current-module* (car *expr-list*))
  (setf *expr-list* (cdr *expr-list*))
  (parse-block)
  (setf *current-module* ""))

(defun parse-multiline-comment ()
  (cond ((equal "|;" (car *expr-list*))
         (dbg "parse-multiline-comment: CLOSE")
         (setf *expr-list* (cdr *expr-list*))
         (return-from parse-multiline-comment))
        ((stringp (car *expr-list*))
         (dbg "parse-multiline-comment: COMMENT >" (car *expr-list*) "<")
         (setf *expr-list* (cdr *expr-list*))
         (parse-multiline-comment))))

(defun parse-single-line-comment ()
  (cond ((equal "\n" (car *expr-list*))
         (setf *expr-list* (cdr *expr-list*))
         (return-from parse-single-line-comment))
        ((not (equal "\n" (car *expr-list*)))
         (dbg "parse-singleline-comment: COMMENT " (car *expr-list*))
         (setf *expr-list* (cdr *expr-list*))
         (parse-single-line-comment))))

(defun parse-cstr ()
  (cond ((equal "\"" (car *expr-list*))
         (add-code "\"")
         (setf *expr-list* (cdr *expr-list*))
         (return-from parse-cstr))
        ((stringp (car *expr-list*))
         (add-code (car *expr-list*))
         (setf *expr-list* (cdr *expr-list*))
         (parse-cstr))))

(defun parse-element ()
  (dbg "parse-element " (car *expr-list*))
  (cond ((numberp (parse-integer (car *expr-list*) :junk-allowed t))
         (add-code (car *expr-list*))
         (if (and (not (equal "]" (cadr *expr-list*)))
                  (not (equal ")" (cadr *expr-list*))))
             (add-code ", ")))
        ((stringp (car *expr-list*))
         (add-code (car *expr-list*))
         (if (and (not (equal "]" (cadr *expr-list*)))
                  (not (equal ")" (cadr *expr-list*))))
             (add-code ", "))))
  (setf *expr-list* (cdr *expr-list*)))
             
(defun parse-vector ()
  (dbg "parse-vector " (car *expr-list*))
  (cond ((equal "[" (car *expr-list*))
         (progn
           (setf *expr-list* (cdr *expr-list*))
           (parse-vector)))
        ((equal "]" (car *expr-list*))
         (progn
           (setf *expr-list* (cdr *expr-list*))
           (return-from parse-vector)))
        ((stringp (car *expr-list*))
         (progn
           (parse-element)
           (parse-vector)))))
  
(defun parse-list ()
  (dbg "parse-list " (car *expr-list*))
  (cond ((equal "'(" (car *expr-list*))
         (progn
           (setf *expr-list* (cdr *expr-list*))
           (parse-list)))
        ((equal ")" (car *expr-list*))
         (progn
           (setf *expr-list* (cdr *expr-list*))
           (return-from parse-list)))
        ((stringp (car *expr-list*))
         (progn
           (parse-element)
           (parse-list)))))

(defun count-elements ()
  (let ((count 0)
        (parens 0)
        (expr-list *expr-list*))
    (loop for x from 0 to (1- (length expr-list)) do
         (if (equal "(" (elt expr-list x))
             (progn
               (if (= parens 0)
                   (setf count (1+ count)))
               (setf parens (1+ parens))))
         (if (equal ")" (elt expr-list x))
             (progn
               (setf parens (1- parens))
               (if (< parens 0)
                   (return-from count-elements count))))
         (if (and (not (equal "(" (elt expr-list x)))
                  (not (equal ")" (elt expr-list x))))
             (progn
               (if (= parens 0)
                   (setf count (1+ count))))))
    count))

(defun get-type (expr-list)
  (let ((variable-type (gethash (get-iter-variable-name (cadr *expr-list*)) *variables*))
        (number-type (type-of-number-string (cadr *expr-list*)))
        (function-type (inspect-function-type (cdr expr-list)))
        (tp nil)
        (tp-str ""))
    (cond ((remove-if-not #'(lambda (x)
                              (equal x (get-iter-variable-name (cadr *expr-list*))))
                          (hash-table-keys *variables*))
           (setf tp variable-type))
          (function-type
           (setf tp function-type))
          (number-type
           (setf tp number-type)))
    (cond ((equal tp 'boolean)
           (setf tp-str "bool"))
          ((equal tp 'b8)
           (setf tp-str "char"))
          ((equal tp 'short-integer)
           (setf tp-str "i16"))
          ((equal tp 'integer)
           (setf tp-str "i32"))
          ((equal tp 'bigint)
           (setf tp-str "i64"))
          ((equal tp 'double-float)
           (setf tp-str "f64"))
          ((equal tp 'single-float)
           (setf tp-str "f32"))
          ((equal tp 'string)
           (setf tp-str "string"))
          
          ((equal tp 'boolean-array)
           (setf tp-str "array_bool"))
          ((equal tp 'char-array)
           (setf tp-str "array_c8"))
          ((equal tp 'char-array)
           (setf tp-str "array_b8"))
          ((equal tp 'short-integer-array)
           (setf tp-str "array_i16"))
          ((equal tp 'integer-array)
           (setf tp-str "array_i32"))
          ((equal tp 'bigint-array)
           (setf tp-str "array_i64"))
          ((equal tp 'double-float-array)
           (setf tp-str "array_f64"))
          ((equal tp 'single-float-array)
           (setf tp-str "array_f32"))
          
          ((equal tp 'boolean-pointer)
           (setf tp-str "pointer_bool"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_c8"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_b8"))
          ((equal tp 'short-integer-pointer)
           (setf tp-str "pointer_i16"))
          ((equal tp 'integer-pointer)
           (setf tp-str "pointer_i32"))
          ((equal tp 'bigint-pointer)
           (setf tp-str "pointer_i64"))
          ((equal tp 'double-float-pointer)
           (setf tp-str "pointer_f64"))
          ((equal tp 'single-float-pointer)
           (setf tp-str "pointer_f32"))

          ((equal tp 'boolean-list)
           (setf tp-str "list_bool"))
          ((equal tp 'char-list)
           (setf tp-str "list_c8"))
          ((equal tp 'char-list)
           (setf tp-str "list_b8"))
          ((equal tp 'short-interger-list)
           (setf tp-str "list_i16"))
          ((equal tp 'integer-list)
           (setf tp-str "list_i32"))
          ((equal tp 'bigint-list)
           (setf tp-str "list_i64"))
          ((equal tp 'double-float-list)
           (setf tp-str "list_f64"))
          ((equal tp 'single-float-list)
           (setf tp-str "list_f32"))
          (t
           (setf tp-str "T")
           (error-cant-infer-type)))
    tp-str))


(defun get-math-type (expr-list)
  (let ((variable-type (gethash (get-iter-variable-name (cadr *expr-list*)) *variables*))
        (number-type (type-of-number-string (cadr expr-list)))
        (function-type (inspect-function-type (cdr expr-list)))
        (tp nil)
        (tp-str ""))
    (cond ((remove-if-not #'(lambda (x)
                              (equal x (get-iter-variable-name (cadr expr-list))))
                          (hash-table-keys *variables*))
           (setf tp variable-type))
          (function-type
           (setf tp function-type))
          (number-type
           (setf tp number-type)))
    (cond ((equal tp 'short-integer)
           (setf tp-str "i16"))
          ((equal tp 'integer)
           (setf tp-str "i32"))
          ((equal tp 'bigint)
           (setf tp-str "i64"))
          ((equal tp 'double-float)
           (setf tp-str "f64"))
          ((equal tp 'single-float)
           (setf tp-str "f32"))
          
          ((equal tp 'boolean-pointer)
           (setf tp-str "pointer_bool"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_c8"))
          ((equal tp 'char-pointer)
           (setf tp-str "pointer_b8"))
          ((equal tp 'short-integer-pointer)
           (setf tp-str "pointer_i16"))
          ((equal tp 'integer-pointer)
           (setf tp-str "pointer_i32"))
          ((equal tp 'bigint-pointer)
           (setf tp-str "pointer_i64"))
          ((equal tp 'double-float-pointer)
           (setf tp-str "pointer_f64"))
          ((equal tp 'single-float-pointer)
           (setf tp-str "pointer_f32"))
          (t
           (setf tp-str "T")
           (error-cant-infer-type)))
    tp-str))

(defun parse-arguments (max)
  (dbg "parse-arguments: >" (car *expr-list*) "<")
  (cond ((equal "(" (car *expr-list*))
         (progn
           (if (and *paranteses*
                    (not (equal "(" (get-last-code)))
                    (not (equal ")" (get-last-code))))
               (add-code ","))
           (dbg "parse-arguments: parse-expression ( block "
                *block* " Parens " *paranteses*)
           (parse-expression t)
           (dbg "parse-arguments: expression end")
           (parse-arguments (1- (count-elements)))))
        ((equal "\"" (car *expr-list*))
         (if (and *paranteses*
                  (not (equal "(" (get-last-code))))
             (add-code ","))
         (add-code "\"")
         (dbg "parse-arguments: parse-cstr >" (car *expr-list*) "<")
         (setf *expr-list* (cdr *expr-list*))
         (parse-cstr)
         (parse-arguments max))
        ((equal ")" (car *expr-list*))
         (let ((fn (get-current-function)))
           (dbg "parse-arguments: " (car *expr-list*) " function " fn)
           (dbg "parse-arguments: block " *block* " Parens " *paranteses*)
           (return-from parse-arguments)))
        ((equal "," (car *expr-list*))
         (error-syntax-error))
        ((equal "\n" (car *expr-list*))
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments max))
        ((numberp (parse-integer (car *expr-list*) :junk-allowed t))
         (progn
           (dbg "parse-arguments: NUMBERP " *expr-list*)
           (inc-arg)
           (if (and (get-arg)
                    (not (equal "(" (get-last-code))))
               (add-code ","))
           (progn
             ; convert lisp double-float to c double
             (setf (car *expr-list*) (regex-replace-all "d0" (car *expr-list*) "f"))
             (add-code (car *expr-list*))
             (setf *expr-list* (cdr *expr-list*))
             (parse-arguments max))))
        ((remove-if-not #'(lambda (x)
                             (equal x (get-iter-variable-name (car *expr-list*))))
                         (hash-table-keys *variables*))
         (progn
           (inc-arg)
           (if (and (get-arg)
                    (not (equal "(" (get-last-code)))
                    (not (equal "&" (get-last-code))))
               (add-code ","))
           (dbg "parse-arguments: VARIABLE " (get-iter-variable-name (car *expr-list*)))
           (add-code (get-iter-variable-name (car *expr-list*)))
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments max)
           (return-from parse-arguments)))
        ((remove-if-not #'(lambda (x)
                            (equal x (get-iter-function-name (car *expr-list*))))
                        (hash-table-keys *functions*))
         (progn
           (dbg "parse-arguments: last code " (get-previous-code))
           (add-code (get-iter-function-name (car *expr-list*)))
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments max)))
        ((stringp (car *expr-list*))
         (dbg "parse-arguments: VARIABLE not defined: "
              (get-iter-variable-name  (car *expr-list*))" block " *block*
              " hash " (hash-table-keys *variables*))
         (error-variable-not-defined))))

(defun parse-infix (function)
  (if (equal ")" (car *expr-list*))
      (progn
        (dbg "parse-infix: parens ) parens " *paranteses* " block " *block*)
        (dbg "parse-infix: EXIT " *expr-list*)
        (return-from parse-infix)))
  (dbg "parse-infix: operand " (car *expr-list*))
  (parse-expression t)
  (dbg "parse-infix: expression end" (car *expr-list*))
  (if (and (not (equal ")" (car *expr-list*)))
           (not (equal "\n" (car *expr-list*))))
      (progn
        (dbg "parse-infix: add-code")
        (add-code function)
        (dbg "parse-infix: repeat")
        (parse-infix function))))

(defun parse-call ()
  (cond ((equal "(" (car *expr-list*))
         (progn
           (dbg "parse-call: CALL OPEN ( block " *block* " Parens " *paranteses*)
           (parse-expression t)
           (dbg "parse-call: expression end")))
        ((equal ")" (car *expr-list*))
         (progn
           (setf *expr-list* (cdr *expr-list*))
           (dbg "parse-arguments: ) " (car *expr-list*))
           (return-from parse-call)))
        ((equal "," (car *expr-list*))
         (error-syntax-error))
        ((equal "\n" (car *expr-list*))
         (dbg "parse-call: RET")
         (setf *expr-list* (cdr *expr-list*))
         (parse-call))
        ((or (equal "set" (car *expr-list*)) (equal "::" (car *expr-list*)))
         (let ((type (get-type *expr-list*)))
           (store-current-function "set")
           (if (remove-if-not #'(lambda (x)
                                  (equal x (get-iter-variable-name
                                            (cadr *expr-list*))))
                                  (hash-table-keys *variables*))
               (progn
                 (add-code (format nil "set_pointer_~a" type))
                 (add-code "(")
                 (add-code "&"))
               (progn
                 (if (or (search "elt" (caddr *expr-list*)) (search "#" (caddr *expr-list*)))
                     (add-code (format nil "set_pointer_~a" type))
                     (add-code (format nil "set_~a" type)))
                 (add-code "(")))
           (progn
             (zero-arg)
             (dbg "parse-call: set Next arg " (cadr *expr-list*))
             (setf *expr-list* (cdr *expr-list*))
             (parse-arguments 2))))
        ((or (equal "elt" (car *expr-list*)) (equal "#" (car *expr-list*)))
         (let ((type (get-type *expr-list*)))
           (store-current-function "elt")
           (if (equal (cadr (gethash (get-last-function) *signatures*)) "value")
               (add-code "*"))
           (add-code (format nil "elt_~a" (regex-replace "pointer" type "array")))
           (add-code "(")
           (zero-arg)
           (dbg "parse-call: elt Next arg " (cadr *expr-list*))
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments (1- (count-elements)))))
         ((equal "prnfmt" (car *expr-list*))
          (store-current-function "prnfmt")
          (add-code "print_format")
          (add-code "(")
          (zero-arg)
          (dbg "parse-call: prnfmt Next arg " (cadr *expr-list*))
          (setf *expr-list* (cdr *expr-list*))
          (parse-arguments *infinite-arguments*))
        ((equal "prnl" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "prnl")
           (if (search "array" type)
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr *expr-list*)))))
               (progn
                 (add-code (format nil "println_~a" type))
                 (add-code "(")))
           (zero-arg)
           (dbg "parse-call: prnl Next arg " (cadr *expr-list*))
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)))
        ((equal "prn" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "prn")
           (if (search "array" type)
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")
                 (add-code (format nil "sizeof(~a)"
                                   (get-iter-variable-name (cadr *expr-list*)))))
               (progn
                 (add-code (format nil "print_~a" type))
                 (add-code "(")))
           (zero-arg)
           (dbg "parse-call: prn Next arg " (cadr *expr-list*))
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)))
        ((equal "prnstr" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "prnstr")
           (zero-arg)
           (add-code (format nil "print_str_~a" type))
           (add-code "(")
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)))
        ((equal "let" (car *expr-list*))
         (store-current-function "let")
         (zero-arg)
         (inf "Compile let in block " *block*)
         (dbg "parse-call: LET INC BLOCK " *block* " PARENS " *paranteses*)
         (setf *expr-list* (cdr *expr-list*))
         (parse-let))
        ((or (equal "for" (car *expr-list*)) (equal "∑" (car *expr-list*)))
         (store-current-function "for")
         (zero-arg)
         (inf "Compile for in block " *block*)          
         (dbg "parse-call: FOR INC BLOCK " *block* " PARENS " *paranteses*)
         (setf *expr-list* (cdr *expr-list*))
         (parse-for))
        ((equal "defn" (car *expr-list*))
         (store-current-function "defn")
         (zero-arg)
         (setf *target* 'implementation)
         (dbg "parse-call: DEFN INC BLOCK " (cdr *expr-list*))
         (inf "Compile function '" (cadr *expr-list*) "'")
         (setf *expr-list* (cdr *expr-list*))
         (parse-def-function)
         (setf *target* 'code))
        ((equal "return" (car *expr-list*))
         (store-current-function "return")
         (add-code "return")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "if" (car *expr-list*))
         (store-current-function "if")
         (zero-arg)
         (inf "Compile condition in block " *block*)
         (dbg "parse-call: IF INC BLOCK " *block* " PARENS " *paranteses*)
         (setf *expr-list* (cdr *expr-list*))
         (parse-if))
        ((or (equal "mod" (car *expr-list*))
             (equal "%" (car *expr-list*)))
         (store-current-function "mod")
         (add-code "mod")
         (add-code "(")
         (zero-arg)
         (dbg "parse-call: MOD block " *block* " PARENS " *paranteses*)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 2))
        ((equal "<" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (add-code (format nil "lt_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (zero-arg)
           (return-from parse-call)))
        ((equal "<=" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (add-code (format nil "leqt_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (zero-arg)
           (return-from parse-call)))
        ((equal ">" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (add-code (format nil "gt_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (zero-arg)
           (return-from parse-call)))
        ((equal ">=" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (add-code (format nil "geqt_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (zero-arg)
           (return-from parse-call)))
        ((equal "!=" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (add-code (format nil "neq_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (zero-arg)
           (return-from parse-call)))
        ((equal "==" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (add-code (format nil "eq_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((or (equal "add" (car *expr-list*)) (equal "+" (car *expr-list*)))
         (store-current-function "add")
         (zero-arg)
         (dbg "parse-call: operator + ")
         (setf *expr-list* (cdr *expr-list*))
         (dbg "parse-call: max " (format nil "~a" (count-elements)))
         (add-code "(")
         (if (not (equal ")" (car *expr-list*)))
             (progn
               (dbg "parse-call: parse-infix notation " (car *expr-list*))
               (parse-infix "+")
               (dbg "parse-call: parse-infix end" *expr-list*))
             (error-operator-not-defined))
         (zero-arg)
         (parse-arguments (count-elements))
         (dbg "parse-call: add end after arguments " (car *expr-list*))
         (return-from parse-call))
        ((or (equal "sub" (car *expr-list*)) (equal "-" (car *expr-list*)))
         (store-current-function "sub")
         (zero-arg)
         (dbg "parse-call: operator - ")
         (setf *expr-list* (cdr *expr-list*))
         (dbg "parse-call: max " (format nil "~a" (count-elements)))
         (add-code "(")
         (if (not (equal ")" (car *expr-list*)))
             (progn
               (dbg "parse-call: parse-infix notation " (car *expr-list*))
               (parse-infix "-")
               (dbg "parse-call: parse-infix end " *expr-list*))
             (error-operator-not-defined))
         (zero-arg)
         (parse-arguments (count-elements))
         (dbg "parse-call: sub end after arguments " (car *expr-list*))
         (return-from parse-call))
        ((or (equal "mul" (car *expr-list*)) (equal "*" (car *expr-list*)))
         (store-current-function "mul")
         (zero-arg)
         (dbg "parse-call: operator * ")
         (setf *expr-list* (cdr *expr-list*))
         (dbg "parse-call: max " (format nil "~a" (count-elements)))
         (add-code "(")
         (if (not (equal ")" (car *expr-list*)))
             (progn
               (dbg "parse-call: parse-infix notation " (car *expr-list*))
               (parse-infix "*")
               (dbg "parse-call: parse-infix end" *expr-list*))
             (error-operator-not-defined))
         (zero-arg)
         (parse-arguments (count-elements))
         (dbg "parse-call: mul end after arguments " (car *expr-list*))
         (return-from parse-call))
        ((or (equal "div" (car *expr-list*)) (equal "/" (car *expr-list*)))
         (store-current-function "div")
         (zero-arg)
         (dbg "parse-call: operator / ")
         (setf *expr-list* (cdr *expr-list*))
         (dbg "parse-call: max " (format nil "~a" (count-elements)))
         (add-code "(")
         (if (not (equal ")" (car *expr-list*)))
             (progn
               (dbg "parse-call: parse-infix notation " (car *expr-list*))
               (parse-infix "/")
               (dbg "parse-call: parse-infix end " *expr-list*))
             (error-operator-not-defined))
         (zero-arg)
         (parse-arguments (count-elements))
         (dbg "parse-call: div end after arguments " (car *expr-list*))
         (return-from parse-call))
        ((or (equal "sqrt" (car *expr-list*)) (equal "√" (car *expr-list*)))
         (let ((type (get-type *expr-list*)))
           (store-current-function "sqrt")
           (add-code (format nil "sqrt_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((or (equal "power" (car *expr-list*)) (equal "^" (car *expr-list*)))
         (let ((type (get-type *expr-list*)))
           (store-current-function "power")
           (add-code (format nil "power_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "max" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "max")
           (add-code (format nil "max_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "min" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "min")
           (add-code (format nil "min_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "module" (car *expr-list*))
         (store-current-function "module")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-module)
         (return-from parse-call))
        ((or (equal "size" (car *expr-list*)) (equal "@" (car *expr-list*)))
         (store-current-function "size")
         (add-code "sizeof")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "map" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "map")
           (add-code (format nil "map_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "mapn" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "mapn")
           (add-code (format nil "mapn_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "reduce" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "reduce")
           (add-code (format nil "reduce_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "push" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "push")
           (add-code (format nil "push_~a" type))
           (add-code "(")
           (add-code "&")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "car" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "car")
           (add-code (format nil "car_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "cdr" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "cdr")
           (add-code (format nil "cdr_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "append" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (if (and (not (search "list" type))
                    (not (search "array" type))
                    (not (search "pointer" type)))
               (error-type-not-supported))
           (store-current-function "append")
           (add-code (format nil "append_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "len" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (store-current-function "len")
           (add-code (format nil "length_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 2)
           (return-from parse-call)))
        ((equal "remove" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "remove")
           (add-code (format nil "remove_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 1)
           (return-from parse-call)))
        ((equal "pop" (car *expr-list*))
         (let ((type (get-type *expr-list*)))
           (if (not (search "list" type))
               (error-only-lists-supported))
           (store-current-function "pop")
           (add-code (format nil "pop_~a" type))
           (add-code "(")
           (add-code "&")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 1)
           (return-from parse-call)))
        ((equal "break" (car *expr-list*))
         (add-code "break")
         (add-code (format nil ";~%"))
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (return-from parse-call))
        ((equal "destroy" (car *expr-list*))
         (add-code "destroy_ptr")
         (add-code "(")
         (add-code "pointer_list")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (return-from parse-call))
        ((equal "bool" (car *expr-list*))
         (store-current-function "bool")
         (add-code "(")
         (add-code "bool")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "b8" (car *expr-list*))
         (store-current-function "b8")
         (add-code "(")
         (add-code "b8")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "c8" (car *expr-list*))
         (store-current-function "c8")
         (add-code "(")
         (add-code "c8")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "i16" (car *expr-list*))
         (store-current-function "i16")
         (add-code "(")
         (add-code "i16")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "i32" (car *expr-list*))
         (store-current-function "i32")
         (add-code "(")
         (add-code "i32")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "i64" (car *expr-list*))
         (store-current-function "i64")
         (add-code "(")
         (add-code "i64")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "f64" (car *expr-list*))
         (store-current-function "f64")
         (add-code "(")
         (add-code "f64")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "f32" (car *expr-list*))
         (store-current-function "f32")
         (add-code "(")
         (add-code "f32")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "bool>" (car *expr-list*))
         (store-current-function "bool>")
         (add-code "(")
         (add-code "bool*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "c8>" (car *expr-list*))
         (store-current-function "c8>")
         (add-code "(")
         (add-code "c8*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "b8>" (car *expr-list*))
         (store-current-function "b8>")
         (add-code "(")
         (add-code "b8*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "i16>" (car *expr-list*))
         (store-current-function "i16>")
         (add-code "(")
         (add-code "i16*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "i32>" (car *expr-list*))
         (store-current-function "i32>")
         (add-code "(")
         (add-code "i32*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "i64>" (car *expr-list*))
         (store-current-function "i64>")
         (add-code "(")
         (add-code "i64*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "f64>" (car *expr-list*))
         (store-current-function "f64>")
         (add-code "(")
         (add-code "f64*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "f32>" (car *expr-list*))
         (store-current-function "f32>")
         (add-code "(")
         (add-code "f32*")
         (add-code ")")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "del" (car *expr-list*))
         (store-current-function "del")
         (add-code (format nil "delete_ptr"))
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "destroy" (car *expr-list*))
         (store-current-function "destroy")
         (add-code (format nil "destroy_ptr"))
         (add-code "(")
         (add-code "pointer_list")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 0)
         (return-from parse-call))
        ((equal "new" (car *expr-list*))
         (if (not (search ">" *current-let-definition*))
             (error-type-not-supported))
         (let ((type (regex-replace ">" *current-let-definition* "")))
           (store-current-function "new")
           (add-code (format nil "new_~a" type))
           (add-code "(")
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (parse-arguments 1)
           (return-from parse-call)))
        ((equal "new_bool" (car *expr-list*))
         (store-current-function "new_bool")
         (add-code "new_bool")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_c8" (car *expr-list*))
         (store-current-function "new_c8")
         (add-code "new_c8")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_b8" (car *expr-list*))
         (store-current-function "new_b8")
         (add-code "new_b8")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_i16" (car *expr-list*))
         (store-current-function "new_16")
         (add-code "new_i16")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_i32" (car *expr-list*))
         (store-current-function "new_i32")
         (add-code "new_i32")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_i64" (car *expr-list*))
         (store-current-function "new_i64")
         (add-code "new_i64")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_f32" (car *expr-list*))
         (store-current-function "new_f32")
         (add-code "new_f32")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((equal "new_f64" (car *expr-list*))
         (store-current-function "new_f64")
         (add-code "new_f64")
         (add-code "(")
         (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments 1)
         (return-from parse-call))
        ((remove-if-not #'(lambda (x)
                            (equal x (get-iter-function-name (car *expr-list*))))
                        (hash-table-keys *functions*))
         (progn
           (dbg "parse-call: FN: " (get-iter-function-name (car *expr-list*)))
           (if (is-function-map-p (car *expr-list*))
               (add-code (get-iter-function-name (get-function-value (car *expr-list*))))
               (add-code (get-iter-function-name (car *expr-list*))))
           (add-code "(")
           (zero-arg)
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments *infinite-arguments*)))
        ((get-iter-variable-name (car *expr-list*))
         (dbg "parse-call: FN emit: " (get-function-name (car *expr-list*)))
         (zero-arg)
         (add-code "(")
         (add-code "*")
         (add-code (get-function-name (car *expr-list*)))
         (add-code ")")
         (add-code "(")
         (setf *expr-list* (cdr *expr-list*))
         (parse-arguments *infinite-arguments*))
        ((stringp (car *expr-list*))
         (dbg "parse-call: FN not defined: " (get-function-name (car *expr-list*)))
         (error-function-not-defined)))
   *expr-list*)


(defun parse-expression (&optional (omit nil))
  (if (car *expr-list*)
      (progn
        (dbg "parse-expression: start " (car *expr-list*))
        (if (equal "," (car *expr-list*))
            (error-syntax-error))        
        (if (equal "\n" (car *expr-list*))
            (progn
              (setf *expr-list* (cdr *expr-list*))
              (dbg "parse-expression: caught \n")
;              (parse-expression)
              (return-from parse-expression)))
        (if (equal "\"" (car *expr-list*))
            (progn
              (dbg "parse-expression: STRING block " *block*)
              (add-code "\"")
              (setf *expr-list* (cdr *expr-list*))
              (parse-cstr)
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: STRING END " *expr-list*)
              (return-from parse-expression)))
        (if (equal ";|" (car *expr-list*))
            (progn
              (dbg "parse-expression: parse multiline comment")
              (parse-multiline-comment)
              (return-from parse-expression)))
        (if (equal ";" (car *expr-list*))
            (progn
              (dbg "parse-expression: parse singleiline comment")
              (parse-single-line-comment)
              (return-from parse-expression)))
        (if (equal "[" (car *expr-list*))
            (progn
              (add-code "{")
              (dbg "parse-expression: parse vector " (car *expr-list*))
              (setf *expr-list* (cdr *expr-list*))
              (parse-vector)
              (add-code (format nil "}"))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (return-from parse-expression *expr-list*)))
        (if (equal "'" (car *expr-list*))
            (progn
              (setf *expr-list* (cddr *expr-list*))
              (let ((type (get-type *expr-list*))
                    (temp nil)
                    (start (cddr *expr-list*)))
                (add-code (format nil "create_list_~a" type))
                (add-code "(")
                (add-code "(")
                (add-code type)
                (add-code "[]")
                (add-code ")")
                (add-code "{")
                (dbg "parse-expression: parse list " *expr-list*)
                (setf *expr-list* (cddr *expr-list*))
                (parse-list)
                (add-code (format nil "}"))
                (add-code ",")
                (setf temp *expr-list*)
                (setf *expr-list* start)
                (add-code (format nil "~a" (count-elements)))
                (setf *expr-list* temp)
                (add-code (format nil ")"))
                (if (not omit)
                    (add-code (format nil ";~%")))
                (return-from parse-expression *expr-list*))))
        (if (numberp (parse-integer (car *expr-list*) :junk-allowed t))
            (progn
              (dbg "parse-expression: NUM block " *block*
                   " number " (car *expr-list*))
              (add-code (car *expr-list*))
              (if (not omit)
                  (add-code (format nil ";~%")))
              (setf *expr-list* (cdr *expr-list*))
              (return-from parse-expression *expr-list*)))
        (if (remove-if-not
             #'(lambda (x)
                 (equal x (get-iter-function-name (car *expr-list*))))
             (hash-table-keys *functions*))
            (progn
              (add-code (get-iter-function-name (car *expr-list*)))
              (zero-arg)
              (if (not omit)
                  (add-code (format nil ";~%")))
              (dbg "parse-expression: parse function symbol "
                   (car *expr-list*))))
        (if (remove-if-not
             #'(lambda (x)
                 (equal x (get-iter-variable-name (car *expr-list*))))
             (hash-table-keys *variables*))
         (progn
           (dbg "parse-expression: VARIABLE "
                (get-iter-variable-name (car *expr-list*)))
           (if (search ">" *current-let-definition*)
               (add-code "&"))
           (add-code (get-iter-variable-name (car *expr-list*)))
           (if (not omit)
               (add-code (format nil ";~%")))
           (zero-arg)
           (setf *expr-list* (cdr *expr-list*))
           (return-from parse-expression)))
        (if (not (or (equal "," (car *expr-list*))
                     (equal "\n" (car *expr-list*))
                     (equal "(" (car *expr-list*))
                     (equal ")" (car *expr-list*))
                     (equal "[" (car *expr-list*))
                     (equal "]" (car *expr-list*))
                     (equal "\"" (car *expr-list*))
                     (equal ";|" (car *expr-list*))
                     (equal "|;" (car *expr-list*))
                     (equal ";" (car *expr-list*))
                     (numberp (parse-integer (car *expr-list*) :junk-allowed t))))
            (progn
              (dbg "parse-expression: SYMBOL " (car *expr-list*))
              (setf *expr-list* (cdr *expr-list*))
              (return-from parse-expression *expr-list*)))
        (if (equal "(" (car *expr-list*))
            (let ((space nil))
              (parse-open-parens)
              (zero-arg)
              (inc-arg)
              (inc-parens)
              (dbg "parse-expression: OPEN parens "
                   *paranteses* " block " *block*)
              ;; omit semicolon for blocks
              (if (or (equal "for" (car *expr-list*))
                      (equal "if" (car *expr-list*))
                      (equal "defn" (car *expr-list*))
                      (equal "let" (car *expr-list*))
                      (equal "module" (car *expr-list*)))
                  (setf space t))
              (parse-call)
              (dbg "parse-expression: CALL END rest " *expr-list*
                   " parens " *paranteses* " block " *block*)
              (if (car *expr-list*)
                  (parse-close-parens))
              (dbg "parse-expression: CLOSE parens " *paranteses* " block " *block*
                   " omit " omit)
              (let ((fn (get-last-function)))
                (dbg "parse-expression: function " fn)
                (if (and
                     (not (equal "i16" fn))
                     (not (equal "i32" fn))
                     (not (equal "i64" fn))
                     (not (equal "f32" fn))
                     (not (equal "f64" fn))
                     (not (equal "bool" fn))
                     (not (equal "b8" fn))
                     (not (equal "c8" fn))
                     (not (equal "i16>" fn))
                     (not (equal "i32>" fn))
                     (not (equal "i64>" fn))
                     (not (equal "f32>" fn))
                     (not (equal "f64>" fn))
                     (not (equal "bool>" fn))
                     (not (equal "b8>" fn))
                     (not (equal "c8>" fn))
                     (not space))
                    (add-code ")")))
              (dec-arg)
              (dec-parens)
              (if (and (not space) (not omit))
                  (add-code (format nil ";~%")))
              (zero-arg)
              (dbg "parse-expression: return")
              (return-from parse-expression))))))
  
(defun parse (expression)
  "Parse expression."
  (let ((expr-list (preprocess expression)))
    (setf *expr-list* expr-list)
    (setf *code_list* '(""))
    (setf *implementation_list* '(""))
    (setf *definition_list* '(""))
    (setf *paranteses* 0)
    (setf  *block* 0)
    (setf *arguments* (make-hash-table))
    (setf *variables* (make-hash-table :test 'equal))
    (setf *functions* (make-hash-table :test 'equal))
    (setf *function-map* (make-hash-table :test 'equal))
    (setf *signatures* (make-hash-table :test 'equal))
    (setf *current-function* (make-hash-table :test 'equal))
    (set-arg 0)
    (setup-signatures)
    (loop while (and (find "(" expr-list :test #'equal)
                     (> (length expr-list) 0)
                     *expr-list*) do
         (if *expr-list*
             (parse-expression))))
  (emit-code-call))
